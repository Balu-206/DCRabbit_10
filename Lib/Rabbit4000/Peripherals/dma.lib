/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/* START LIBRARY DESCRIPTION *************************************************
DMA.LIB

OVERVIEW:
	The interface is designed to to provide the users with a set of functions
	that transfer blocks of data with direct memory access.  This library
   provides high level, low level, and debugging functions for the DMA.

SUPPORT LIB'S:
	none
END DESCRIPTION *************************************************************/

/*** BeginHeader */
#ifndef __DMA_LIB
#define __DMA_LIB

#include <errno.h>							// for EINVAL and EBUSY error codes

#ifdef DMA_DEBUG
	#define _dma_nodebug __debug
#else
	#define _dma_nodebug __nodebug
#endif

#define DMA_CHANNEL_NONE		0xFF
#if _RAB6K
	#define DMA_CHANNEL_ANY		0xFFFF
#else
	#define DMA_CHANNEL_ANY		0xFF
#endif
#define DMA_CHANNEL_0			0x0001
#define DMA_CHANNEL_1			0x0002
#define DMA_CHANNEL_2			0x0004
#define DMA_CHANNEL_3			0x0008
#define DMA_CHANNEL_4			0x0010
#define DMA_CHANNEL_5			0x0020
#define DMA_CHANNEL_6			0x0040
#define DMA_CHANNEL_7			0x0080
#if _RAB6K
	#define DMA_CHANNEL_8         0x0100
	#define DMA_CHANNEL_9         0x0200
	#define DMA_CHANNEL_10        0x0400
	#define DMA_CHANNEL_11        0x0800
	#define DMA_CHANNEL_12        0x1000
	#define DMA_CHANNEL_13        0x2000
	#define DMA_CHANNEL_14        0x4000
	#define DMA_CHANNEL_15        0x8000
#endif
#define DMA_IDP_FIXED			0x00
#define DMA_IDP_ROTATE_FINE	0x80
#define DMA_IDP_ROTATE_COARSE	0xC0

// CONTROL DEFINES
#define DMA_LAST_DESC			0x80	// last descriptor, no repetition
#define DMA_LINK_DESC         0x40	// linked list instead of array
#define DMA_SRC_IOI           0x00	// source selection
#define DMA_SRC_IOE           0x04
#define DMA_SRC_MEMDEC        0x08
#define DMA_SRC_MEM           0x0C
#define DMA_DEST_IOI          0x00	// destination selection
#define DMA_DEST_IOE          0x01
#define DMA_DEST_MEMDEC       0x02
#define DMA_DEST_MEM          0x03

// FLAG DEFINES
#define DMA_F_DEST_DEC			0x0001 // only applicable if dest is memory
#define DMA_F_SRC_DEC			0x0004 // only applicable if src is memory
#define DMA_F_REPEAT				0x0008
#define DMA_F_INTERRUPT			0x0010 // interrupt on completion of descriptor
#define DMA_F_LAST_SPECIAL    0x0020 // last byte gets special treatment
#define DMA_F_STOP_MATCH		0x0100 // enable stop match
#define DMA_F_FALLING         0x0000
#define DMA_F_RISING          0x0200
#define DMA_F_LOW             0x0400
#define DMA_F_HIGH            0x0600
#define DMA_F_PD2             0x1000
#define DMA_F_PE2             0x2000
#define DMA_F_PE6             0x3000
#define DMA_F_PD3             0x1800
#define DMA_F_PE3             0x2800
#define DMA_F_PE7					0x3800
#define DMA_F_TIMER				0x4000 // enable dma timer
#define DMA_F_TIMER_1BPR		0x8000 // timed transfer 1 byte per request

//Special Control Register Flags
#define DMA_SC_USB_RX		0x80 //Enable DMA for auto USB receive chan operation
#define DMA_SC_USB_TX		0xC0 //Enable DMA for auto USB transmit chan operation

#define DMA_SC_CS_OFF		0x10 //Disable cycle-steal operation

#define DMA_SC_DC_SRC		0x08 //Disconnect src DMA request(full for buff Transfer)
#define DMA_SC_SRC_FIXED	0x04 //Source address fixed, independant of type
#define DMA_SC_DC_DEST		0x02 //Disconnect dest DMA request (full for buff transfer)
#define DMA_SC_DEST_FIXED  0x01 //Destination address fixed, independant of type
// MACRO Definitions:
#if _RAB6K
	#define DMAstartDirect(channel) WrPortI16(DMCSLR, 1 << channel);
	#define DMAstartAuto(channel)   WrPortI16(DMALLR, 1 << channel);
	#define DMAstopDirect(channel)  WrPortI16(DMHLR,  1 << channel);
#else
	#define DMAstartDirect(channel) WrPortI(DMCSR, NULL, 1 << channel);
	#define DMAstartAuto(channel)   WrPortI(DMALR, NULL, 1 << channel);
	#define DMAstopDirect(channel)  WrPortI(DMHR,  NULL, 1 << channel);
#endif

typedef unsigned long dma_addr_t;
typedef unsigned int dma_chan_t;

// DMA buffer descriptor struct
typedef struct {
   char           frameStatus;
   char           chanControl;
   unsigned int   bufLength;
   dma_addr_t     srcAddress;    // note that uppermost byte unused
   dma_addr_t     destAddress;   // note that uppermost byte unused
   dma_addr_t     linkAddress;   // note that uppermost byte unused
} DMABufDesc;

// One without link field: use for array descriptors
typedef struct {
   char           frameStatus;
   char           chanControl;
   unsigned int   bufLength;
   dma_addr_t     srcAddress;    // note that uppermost byte unused
   dma_addr_t     destAddress;   // note that uppermost byte unused
} DMABufDesc12;
/*** EndHeader */

/*** BeginHeader _dma_bd, _dma_allocCnt, _dma_chanInUse, _dma_len */
extern unsigned int _dma_len[DMA_CHAN_CNT];
extern char _dma_allocCnt[DMA_CHAN_CNT];  //number of times allocated
#if _RAB6K
	extern unsigned int _dma_chanInUse; //which channels are currently in use
#else
	extern char	_dma_chanInUse;
#endif
extern dma_addr_t _dma_bd[DMA_CHAN_CNT];
/*** EndHeader */

unsigned int _dma_len[DMA_CHAN_CNT];
char _dma_allocCnt[DMA_CHAN_CNT];
#if _RAB6K
	unsigned int _dma_chanInUse;
#else
	char _dma_chanInUse;
#endif
dma_addr_t _dma_bd[DMA_CHAN_CNT];

//////////////////////////////////////////////////////////////////////////////
/* START FUNCTION DESCRIPTION ************************************************
DMAstartDirect						<DMA.LIB>

syntax:	void DMAstartDirect(int channel)

PARAMETER1:		DMA channel (obtainable through DMAhandle2chan)

DESCRIPTION:   This function is defined to the following:

					WrPortI(DMCSR, NULL, 1 << channel); (Rabbit 4000/5000)
					WrPortI(DMCSLR, NULL, 1 << channel); (Rabbit 6000)

               Start (or restart) the corresponding DMA channel using the
               contents of the DMA channel registers. This command should only
               be used after all the DMA channel registers have been loaded.

RETURN VALUE:	none.

SEE ALSO:		DMAstartAuto, DMAstopDirect
END DESCRIPTION *************************************************************/

/* START FUNCTION DESCRIPTION ************************************************
DMAstartAuto						<DMA.LIB>

syntax:	void DMAstartAuto(int channel)

PARAMETER1:		DMA channel (obtainable through DMAhandle2chan)

DESCRIPTION:   This function is defined to the following:

					WrPortI(DMALR, NULL, 1 << channel); (Rabbit 4000/5000)
					WrPortI(DMALLR, NULL, 1 << channel); (Rabbit 6000)

               Start (using auto-load) the corresponding DMA channel, using the
               buffer descriptor in memory addressed by the Initial Address
               Register. This command should only be used after the Initial
               Address has been loaded.

RETURN VALUE:	none.

SEE ALSO:		DMAstartDirect, DMAstopDirect
END DESCRIPTION *************************************************************/

/* START FUNCTION DESCRIPTION ************************************************
DMAstopDirect						<DMA.LIB>

syntax:	void DMAstopDirect(int channel)

PARAMETER1:		DMA channel (obtainable through DMAhandle2chan)

DESCRIPTION:   This function is defined to the following:

					WrPortI(DMHR, NULL, 1 << channel); (Rabbit 4000/5000)
					WrPortI(DMHLR, NULL, 1 << channel); (Rabbit 6000)

               Halt the corresponding DMA channel. The DMA registers obtain the
               current state and the DMA can be restarted using the DMCSR
               (DMCSLR/DMCSHR for Rabbit 6000).

RETURN VALUE:	none.

SEE ALSO:		DMAstartAuto, DMAstartDirect
END DESCRIPTION *************************************************************/

/*** BeginHeader DMAsetParameters */
int DMAsetParameters(unsigned int transfer_pri,
							unsigned int interrupt_pri,
                     unsigned int inter_dma_pri,
                     unsigned int chunkiness,
                     unsigned int min_cpu_pct);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ************************************************
DMAsetParameters					<DMA.LIB>

syntax:	int DMAsetParameters(unsigned int transfer_pri,
										unsigned int interrupt_pri,
                  			   unsigned int inter_dma_pri,
			                     unsigned int chunkiness,
         			            unsigned int min_cpu_pct)

PARAMETER1: DMA transfer priority (0-3) - Transfers can occur when the CPU
            interrupt priority is less than or equal to this value.
PARAMETER2:	DMA interrupt priority (0-3) - A value of 0 will disable the
            DMA interrupts.
PARAMETER3: Relative prioritization amongst the DMA channels.  It is one of
				the following constants:
            DMA_IDP_FIXED - fixed prioriteis, with higher channel numbers
            	taking precedence;
            DMA_IDP_ROTATE_FINE - priorities are rotated after every byte
            	transferred;
            DMA_IDP_ROTATE_COARSE - priorities rotated after every transfer
            	request, the size of which is determined by the 'chunkiness'
               parameter.
PARAMETER4: Maximum transfer burst size. Allowed values are 1, 2, 3, 4, 8,
				16, 32, or 64.  Other numbers will be rounded down to the
            nearest allowed value.
PARAMETER5: A number between 0 and 100 describing the minimum (worst-case)
            relative amount of time that the CPU will control the bus vs
            the DMA time. Internally, this function uses this figure to
            determine the 'minimum clocks between bursts' hardware setting.
            The figure will be rounded in favor of the CPU, up to the
            maximum possible hardware setting.
DESCRIPTION:  This function sets up DMA parameters.  Warning: If this board
            is using the Rabbit 4000 built-in ethernet (DMAETH.LIB) then
            be sure to use an interrupt priority and transfer level
            of at least 2 (or whatever you set for DMAETH_NET_IP if not
            using the default).  Test ethernet performance to ensure the DMA
            parameters do not cause problems.

            The chunkiness parameter determines the amount of CPU time
            needed to transfer data according to this chart:

            chunkiness:	1   2   3   4   8   16  32  64
            CPU_cycles: 11  15  19  23  39  71  135 263

            The minimum time between bursts is calculated with this formula

            wait_time = (cpu_time * min_cpu_pct) / (100-min_cpu_pct);

            This is then rounded up to the nearest value out of 12, 16, 24,
            32, 64, 128, 256, or 512.

				!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            PLEASE NOTE: This method affects DMA transfer interrupt priority.
            In the Rabbit 6000, Cycle-Stealing and Non-Cycle-Stealing DMA
            transfers SHARE THE SAME PRIORITY. It is important to know that the
            function DMAsetParameters ALSO affects DMA transfer interrupt
            priority. This was done to support backwards compatiblity. To avoid
            confusion regarding this shared functionality, please use the same
            value for the first two parameters of DMAsetParameters and
            DMAsetCSParameters.
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


RETURN VALUE:	0 for success, -EINVAL for an error (debug mode only).

SEE ALSO:
END DESCRIPTION *************************************************************/

_dma_nodebug
int DMAsetParameters(unsigned int transfer_pri,
							unsigned int interrupt_pri,
                     unsigned int inter_dma_pri,
                     unsigned int chunkiness,
                     unsigned int min_cpu_pct)
{
	auto int wait_time, cpu_time;
   auto char dmcr_val, dmtcr_val;

#ifdef DMA_DEBUG
	if(inter_dma_pri != DMA_IDP_FIXED &&
   	inter_dma_pri != DMA_IDP_ROTATE_FINE &&
      inter_dma_pri != DMA_IDP_ROTATE_COARSE){
    	printf("Error: Invalid argument.\n");
		return -EINVAL;
   }
	if(transfer_pri > 3 || interrupt_pri > 3){
    	printf("Error: Invalid interrupt priority level.\n");
		return -EINVAL;
   }
   #ifdef PKTDRV_H
	 	#if USING_DMAETH || USING_DMAETH100
	   printf
	     ("Warning: DMAsetParameters may override inbuilt ethernet settings.\n");
	   #endif
	#endif
#endif

	dmtcr_val = inter_dma_pri;

	/***************************************************************************
	This section rounds down the chunkiness to only the allowed values, and sets
		the DMTCR value appropriately.  cpu_time is number of clocks needed for
		each burst.

	These are values from the following table:
		1 byte per burst		|	11 clocks
		2 bytes per burst		|	15 clocks
		3 bytes per burst		|	19 clocks
		4 bytes per burst		|	23 clocks
		8 bytes per burst		|	39 clocks
		16 bytes per burst	|	71 clocks
		32 bytes per burst	|	135 clocks
		64 bytes per burst	|	263 clocks
	***************************************************************************/
   if(chunkiness & 0xFFC0){			  	// This covers all numbers >= 64
   	dmtcr_val |= 0x38;               // max 64 bytes per burst
      cpu_time = 263;
   }
   else if(chunkiness & 0x0020){      	// This covers all numbers >= 32
   	dmtcr_val |= 0x30;               // max 32 bytes per burst
      cpu_time = 135;
   }
   else if(chunkiness & 0x0010){      	// This covers all numbers >= 16
   	dmtcr_val |= 0x28;               // max 16 bytes per burst
      cpu_time = 71;
   }
   else if(chunkiness & 0x0008){			// This covers all numbers >= 8
   	dmtcr_val |= 0x20;               // max 8 bytes per burst
      cpu_time = 39;
   }
   else if(chunkiness & 0x0004){       // This covers all numbers >= 4
   	dmtcr_val |= 0x18;               // max 4 bytes per burst
      cpu_time = 23;
   }
   else if(chunkiness == 3){      		// This covers the number 3
   	dmtcr_val |= 0x10;               // max 3 bytes per burst
      cpu_time = 19;
   }
   else if(chunkiness == 2){      		// This covers the number 2
   	dmtcr_val |= 0x08;               // max 2 bytes per burst
      cpu_time = 15;
   }
   else {                              // This covers the number 1 (and 0)
      cpu_time = 11;                   // max 1 bytes per burst
	}

   if(min_cpu_pct >= 100)
   	wait_time = 512;                 // maximum
   else
	  	wait_time = (cpu_time * min_cpu_pct) / (100-min_cpu_pct);

	// This section loads DMTCR with the appropriate value based on the amount
	// of time between bursts (based on the equation:
	// wait_time = (cpu_time * min_cpu_pct)/(100 - min_cpu_pct)
   if(wait_time > 12){
	   if(wait_time <= 16)
	      dmtcr_val |= 0x01;
	   else if(wait_time <= 24)
	      dmtcr_val |= 0x02;
	   else if(wait_time <= 32)
	      dmtcr_val |= 0x03;
	   else if(wait_time <= 64)
	      dmtcr_val |= 0x04;
	   else if(wait_time <= 128)
	      dmtcr_val |= 0x05;
	   else if(wait_time <= 256)
	      dmtcr_val |= 0x06;
	   else
	      dmtcr_val |= 0x07;
   }
	// vantive 25230 - the following made unconditional.  Otherwise, use of
	// serial plus network may completely inhibit DMA interrupts.
	WrPortI(DMTCR, NULL, dmtcr_val);
   WrPortI(DMCR, NULL, ((transfer_pri << 2) | interrupt_pri) & 0x0F);
	return 0;
}
/*** BeginHeader DMAsetCSParameters */
int DMAsetCSParameters(unsigned int transfer_pri,
							unsigned int interrupt_pri,
                     unsigned int inter_dma_pri,
                     unsigned int chunkiness);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ************************************************
DMAsetCSParameters					<DMA.LIB>

syntax:	int DMAsetCSParameters(unsigned int transfer_pri,
										unsigned int interrupt_pri,
                  			   unsigned int inter_dma_pri,
			                     unsigned int chunkiness)

PARAMETER1: DMA transfer priority (0-3) - Transfers can occur when the CPU
            interrupt priority is less than or equal to this value.
PARAMETER2:	DMA interrupt priority (0-3) - A value of 0 will disable the
            DMA interrupts.
PARAMETER3: Relative prioritization amongst the DMA channels.  It is one of
				the following constants:
            DMA_IDP_FIXED - fixed prioriteis, with higher channel numbers
            	taking precedence;
            DMA_IDP_ROTATE_FINE - priorities are rotated after every byte
            	transferred;
            DMA_IDP_ROTATE_COARSE - priorities rotated after every transfer
            	request, the size of which is determined by the 'chunkiness'
               parameter.
PARAMETER4: Maximum transfer burst size. Allowed values are 1, 2, 3, 4, 8,
				16, 32, or 64.  Other numbers will be rounded down to the
            nearest allowed value.
DESCRIPTION:  This function sets up Cycle Stealing DMA parameters.
				Warning: If this board is using the Rabbit 4000 built-in ethernet
				(DMAETH.LIB) then be sure to use an interrupt priority and transfer
				level of at least 2 (or whatever you set for DMAETH_NET_IP if not
            using the default).  Test ethernet performance to ensure the DMA
            parameters do not cause problems.

            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            PLEASE NOTE: This method affects DMA transfer interrupt priority.
            In the Rabbit 6000, Cycle-Stealing and Non-Cycle-Stealing DMA
            transfers SHARE THE SAME PRIORITY. It is important to know that the
            function DMAsetParameters ALSO affects DMA transfer interrupt
            priority. This was done to support backwards compatiblity. To avoid
            confusion regarding this shared functionality, please use the same
            value for the first two parameters of DMAsetParameters and
            DMAsetCSParameters.

				ALSO PLEASE NOTE: Cycle-stealing mode is enabled by DEFAULT on the
            Rabbit 6000. Cycle-stealing is only available on the Rabbit 6000
            (or above) for DMA transfers that use internal memory only
            (i.e. mem2mem, mem2ioi, ioi2mem).If you attempt a DMA transfer
            that uses something other than internal memory (mem2ioe, ioe2mem)
            these settings (excluding the first two parameters) WILL NOT APPLY.
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

RETURN VALUE:	0 for success, -EINVAL for an error (debug mode only).

SEE ALSO:
END DESCRIPTION *************************************************************/

_dma_nodebug
int DMAsetCSParameters(unsigned int transfer_pri,
							unsigned int interrupt_pri,
                     unsigned int inter_dma_pri,
                     unsigned int chunkiness)
{
	#if _RAB6K
	   auto int wait_time, cpu_time;
	   auto char dmcr_val, dcstcr_val;

	   #ifdef DMA_DEBUG
	      if(inter_dma_pri != DMA_IDP_FIXED &&
	         inter_dma_pri != DMA_IDP_ROTATE_FINE &&
	         inter_dma_pri != DMA_IDP_ROTATE_COARSE){
	         printf("Error: Invalid argument.\n");
	         return -EINVAL;
	      }
	      if(transfer_pri > 3 || interrupt_pri > 3){
	         printf("Error: Invalid interrupt priority level.\n");
	         return -EINVAL;
	      }
	      #ifdef PKTDRV_H
	         #if USING_DMAETH || USING_DMAETH100
	         printf
	           ("Warning: DMAsetCSParameters may override inbuilt ethernet settings.\n");
	         #endif
	      #endif
	   #endif

	   dcstcr_val = inter_dma_pri;

	   /***************************************************************************
	   This section rounds down the chunkiness to only the allowed values, and sets
	      the DCSTCR value appropriately.
	   ***************************************************************************/
	   if(chunkiness & 0xFFC0){            // This covers all numbers >= 64
	      dcstcr_val |= 0x38;              // max 64 bytes per burst
	   }
	   else if(chunkiness & 0x0020){       // This covers all numbers >= 32
	      dcstcr_val |= 0x30;               // max 32 bytes per burst
	   }
	   else if(chunkiness & 0x0010){       // This covers all numbers >= 16
	      dcstcr_val |= 0x28;               // max 16 bytes per burst
	   }
	   else if(chunkiness & 0x0008){       // This covers all numbers >= 8
	      dcstcr_val |= 0x20;               // max 8 bytes per burst
	   }
	   else if(chunkiness & 0x0004){       // This covers all numbers >= 4
	      dcstcr_val |= 0x18;               // max 4 bytes per burst
	   }
	   else if(chunkiness == 3){           // This covers the number 3
	      dcstcr_val |= 0x10;               // max 3 bytes per burst
	   }
	   else if(chunkiness == 2){           // This covers the number 2
	      dcstcr_val |= 0x08;               // max 2 bytes per burst
	   }
	   // vantive 25230 - the following made unconditional.  Otherwise, use of
	   // serial plus network may completely inhibit DMA interrupts.
	   WrPortI(DCSTCR, NULL, dcstcr_val);
	   WrPortI(DMCR, NULL, ((transfer_pri << 2) | interrupt_pri) & 0x0F);
	   return 0;
	#else
		#warnt DMAsetCSParameters() should only be used on the Rabbit 6000 or above
		return 0;
	#endif
}
/*** BeginHeader DMAalloc */
dma_chan_t DMAalloc(unsigned int channel_mask, int highest);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ************************************************
DMAalloc								<DMA.LIB>

syntax:	dma_chan_t DMAalloc(int channel_mask, int highest)

PARAMETER1:		a mask of all the acceptable channels to choose from.
PARAMETER2:		a bool indicating whether to search for an available channel
					from 8 (16 if Rabbit 6000) or from 0.

DESCRIPTION:	This function returns a handle to an available channel.  The
					handle contains the channel number and a validation byte to
               prevent use of an old handle after deallocation.

RETURN VALUE:	Returns a handle to an available channel if one is
					unallocated. If none are available it returns
               DMA_CHANNEL_NONE

SEE ALSO:		DMAunalloc, DMAhandle2chan
END DESCRIPTION *************************************************************/

_dma_nodebug
dma_chan_t DMAalloc(unsigned int channel_mask, int highest)
{
	auto unsigned int i, j, k;

	#GLOBAL_INIT
	{  // initialize channel allocation counters
	   _dma_chanInUse = 0;
	   memset(_dma_len, 0, sizeof(_dma_len));
	   memset(_dma_allocCnt, 0, sizeof(_dma_allocCnt));
	   memset(_dma_bd, 0, sizeof(_dma_bd));
		//clear possible DMA setup residue following a soft reset
		// load 0xFFFF value to DMH(L/H)R register to halt all DMA channel
		#if _RAB6K
			WrPortI16(DMHLR, 0xFFFF);
			//printf("GLOBAL Init executed\n");
		#else
			WrPortI(DMHR,NULL,0xFF);
		#endif
      //load 0x00 value to DMRxCR registers to disable DMA requests
      WrPortI16(DMR0CR, 0x0000);
	} //end of #GLOBAL_INIT
   if(highest) {
      for(j = DMA_CHAN_CNT-1, i = 1u<<(DMA_CHAN_CNT-1); i; i >>= 1, --j) {
         if(!(_dma_chanInUse & i) && (i & channel_mask)) {
            _dma_chanInUse |= i;
            return (j | (_dma_allocCnt[j] << 8));
         }
      }
   }
   else {
      for(i = 0x0001, j = 0; j < DMA_CHAN_CNT; i <<= 1, ++j) {
         if(!(_dma_chanInUse & i) && (i & channel_mask)) {
            _dma_chanInUse |= i;
            return (j | (_dma_allocCnt[j] << 8));
         }
      }
   }
   return DMA_CHANNEL_NONE; //return DMA_CHANNEL_NONE if no channels available
}
/*** BeginHeader DMAunalloc */
int DMAunalloc(dma_chan_t handle);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ************************************************
DMAunalloc							<DMA.LIB>

syntax:	int DMAunalloc(dma_chan_t handle)

PARAMETER1:		a handle from the DMAalloc function.

DESCRIPTION:	This function returns a handle to an available channel.  The
					handle contains the channel number and a validation byte to
               prevent use of an old handle after deallocation.

RETURN VALUE:  returns 0 on success, -EINVAL for an error.

SEE ALSO:		DMAalloc, DMAhandle2chan
END DESCRIPTION *************************************************************/

_dma_nodebug
int DMAunalloc(dma_chan_t handle)
{
	auto unsigned int channel, mask;
	#if _RAB6K
		mask = 0x000F;
	#else
		mask = 0x0007;
	#endif

   channel = DMAhandle2chan(handle);
   if(channel == DMA_CHANNEL_NONE)
   	return -EINVAL;

   _dma_len[channel] = 0;
   _dma_allocCnt[channel]++;
   _dma_chanInUse &= ~(1 << (handle & mask));
   return 0;
}

/*** BeginHeader DMAtimerSetup */
void DMAtimerSetup(unsigned int divisor);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ************************************************
DMAtimerSetup							<DMA.LIB>

syntax:	void DMAtimerSetup(unsigned int divisor)

PARAMETER1:		16 bit divisor for the DMA timer.

DESCRIPTION:	This function sets up the DMA 16 bit divisor.  In order to use
					the divisor, the DMA_F_TIMER flag must be passed to the
               transfer function.

RETURN VALUE:  none

SEE ALSO:		DMAmem2mem, DMAmatchSetup
END DESCRIPTION *************************************************************/

_dma_nodebug
void DMAtimerSetup(unsigned int divisor)
{
	WrPortI16( DTRDLR, divisor);
}
/*** BeginHeader DMAmatchSetup */
int DMAmatchSetup(dma_chan_t handle, int mask, int byte);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ************************************************
DMAmatchSetup							<DMA.LIB>

syntax:	int DMAmatchSetup(dma_chan_t handle, int mask, int byte)

PARAMETER1:		handle for the DMA channel.
PARAMETER2:		Mask for termination byte (param 3). A value of all zeros
					disables the termination byte match feature. A value of all ones
					uses the full termination byte for comparison.
PARAMETER3:		Byte that, if matched, will terminate the buffer.

DESCRIPTION:	This function sets up the mask and match registers for the DMA.
					These registers are only used when the DMA_F_STOP_MATCH flag is
               passed to the transfer function.

RETURN VALUE:  0 on success, -EINVAL if <handle> is not valid

SEE ALSO:		DMAmem2mem, DMAmatchSetup
END DESCRIPTION *************************************************************/

_dma_nodebug
int DMAmatchSetup(dma_chan_t handle, int mask, int byte)
{

	auto unsigned int channel,DxTMR,DxTBR;
	channel = DMAhandle2chan(handle);
   if(channel == DMA_CHANNEL_NONE)
   	return -EINVAL;
   #if _RAB6K
	   if(channel >= 8){
	      DxTMR = D8TMR;
	      DxTBR = D8TBR;
	   }
	   else {
	      DxTMR = D0TMR;
	      DxTBR = D0TBR;
	   }
	#else
      DxTMR = D0TMR;
      DxTBR = D0TBR;
	#endif
   #asm
	clr   hl
	   ld    iy,0
	   add   iy,sp
	   ld    a, (iy+@sp+channel)
	   and   a,0x07   //if this is a channel >= 8, mask out the MSB
	   ld    L,a
	   xor   a
	   rl    hl
	   rl    hl
	   rl    hl
	   rl    hl //multiply channel by 16
	   ex    bc, hl
	   ld    hl, (sp+@sp+DxTMR) //get the base register address
	   add   hl, bc //add the offset
	   ld    a, (iy+@sp+mask)
	   ioi   ld (hl), a //load the termination mask into DxTMR
	   ld    hl, (sp+@sp+DxTBR) // get the base register address
	   add   hl, bc //add the offset
	   ld    a, (iy+@sp+byte)
	   ioi   ld (hl), a //load the termination byte value into DxTBR
   #endasm
   return 0;
}
/*** BeginHeader DMAspecialSetup */
int DMAspecialSetup(dma_chan_t handle, char flags);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ************************************************
DMAspecialSetup							<DMA.LIB>

syntax:	int DMAspecialSetup(dma_chan_t handle, char flags)

PARAMETER1:		handle for the DMA channel.

PARAMETER2:		DMA_SC_USB_RX enables DMA for automatic network port D (USB)
									  receive channel operation.

					DMA_SC_USB_TX enables DMA for automatic network port D (USB)
									  transmit channel operation.

					(Note: DMA_SC_USB_RX and DMA_SC_USB_TX are mutally exclusive and
						both should not be passed in as part of the flags variable
					 at the same time)

					DMA_SC_CS_OFF	disables cycle stealing mode

					DMA_SC_DC_SRC	disconnects source DMA request (for full buffer
					transfer)

					DMA_SC_SRC_FIXED specifies that the	source address is fixed,
					independant of type

					DMA_SC_DC_DEST	disconnects destination DMA request (for full
					buffer transfer)

					DMA_SC_DEST_FIXED specifies that the destination address is
					fixed, independant of type

DESCRIPTION:	This function sets the DMA special control register that
               corresponds to the channel whose handle was passed in as
               parameter 1. The special control register is set to the value of
       			flags.

					!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       			PLEASE NOTE: Cycle-stealing mode is enabled by DEFAULT on the
       			Rabbit 6000. Cycle-stealing is only available on the Rabbit 6000
       			(or above) for DMA transfers that use internal memory only
       			(i.e. mem2mem, mem2ioi, ioi2mem). If you attempt a DMA transfer
       			that uses something other than internal memory (mem2ioe, ioe2mem)
       			these settings WILL NOT APPLY.
       			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

RETURN VALUE:  0 on success or -EINVAL if <handle> is invalid.

SEE ALSO:		DMAmem2mem, DMAmem2ioi, DMAioi2mem, DMAsetCSParameters
END DESCRIPTION *************************************************************/
_dma_nodebug
int DMAspecialSetup(dma_chan_t handle, char flags)
{
	#if _RAB6K
	   auto unsigned int channel,DxSCR;

	   channel = DMAhandle2chan(handle);

	   if(channel == DMA_CHANNEL_NONE){
	      return -EINVAL;
	   }

      if(channel >= 8){
         DxSCR = D8SCR;
      }
      else {
         DxSCR = D0SCR;
      }
	   #asm
			clr   hl
	      ld    iy,0
	      add   iy,sp
	      ld    a, (iy+@sp+channel)
	      and   a,0x07   //if this is a channel >= 8, mask out the MSB
	      ld    L,a
	      xor   a
	      rl    hl
	      rl    hl
	      rl    hl
	      rl    hl
	      ex    bc, hl
	      ld    hl, (sp+@sp+DxSCR)
	      add   hl, bc
	      ld    a, (iy+@sp+flags)
	      ioi   ld (hl), a
	   #endasm
 	#endif

 	return 0;
}
//////////////////////////////////////////////////////////////////////////////
// This is a support function for DMA transfer functions

/*** BeginHeader DMAflagSetup */
int  DMAflagSetup(int channel, unsigned int flags);
/*** EndHeader */
_dma_nodebug
int  DMAflagSetup(int channel, unsigned int flags)
{
	auto int retval = 0;
	auto unsigned int DxTMR;
	#if _RAB6K
	   if(channel < 8){
	      DxTMR = D0TMR;
	   }
	   else {
	      DxTMR = D8TMR;
	   }
	#else
		DxTMR = D0TMR;
	#endif
   // check flags for character termination (DMA_F_STOP_MATCH)
   if(!(flags & DMA_F_STOP_MATCH)) { //DMA_F_STOP_MATCH not enabled

	   #asm
			ld    hl, (sp+@sp+channel)
	      #if _RAB6K
	         ld    a,L
	         and   a,0x07
	         ld    L,a
	      #endif
	      ex    de, hl
	      ld    bc, 0x0010
	      mul                        ; bc = channel * 16
	      ld    hl, (sp+@sp+DxTMR)   ; hl = D0TMR/D8TMR
	      ex    de,hl          ; de = D0TMR/D8TMR
	      ex    bc, hl            ; hl = channel * 16
	      add   hl, de            ; hl = D0TMR/D8TMR + (channel * 16)
	      ioi   ld (hl), 0x00        ; clear DxTMR.
	   #endasm
	}

   if(flags & DMA_F_TIMER) {
      #asm
	      ld    iy, 0x0000
	      add   iy, sp
	      ld    a, (iy+@sp+channel)
	      ld    d, a
	      ld    a, (iy+@sp+flags+1)
	      ld    hl, DMA_F_TIMER_1BPR
	      and   h
	      cpl
	      rrca             ; This code assumes DMA_F_TIMER_1BPR = 0x8000 and
	      rrca              ; if not flagged, we must load 0x10 into DTRCR
	      #if _RAB6K
	         and   0x20
	      #else
	         rrca
	         and   0x10
	      #endif
	      or    0x80
	      or    d
	      ioi   ld (DTRCR), a
      #endasm
   }

   // check flags for gated transfer via parallel port pin
	#asm
   ld    hl, (sp+@sp+flags)
   ld    a, h
   and   0x3E
   jp    z, .no_gate

   ld		L, a
   bit   3, L        				; bit 3 determines even or odd parallel port
   jr		nz, .odd

.even:
	ld		iy, DMR0CR
   jr		.load_gate
.odd:
	ld		iy, DMR1CR
.load_gate:

   ioi	ld	a, (iy)
   and   0xC0
   jr    nz, .gate_busy
                                 ; bits 1 and 2 determine the polarity
   ld		a, L                    ; bits 4 and 5 determine which port:
   and	0x36                    ; 		PD2, PE2 or PE6
   rlca                          ; these bits correspond to DMRxCR bits
   rlca                          ;     3, 4, 6 and 7
   #if _RAB6K
   	ld		b,a							; save a
   	sla	a
   	ex		af,af'
   	ld		a,b
   	and	a,0xC0
   	ld		b,a
   	ex		af,af'
   	and	a,0x3F
   	or		b
   #endif
   ld		hl, (sp+@sp+channel)
	or		L                       ; or this with the channel #
   ioi	ld	(iy), a					; 		and load into DMRxCR
   jp		.no_gate

.gate_busy:
	ld		hl, EBUSY;
	ld		(sp+@sp+retval), hl
.no_gate:
	#endasm

#ifdef DMA_VERBOSE
	if (!retval)
	{
		DMAprintRegs(channel, 1);
	}
#endif
   return retval;
}

/*** BeginHeader DMAmem2mem */
int DMAmem2mem(dma_chan_t handle,
					dma_addr_t dest,
               dma_addr_t src,
               unsigned int len,
               unsigned int flags);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ************************************************
DMAmem2mem							<DMA.LIB>

syntax:	int DMAmem2mem(dma_chan_t handle,
	                     dma_addr_t dest,
	                     dma_addr_t src,
	                     unsigned int len,
	                     unsigned int flags)

PARAMETER1:	handle for channel to use in transfer.
PARAMETER2: memory destination address
PARAMETER3: memory location source address
PARAMETER4: length to send (cannot equal zero)
PARAMETER5: DMA_F_REPEAT indicates that the transfer will be a cycle.

            DMA_F_INTERRUPT indicates an interrupt will
            be triggered at the completion of the transfer.  The interrupt
            vector and function must be set up in the user's code.

            DMA_F_LAST_SPECIAL (only for ethernet or HDLC peripherals)
           	Internal Source: Status byte written to initial buffer
            	descriptor before last data.
            Internal Destination: Last byte written to offset address
              	for frame termination.
            All Others: no effect.

            DMA_F_SRC_DEC only for transfers with memory source. Indicates
            the source address should be decremented. (If not specified, a
            memory source address is incremented.)

            DMA_F_DEST_DEC only for transfers with memory destination.
            Indicates the destination address should be decremented. (If
            not specified, a memory destination address is incremented.)

				DMA_F_STOP_MATCH indicates whether or not to stop the dma
            transfer when a character is reached.  The match byte and mask
            should have previously been set by calling the DMAmatchSetup()
            function.

            DMA_F_TIMER indicates the DMA timer will be used.  The divisor
            should have already been set by calling the DMAtimerSetup()
            function.  DMA_F_TIMER_1BPR indicates that the timed transfers
            will send one byte per request instead of the entire descriptor

            Only one of the following flags (if any) should be set.  They
            indicate that the DMA transfer is gated using the named pin:
				DMA_F_PD2, DMA_F_PE2, DMA_F_PE6, DMA_F_PD3, DMA_F_PE3,
            DMA_F_PE7

				The following flags indicate the polarity of the gating signal:
	         DMA_F_FALLING (default), DMA_F_RISING, DMA_F_LOW, DMA_F_HIGH

DESCRIPTION:	This function performs an immediate DMA operation from
					memory to memory.

RETURN VALUE:  0 for success.
					-EINVAL for an invalid handle.
               -EBUSY if resources are busy.

SEE ALSO: 		DMAcompleted, DMAstop
END DESCRIPTION *************************************************************/

_dma_nodebug
int DMAmem2mem(dma_chan_t handle,
					dma_addr_t dest,
               dma_addr_t src,
               unsigned int len,
               unsigned int flags)
{
	auto char control;
   auto unsigned int channel;
	static dma_addr_t descPtr;

	channel = DMAhandle2chan(handle);
   if(channel == DMA_CHANNEL_NONE)
   	return -EINVAL;

// This asm block sets up the value to be written to the DMA control register
// 1. If destination is memory and address is to decrement: X1 = DMA_F_DEST_DEC
// 2. If source is memory and address is to decrement: X1 = DMA_F_SRC_DEC
// 3. Both 1 and 2: X1 = DMA_F_DEST_DEC | DMA_F_SRC_DEC
// X2 contains the source and destination. e.g. X2 = DMA_SRC_MEM | DMA_DEST_MEM
   #asm _dma_nodebug
   ld    iy, 0x0000
	add   iy, sp
	ld    L, (iy+@sp+flags)
	ld    a, L
	and   DMA_F_INTERRUPT | DMA_F_LAST_SPECIAL
	ld    h, a
	ld    a, DMA_F_SRC_DEC | DMA_F_DEST_DEC //X1
	and   L
	cpl
	and   DMA_SRC_MEM | DMA_DEST_MEM //X2
	or    h
	ld    (iy+@sp+control), a
   #endasm
   // This helper function takes care of the other flag values.
   if(DMAflagSetup(channel, flags))
   	return -EBUSY;

   _dma_len[channel] = len;

   if(flags & DMA_F_REPEAT) {
   	control |= DMA_LINK_DESC;
		if(_dma_bd[channel] == 0L)
   		descPtr = _dma_bd[channel] = xalloc(sizeof(DMABufDesc));
	   DMAsetBufDesc(control, len, src, dest, descPtr, descPtr, 16);
	   DMAloadBufDesc(channel, &descPtr);
	   DMAstartAuto(channel);
   }
   else {
   	control |= DMA_LAST_DESC;		// make this desc the final one
		DMAsetDirect(channel, control, len, src, dest, 0ul);
		//DMAprintRegs(channel, 1);
		DMAstartDirect(channel);
   }

   return 0;
}

/*** BeginHeader DMAmem2ioe */
int DMAmem2ioe(dma_chan_t handle,
					unsigned int dest,
               dma_addr_t src,
               unsigned int len,
               unsigned int flags);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ************************************************
DMAmem2ioe							<DMA.LIB>

syntax:	int DMAmem2ioe(dma_chan_t handle,
	                     unsigned int dest,
	                     dma_addr_t src,
	                     unsigned int len,
	                     unsigned int flags)

PARAMETER1:	handle for channel to use in transfer.
PARAMETER2: ioe destination address
PARAMETER3: memory location source
PARAMETER4: length to send (cannot equal zero)
PARAMETER5: DMA_F_REPEAT indicates that the transfer will be a cycle.

            DMA_F_INTERRUPT indicates an interrupt will
            be triggered at the completion of the transfer.  The interrupt
            vector and function must be set up in the user's code.

            DMA_F_LAST_SPECIAL (only for ethernet or HDLC peripherals)
           	Internal Source: Status byte written to initial buffer
            	descriptor before last data.
            Internal Destination: Last byte written to offset address
              	for frame termination.
            All Others: no effect.

            DMA_F_SRC_DEC only for transfers with memory source. Indicates
            the source address should be decremented. (If not specified, a
            memory source address is incremented.)

            DMA_F_DEST_DEC only for transfers with memory destination.
            Indicates the destination address should be decremented. (If
            not specified, a memory destination address is incremented.)

				DMA_F_STOP_MATCH indicates whether or not to stop the dma
            transfer when a character is reached.  The match byte and mask
            should have previously been set by calling the DMAmatchSetup()
            function.

            DMA_F_TIMER indicates the DMA timer will be used.  The divisor
            should have already been set by calling the DMAtimerSetup()
            function.  DMA_F_TIMER_1BPR indicates that the timed transfers
            will send one byte per request instead of the entire descriptor

            Only one of the following flags (if any) should be set.  They
            indicate that the DMA transfer is gated using the named pin:
				DMA_F_PD2, DMA_F_PE2, DMA_F_PE6, DMA_F_PD3, DMA_F_PE3,
            DMA_F_PE7

				The following flags indicate the polarity of the gating signal:
	         DMA_F_FALLING (default), DMA_F_RISING, DMA_F_LOW, DMA_F_HIGH

DESCRIPTION:	This function performs an immediate DMA operation from
					memory to external I/O.

RETURN VALUE:  0 for success.
					-EINVAL for an invalid handle.
               -EBUSY if resources are busy.

SEE ALSO: 		DMAmem2mem, DMAcompleted, DMAstop
END DESCRIPTION *************************************************************/

#ifdef _ENABLE_16BIT_FLASH_
 #ifdef __ALLOW_16BIT_AUXIO_DEFECT
	#warns "Defining __ALLOW_16BIT_AUXIO_DEFECT exposes an ioe bug in exchange"
	#warns " for improved memory performance.  See the Rabbit 4000 Users Manual"
	#warns " Appendix B (errata section) or TN255 for complete details."
	#warns "You may comment out these warning messages if you are certain your"
	#warns " application is not at risk and absolute top performance is required."
 #endif
#endif

_dma_nodebug
int DMAmem2ioe(dma_chan_t handle,
					unsigned int dest,
               dma_addr_t src,
               unsigned int len,
               unsigned int flags)
{
	auto char control;
   auto unsigned int channel;
	static dma_addr_t descPtr;

	channel = DMAhandle2chan(handle);
   if(channel == DMA_CHANNEL_NONE)
   	return -EINVAL;
// This asm block sets up the value to be written to the DMA control register
// 1. If destination is memory and address is to decrement: X1 = DMA_F_DEST_DEC
// 2. If source is memory and address is to decrement: X1 = DMA_F_SRC_DEC
// 3. Both 1 and 2: X1 = DMA_F_DEST_DEC | DMA_F_SRC_DEC
// X2 contains the source and destination. e.g. X2 = DMA_SRC_MEM | DMA_DEST_IOE
   #asm _dma_nodebug
   ld    iy, 0x0000
	add   iy, sp
	ld    L, (iy+@sp+flags)
	ld    a, L
	and   DMA_F_INTERRUPT | DMA_F_LAST_SPECIAL
	ld    h, a
	ld    a, DMA_F_SRC_DEC //X1
	and   L
	cpl
	and   DMA_SRC_MEM | DMA_DEST_IOE //X2
	or    h
	ld    (iy+@sp+control), a
   #endasm

   // This helper function takes care of the other flag values.
   if(DMAflagSetup(channel, flags))
   	return -EBUSY;

   _dma_len[channel] = len;

   if(flags & DMA_F_REPEAT) {
   	control |= DMA_LINK_DESC;
		if(_dma_bd[channel] == 0L)
   		descPtr = _dma_bd[channel] = xalloc(sizeof(DMABufDesc));
	   DMAsetBufDesc(control, len, src, dest, descPtr, descPtr, 16);
	   DMAloadBufDesc(channel, &descPtr);
	   DMAstartAuto(channel);
   }
   else {
   	control |= DMA_LAST_DESC;		// make this desc the final one
		DMAsetDirect(channel, control, len, src, dest, 0ul);
      DMAstartDirect(channel);
   }

   return 0;
}

/*** BeginHeader DMAmem2ioi */
int DMAmem2ioi(dma_chan_t handle,
					dma_addr_t dest,
               dma_addr_t src,
               unsigned int len,
               unsigned int flags);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ************************************************
DMAmem2ioi							<DMA.LIB>

syntax:	int DMAmem2ioi(dma_chan_t handle,
	                     unsigned int dest,
	                     dma_addr_t src,
	                     unsigned int len,
	                     unsigned int flags)

PARAMETER1:	handle for channel to use in transfer.
PARAMETER2: ioi destination address
PARAMETER3: memory location source
PARAMETER4: length to send (cannot equal zero)
PARAMETER5: DMA_F_REPEAT indicates that the transfer will be a cycle.

            DMA_F_INTERRUPT indicates an interrupt will
            be triggered at the completion of the transfer.  The interrupt
            vector and function must be set up in the user's code.

            DMA_F_LAST_SPECIAL (only for ethernet or HDLC peripherals)
           	Internal Source: Status byte written to initial buffer
            	descriptor before last data.
            Internal Destination: Last byte written to offset address
              	for frame termination.
            All Others: no effect.

            DMA_F_SRC_DEC only for transfers with memory source. Indicates
            the source address should be decremented. (If not specified, a
            memory source address is incremented.)

            DMA_F_DEST_DEC only for transfers with memory destination.
            Indicates the destination address should be decremented. (If
            not specified, a memory destination address is incremented.)

				DMA_F_STOP_MATCH indicates whether or not to stop the dma
            transfer when a character is reached.  The match byte and mask
            should have previously been set by calling the DMAmatchSetup()
            function.

            DMA_F_TIMER indicates the DMA timer will be used.  The divisor
            should have already been set by calling the DMAtimerSetup()
            function.  DMA_F_TIMER_1BPR indicates that the timed transfers
            will send one byte per request instead of the entire descriptor

            Only one of the following flags (if any) should be set.  They
            indicate that the DMA transfer is gated using the named pin:
				DMA_F_PD2, DMA_F_PE2, DMA_F_PE6, DMA_F_PD3, DMA_F_PE3,
            DMA_F_PE7

				The following flags indicate the polarity of the gating signal:
	         DMA_F_FALLING (default), DMA_F_RISING, DMA_F_LOW, DMA_F_HIGH

DESCRIPTION:	This function performs an immediate DMA operation from
					memory to internal I/O.

RETURN VALUE:  0 for success.
					-EINVAL for an invalid handle.
               -EBUSY if resources are busy.

SEE ALSO: 		DMAmem2mem, DMAcompleted, DMAstop
END DESCRIPTION *************************************************************/

_dma_nodebug
int DMAmem2ioi(dma_chan_t handle,
					dma_addr_t dest,
               dma_addr_t src,
               unsigned int len,
               unsigned int flags)
{
	auto char control;
   auto unsigned int channel;
	static dma_addr_t descPtr;

	channel = DMAhandle2chan(handle);
   if(channel == DMA_CHANNEL_NONE)
   	return -EINVAL;
// This asm block sets up the value to be written to the DMA control register
// 1. If destination is memory and address is to decrement: X1 = DMA_F_DEST_DEC
// 2. If source is memory and address is to decrement: X1 = DMA_F_SRC_DEC
// 3. Both 1 and 2: X1 = DMA_F_DEST_DEC | DMA_F_SRC_DEC
// X2 contains the source and destination. e.g. X2 = DMA_SRC_MEM | DMA_DEST_IOI
   #asm _dma_nodebug
   ld    iy, 0x0000
	add   iy, sp
	ld    L, (iy+@sp+flags)
	ld    a, L
	and   DMA_F_INTERRUPT | DMA_F_LAST_SPECIAL
	ld    h, a
	ld    a, DMA_F_SRC_DEC //X1
	and   L
	cpl
	and   DMA_SRC_MEM | DMA_DEST_IOI //X2
	or    h
	ld    (iy+@sp+control), a
   #endasm

   // This helper function takes care of the other flag values.
   if(DMAflagSetup(channel, flags))
   	return -EBUSY;

   _dma_len[channel] = len;

   if(flags & DMA_F_REPEAT) {
   	control |= DMA_LINK_DESC;
		if(_dma_bd[channel] == 0L)
   		descPtr = _dma_bd[channel] = xalloc(sizeof(DMABufDesc));
	   DMAsetBufDesc(control, len, src, dest, descPtr, descPtr, 16);
	   DMAloadBufDesc(channel, &descPtr);
	   DMAstartAuto(channel);
   }
   else {
   	control |= DMA_LAST_DESC;		// make this desc the final one
		DMAsetDirect(channel, control, len, src, dest, 0ul);
      DMAstartDirect(channel);
   }

   return 0;
}

/*** BeginHeader DMAioe2mem */
int DMAioe2mem(dma_chan_t handle,
					dma_addr_t dest,
               unsigned int src,
               unsigned int len,
               unsigned int flags);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ************************************************
DMAioe2mem							<DMA.LIB>

syntax:	int DMAioe2mem(dma_chan_t handle,
	                     dma_addr_t dest,
	                     unsigned int src,
	                     unsigned int len,
	                     unsigned int flags)

PARAMETER1:	handle for channel to use in transfer.
PARAMETER2: memory destination address
PARAMETER3: ioe location source address
PARAMETER4: length to send (cannot equal zero)
PARAMETER5: DMA_F_REPEAT indicates that the transfer will be a cycle.

            DMA_F_INTERRUPT indicates an interrupt will
            be triggered at the completion of the transfer.  The interrupt
            vector and function must be set up in the user's code.

            DMA_F_LAST_SPECIAL (only for ethernet or HDLC peripherals)
           	Internal Source: Status byte written to initial buffer
            	descriptor before last data.
            Internal Destination: Last byte written to offset address
              	for frame termination.
            All Others: no effect.

            DMA_F_SRC_DEC only for transfers with memory source. Indicates
            the source address should be decremented. (If not specified, a
            memory source address is incremented.)

            DMA_F_DEST_DEC only for transfers with memory destination.
            Indicates the destination address should be decremented. (If
            not specified, a memory destination address is incremented.)

				DMA_F_STOP_MATCH indicates whether or not to stop the dma
            transfer when a character is reached.  The match byte and mask
            should have previously been set by calling the DMAmatchSetup()
            function.

            DMA_F_TIMER indicates the DMA timer will be used.  The divisor
            should have already been set by calling the DMAtimerSetup()
            function.  DMA_F_TIMER_1BPR indicates that the timed transfers
            will send one byte per request instead of the entire descriptor

            Only one of the following flags (if any) should be set.  They
            indicate that the DMA transfer is gated using the named pin:
				DMA_F_PD2, DMA_F_PE2, DMA_F_PE6, DMA_F_PD3, DMA_F_PE3,
            DMA_F_PE7

				The following flags indicate the polarity of the gating signal:
	         DMA_F_FALLING (default), DMA_F_RISING, DMA_F_LOW, DMA_F_HIGH

DESCRIPTION:	This function performs an immediate DMA operation from
					external	I/O to memory.

RETURN VALUE:  0 for success.
					-EINVAL for an invalid handle.
               -EBUSY if resources are busy.

SEE ALSO: 		DMAmem2mem, DMAcompleted, DMAstop
END DESCRIPTION *************************************************************/

#ifdef _ENABLE_16BIT_FLASH_
 #ifdef __ALLOW_16BIT_AUXIO_DEFECT
	#warns "Defining __ALLOW_16BIT_AUXIO_DEFECT exposes an ioe bug in exchange"
	#warns " for improved memory performance.  See the Rabbit 4000 Users Manual"
	#warns " Appendix B (errata section) or TN255 for complete details."
	#warns "You may comment out these warning messages if you are certain your"
	#warns " application is not at risk and absolute top performance is required."
 #endif
#endif

_dma_nodebug
int DMAioe2mem(dma_chan_t handle,
					dma_addr_t dest,
               unsigned int src,
               unsigned int len,
               unsigned int flags)
{
	auto char control;
   auto int channel;
	static dma_addr_t descPtr;

	channel = DMAhandle2chan(handle);
   if(channel == DMA_CHANNEL_NONE)
   	return -EINVAL;
// This asm block sets up the value to be written to the DMA control register
// 1. If destination is memory and address is to decrement: X1 = DMA_F_DEST_DEC
// 2. If source is memory and address is to decrement: X1 = DMA_F_SRC_DEC
// 3. Both 1 and 2: X1 = DMA_F_DEST_DEC | DMA_F_SRC_DEC
// X2 contains the source and destination. e.g. X2 = DMA_SRC_IOE | DMA_DEST_MEM
   #asm _dma_nodebug
   ld    iy, 0x0000
	add   iy, sp
	ld    L, (iy+@sp+flags)
	ld    a, L
	and   DMA_F_INTERRUPT | DMA_F_LAST_SPECIAL
	ld    h, a
	ld    a, DMA_F_DEST_DEC //X1
	and   L
	cpl
	and   DMA_SRC_IOE | DMA_DEST_MEM //X2
	or    h
	ld    (iy+@sp+control), a
   #endasm

   // This helper function takes care of the other flag values.
   if(DMAflagSetup(channel, flags))
   	return -EBUSY;

   _dma_len[channel] = len;

   if(flags & DMA_F_REPEAT) {
   	control |= DMA_LINK_DESC;
		if(_dma_bd[channel] == 0L)
   		descPtr = _dma_bd[channel] = xalloc(sizeof(DMABufDesc));
	   DMAsetBufDesc(control, len, src, dest, descPtr, descPtr, 16);
	   DMAloadBufDesc(channel, &descPtr);
	   DMAstartAuto(channel);
   }
   else {
   	control |= DMA_LAST_DESC;		// make this desc the final one
		DMAsetDirect(channel, control, len, src, dest, 0ul);
      DMAstartDirect(channel);
   }

   return 0;
}

/*** BeginHeader DMAioi2mem */
int DMAioi2mem(dma_chan_t handle,
					dma_addr_t dest,
               unsigned int src,
               unsigned int len,
               unsigned int flags);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ************************************************
DMAioi2mem							<DMA.LIB>

syntax:	int DMAioi2mem(dma_chan_t handle,
	                     dma_addr_t dest,
	                     unsigned int src,
	                     unsigned int len,
	                     unsigned int flags)

PARAMETER1:	handle for channel to use in transfer.
PARAMETER2: memory destination address
PARAMETER3: ioi location source address
PARAMETER4: length to send (cannot equal zero)
PARAMETER5: DMA_F_REPEAT indicates that the transfer will be a cycle.

            DMA_F_INTERRUPT indicates an interrupt will
            be triggered at the completion of the transfer.  The interrupt
            vector and function must be set up in the user's code.

            DMA_F_LAST_SPECIAL (only for ethernet or HDLC peripherals)
           	Internal Source: Status byte written to initial buffer
            	descriptor before last data.
            Internal Destination: Last byte written to offset address
              	for frame termination.
            All Others: no effect.

            DMA_F_SRC_DEC only for transfers with memory source. Indicates
            the source address should be decremented. (If not specified, a
            memory source address is incremented.)

            DMA_F_DEST_DEC only for transfers with memory destination.
            Indicates the destination address should be decremented. (If
            not specified, a memory destination address is incremented.)

				DMA_F_STOP_MATCH indicates whether or not to stop the dma
            transfer when a character is reached.  The match byte and mask
            should have previously been set by calling the DMAmatchSetup()
            function.

            DMA_F_TIMER indicates the DMA timer will be used.  The divisor
            should have already been set by calling the DMAtimerSetup()
            function.  DMA_F_TIMER_1BPR indicates that the timed transfers
            will send one byte per request instead of the entire descriptor

            Only one of the following flags (if any) should be set.  They
            indicate that the DMA transfer is gated using the named pin:
				DMA_F_PD2, DMA_F_PE2, DMA_F_PE6, DMA_F_PD3, DMA_F_PE3,
            DMA_F_PE7

				The following flags indicate the polarity of the gating signal:
	         DMA_F_FALLING (default), DMA_F_RISING, DMA_F_LOW, DMA_F_HIGH

DESCRIPTION:	This function performs an immediate DMA operation from
					internal I/O to memory.

RETURN VALUE:  0 for success.
					-EINVAL for an invalid handle.
               -EBUSY if resources are busy.

SEE ALSO: 		DMAmem2mem, DMAcompleted, DMAstop
END DESCRIPTION *************************************************************/

_dma_nodebug
int DMAioi2mem(dma_chan_t handle,
					dma_addr_t dest,
               unsigned int src,
               unsigned int len,
               unsigned int flags)
{
	auto char control;
   auto int channel;
	static dma_addr_t descPtr;

	channel = DMAhandle2chan(handle);
   if(channel == DMA_CHANNEL_NONE)
   	return -EINVAL;
// This asm block sets up the value to be written to the DMA control register
// 1. If destination is memory and address is to decrement: X1 = DMA_F_DEST_DEC
// 2. If source is memory and address is to decrement: X1 = DMA_F_SRC_DEC
// 3. Both 1 and 2: X1 = DMA_F_DEST_DEC | DMA_F_SRC_DEC
// X2 contains the source and destination. e.g. X2 = DMA_SRC_IOI | DMA_DEST_MEM
   #asm _dma_nodebug
	ld    iy, 0x0000
	add   iy, sp
	ld    L, (iy+@sp+flags)
	ld    a, L
	and   DMA_F_INTERRUPT | DMA_F_LAST_SPECIAL
	ld    h, a
	ld    a, DMA_F_DEST_DEC //X1
	and   L
	cpl
	and   DMA_SRC_IOI | DMA_DEST_MEM //X2
	or    h
	ld    (iy+@sp+control), a
   #endasm

   // This helper function takes care of the other flag values.
   if(DMAflagSetup(channel, flags))
   	return -EBUSY;

   _dma_len[channel] = len;

   if(flags & DMA_F_REPEAT) {
   	control |= DMA_LINK_DESC;
		if(_dma_bd[channel] == 0L)
   		descPtr = _dma_bd[channel] = xalloc(sizeof(DMABufDesc));
	   DMAsetBufDesc(control, len, src, dest, descPtr, descPtr, 16);
	   DMAloadBufDesc(channel, &descPtr);
	   DMAstartAuto(channel);
   }
   else {
   	control |= DMA_LAST_DESC;		// make this desc the final one
		DMAsetDirect(channel, control, len, src, dest, 0ul);
      DMAstartDirect(channel);
   }

   return 0;
}

/*** BeginHeader DMAcompleted */
int DMAcompleted(dma_chan_t handle, unsigned int *len);
/*** EndHeader */
/* START FUNCTION DESCRIPTION *************************************************
DMAcompleted						<DMA.LIB>

syntax:	int DMAcompleted(dma_chan_t handle, unsigned int *len)

PARAMETER1: handle for channel to check
PARAMETER2: pointer to the value to be filled with the amount last
				transfered

DESCRIPTION:	This function checks to see if a channel is finished with
					its DMA operation.  If complete, the number of bytes
               transferred in the last operation is returned in *len (if
               len is not NULL), and 1 is returned.

RETURN VALUE:	1 if the DMA operation is complete.
					0 if an allocated channel has never been used or is
	               currently running.
               -EINVAL for an invalid handle.

SEE ALSO:		DMAstop
END DESCRIPTION *************************************************************/

_dma_nodebug
int DMAcompleted(dma_chan_t handle, unsigned int *len)
{
	auto unsigned int channel, reg_offset;
   auto unsigned int i, DMCSnL, chan_mask;
   auto unsigned int DxBU0R, DxBU1R, DxTMR, DxTMR_val, DxTMR_addr;
   auto unsigned int DxSMR, DxSMR_addr, DxSMR_val;

	channel = DMAhandle2chan(handle);
   if(channel == DMA_CHANNEL_NONE){
		return -EINVAL;
	}
	#if _RAB6K
		/*this code is a workaround to a hardware bug currently found in the
			Rabbit 6000 fpga. As it stands, after a DMA transfer that uses the
			termination byte feature, the Master Control/Status registers will not
			reset the bit that corresponds to the DMA channel that just completed.
			This hardware bug makes makes it so that DMAcompleted never returns a
			value of 1 (indicating that the DMA transfer has completed). As a
			workaround, DMAcompleted was updated with the following logic:

			if( DMA termination byte feature enabled){
				get the value of the state machine register for channel X
				if( state machine register says channel X is idle)
					DMA transfer is finished, return 1
				else
					DMA transfer is not finished, return 0
			else
				DMA termination byte feature is not enabled, this logic is not applicable
		*/
		reg_offset = ((channel & 0x0007) * 16);
		if(channel >= 8){
			DxTMR = D8TMR;
			DxSMR = D8SMR;
		}
		else{
			DxTMR = D0TMR;
			DxSMR = D0SMR;
		}
		DxTMR_addr = DxTMR + reg_offset;//calculate the address of the TMR reg
		DxTMR_val = RdPortI(DxTMR_addr);//load the value of the TMR reg
		if(DxTMR_val){ //if we are using termination byte matching
			DxSMR_addr = DxSMR + reg_offset; //calculate the address of the SMR reg
			DxSMR_val = RdPortI(DxSMR_addr); //load the value of the SMR reg
			if(DxSMR == 0x00FF){ //if SMR indicates channel is idle
				DMCSnL = 0;
				//set DMCSnL to 0 so that it does not trigger a return value of 0
			}
			else{
				DMCSnL = 1;
				//set DMCSnL to 1 so that id DOES return a value of 0
			}
		}
		else //we are not using termination byte matching, DMCSLR value is valid
		{
			DMCSnL = RdPortI16(DMCSLR);
		}
	#else
		DMCSnL = RdPortI(DMCSR);
	#endif
   if(DMCSnL & (1 << channel)){
      return 0;
   }
   #if _RAB6K
   	chan_mask = 0x0F;
   #else
   	chan_mask = 0x07;
   #endif
   // Clear external requests for this channel.
   if((RdPortI(DMR0CR) & chan_mask) == channel){
      WrPortI(DMR0CR, NULL, 0x0000 );
   }
   if((RdPortI(DMR1CR) & chan_mask) == channel){
      WrPortI(DMR1CR, NULL, 0x0000);
	}

   if(len != NULL) {
   #if _RAB6K
   	if(channel >= 8){
   		DxBU0R = D8BU0R;
   		DxBU1R = D8BU1R;
		}
		else {
   		DxBU0R = D0BU0R;
   		DxBU1R = D0BU1R;
   	}
   #else
			DxBU0R = D0BU0R;
   		DxBU1R = D0BU1R;
   #endif
   	i = channel << 4;
   	*len = (_dma_len[channel] - RdPortI(DxBU0R+i) - (RdPortI(DxBU1R+i)) << 8);
   }
   return 1;
}

/*** BeginHeader DMAstop */
int DMAstop(dma_chan_t handle);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ************************************************
DMAstop								<DMA.LIB>

syntax:	int DMAstop(dma_chan_t handle)

PARAMETER1:		handle for channel to stop.

DESCRIPTION:	Stop a DMA operation started with one of the DMAmem2ioe
					series functions.  DMAcompleted() will return TRUE after for
               an operation stopped with this function, but with less data
               length than the original request.  It is OK to stop an
               operation which has currently completed; this has no effect.
               DMAcompleted() may be called to determine the actual amount
               of data transferred.

RETURN VALUE:	0 for success, -EINVAL for an invalid channel.

SEE ALSO:		DMAcompleted, DMAstopDirect
END DESCRIPTION *************************************************************/

_dma_nodebug
int DMAstop(dma_chan_t handle)
{
	auto unsigned int channel, i,chan_mask,halt_chan, DxL0R, DxL1R;

   channel = DMAhandle2chan(handle);
   if(channel == DMA_CHANNEL_NONE)
   	return -EINVAL;
	#if _RAB6K
   	chan_mask = 0x0F;
   #else
   	chan_mask = 0x07;
   #endif
   // Clear external requests for this channel.
   if((RdPortI(DMR0CR) & chan_mask) == channel)
      WrPortI(DMR0CR, NULL, 0x0000);
   if((RdPortI(DMR1CR) & chan_mask) == channel)
      WrPortI(DMR1CR, NULL, 0x0000);
   #if _RAB6K
	   if(channel >= 8){
            DxL0R = D8L0R;
            DxL1R = D8L1R;
         }
      else {
            DxL0R = D0L0R;
            DxL1R = D0L1R;
         }
   #else
		DxL0R = D0L0R;
      DxL1R = D0L1R;
   #endif
   i = channel << 4;
  	_dma_len[channel] -= (RdPortI(DxL0R+i) + (RdPortI(DxL1R+i) << 8));
  	#if _RAB6K
  		halt_chan = 1 << channel;
		#asm
			ld		hl,(sp+@sp+halt_chan)
			ld		(DMHLR),hl
		#endasm
  	#else
   	WrPortI(DMHR, NULL, 1 << channel);
	#endif
   return 0;
}

/*** BeginHeader DMAhandle2chan */
int DMAhandle2chan(dma_chan_t handle);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ************************************************
DMAhandle2chan						<DMA.LIB>

syntax:	int DMAhandle2chan(dma_chan_t handle)

PARAMETER1:	handle to convert to channel number

DESCRIPTION:	This function checks the validity of a handle and returns
					the channel number if it is valid.

RETURN VALUE:	0-7 (Rabbit 4000, 5000) or 0-15 (Rabbit 6000+) if the
             	channel is valid. DMA_CHANNEL_NONE is returned if the
             	channel is invalid.

SEE ALSO:	DMAalloc, DMAunalloc
END DESCRIPTION *************************************************************/

_dma_nodebug
int DMAhandle2chan(dma_chan_t handle)
{
   auto unsigned int channel,chan_mask;
	if(handle == DMA_CHANNEL_NONE)
		return DMA_CHANNEL_NONE;
	#if _RAB6K
		chan_mask = 0x0F;
	#else
		chan_mask = 0x07;
	#endif
   channel = handle & chan_mask;
	if(!(_dma_chanInUse & (1 << channel)) ||
   	(handle >> 8 != _dma_allocCnt[channel])) {
		return DMA_CHANNEL_NONE;
   }

	return channel;
}

/*** BeginHeader DMAprintBufDesc */
void DMAprintBufDesc(void * dr, dma_addr_t dp);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ************************************************
DMAprintBufDesc					<DMA.LIB>

syntax:	void DMAprintBufDesc(void * dr, dma_addr_t dp)

PARAMETER1:	pointer to buffer descriptor in root memory.
PARAMETER2: address of buffer descriptor in physical memory.

DESCRIPTION:	This is a debugging function only.  It formats and prints
					the contents of the buffer descriptor at *dr or *dp, using
               bit 6 of the chanControl field to determine whether to
               assume a short or long format. If dr is not NULL, then the
               buffer descriptor is in root memory and *dr is used.
               Otherwise, dp is assumed to be the physical address of the
               buffer descriptor in xmem.

RETURN VALUE:	none.

SEE ALSO:		DMAprintRegs
END DESCRIPTION *************************************************************/

_dma_nodebug
void DMAprintBufDesc(void /*DMABufDesc or DMABufDesc12 */ * dr, dma_addr_t dp)
{
	auto DMABufDesc d;

	if(dr)
   	dp = paddr(dr);
   xmem2root(&d, dp, sizeof(d));

	printf("  Loc=x%lX fs=x%02X cc=x%02X len=%u src=x%lX dst=x%lX", dp,
   	d.frameStatus, d.chanControl, d.bufLength, d.srcAddress, d.destAddress);
   if (d.chanControl & 0x40)
   	printf(" lnk=%06X\n", d.linkAddress);
   else
   	printf("\n");
   printf("     %s, %s, %s, %s, %s, %s\n",
   	d.chanControl & 0x80 ? "final" : "not last"
     ,d.chanControl & 0x40 ? "link" : "sequential"
     ,d.chanControl & 0x20 ? "special I/O" : "normal"
     ,d.chanControl & 0x10 ? "interrupt" : "no interrupt"
     ,(d.chanControl & 0x0C) == 0x00 ? "intl I/O src" :
      (d.chanControl & 0x0C) == 0x04 ? "extl I/O src" :
      (d.chanControl & 0x0C) == 0x08 ? "mem src--" :
                                       "mem src++"
     ,(d.chanControl & 0x03) == 0x00 ? "intl I/O dst" :
      (d.chanControl & 0x03) == 0x01 ? "extl I/O dst" :
      (d.chanControl & 0x03) == 0x02 ? "mem dst--" :
                                       "mem dst++"
		);
}

/*** BeginHeader DMAprintRegs */
void DMAprintRegs(int chan, int masters);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ************************************************
DMAprintRegs						<DMA.LIB>

syntax:	void DMAprintRegs(int chan, int masters)

PARAMETER1:	channel number to print
PARAMETER2:	a bool to determine whether or not to print out the master
				registers shared between all channels.

DESCRIPTION:	This is a debugging function only. This prints the values of
					the hardware registers foer the specified channel.  If
               masters is true, then it also prints the values of the
               master DMA control registers.

               Note that the Source and Destination Address registers are
               write only and read as zero.

RETURN VALUE:	none.

SEE ALSO:		DMAprintBufDesc
END DESCRIPTION *************************************************************/
const char _tran_burst[8] = { 1, 2, 3, 4, 8, 16, 32, 64 };
const int _tran_clocks[8] = { 12, 16, 24, 32, 64, 128, 256, 512 };
_dma_nodebug char * _tran_state(int state)
{
	switch (state) {
		#if _RAB6K
			case 0xFF: return "idle";
	      case 0xFD: return "cont byte (start)";
	      case 0xFB: return "cont byte (chain)";
	      case 0xF5: return "count 0";
	      case 0xF3: return "count 1";
	      case 0xEF: return "src 0";
	      case 0xED: return "src 1";
	      case 0xEB: return "src 2";
	      case 0xDF: return "dst 0";
	      case 0xDD: return "dst 1";
	      case 0xDB: return "dst 2";
	      case 0xBF: return "lnk 0";
	      case 0xBD: return "lnk 1";
	      case 0xBB: return "lnk 2";
	      case 0x7F: return "data";
	      case 0x7D: return "rx status";
	      case 0x7B: return "last rx";
	      case 0x79: return "last tx";
		#else
	      case 0xFE: return "idle";
	      case 0xFC: return "cont byte (start)";
	      case 0xFA: return "cont byte (chain)";
	      case 0xF4: return "count 0";
	      case 0xF2: return "count 1";
	      case 0xEE: return "src 0";
	      case 0xEC: return "src 1";
	      case 0xEA: return "src 2";
	      case 0xDE: return "dst 0";
	      case 0xDC: return "dst 1";
	      case 0xDA: return "dst 2";
	      case 0xBE: return "lnk 0";
	      case 0xBC: return "lnk 1";
	      case 0xBA: return "lnk 2";
	      case 0x7E: return "data";
	      case 0x7C: return "rx status";
	      case 0x7A: return "last rx";
	      case 0x78: return "last tx";
	   #endif
   }
   return "undocumented";
}

_dma_nodebug
void DMAprintRegs(int chan, int masters)
{
	#if _RAB6K //if its a Rabbit 6000
	auto char mregs[8];		// Master regs in 0x0100-0x0105 range, 0x125
	auto char pregs[8];		// Per-channel regs (not part of buffer descriptor)
   								// Rabbit 6000:
   								// Channels 0-7
   								// Range: 0x01?2, 0x01?8 - 0x01?E
   								// where ? = chan number
                           // also includes state machine register
                           // Channels 8-15
                           // Range: 0x09?2, 0x09?8 - 0x09?E
                           // where ? = chan number - 8
	auto char dregs[7];		// Descriptor regs
									// Channels 0-7
									// Range: 0x01?0 - 0x01?3, 0x01?C - 0x01?E
									// where ? = chan number + 8
									// Channels 8-15
									// Range: 0x09?0 - 0x09?3, 0x09?C - 0x09?E
   								// where ? = chan number.
	auto unsigned int chanCpy, DxSMR, DxTBR, DxCR,DxLA0R,DxSCR;
	chanCpy = chan;
	if (masters) {
		#asm
      ld    hl,@sp+mregs
      add   hl,sp
      ex    de,hl
      ld    hl,DMCSLR          ; DMCSLR (first master reg)
      ld    bc,6
		ioi   lsir
		ioi   ld    a, (DCSTCR)    ; include DMA Cycle-Steal Timing Control Reg
      clr   hl
      ld    L,a
      ld    (sp+@sp+mregs+6),hl
	   #endasm
   }
   if(chan >=8 && chan<=15){
		DxSMR = D8SMR;
		DxTBR = D8TBR;
		DxCR = D8CR;
		DxLA0R = D8LA0R;
		DxSCR = D8SCR;
	}
	else if(chan <= 7 && chan >= 0){
		DxSMR = D0SMR;
		DxTBR = D0TBR;
		DxCR = D0CR;
		DxLA0R = D0LA0R;
		DxSCR = D0SCR;
	}
	else{
		printf("Channel %d is not a valid DMA Channel.\n", chan);
		return;
	}
   chan <<= 4;
   chan &= 0x0070;
   #asm
   ld    hl,(sp+@sp+DxSMR)
   ex		de,hl
   ld    hl,(sp+@sp+chan)
   add   hl,de
   ioi   ld    a,(hl)
   clr   hl
   ld    L,a
   ld    (sp+@sp+pregs),hl
   ld    hl,(sp+@sp+DxTBR)
   ex		de,hl          ; DxTBR
   ld    hl,(sp+@sp+chan)
   add   hl,de
   ex    de,hl
   ld    hl,@sp+pregs+1
   add   hl,sp
   ex    de,hl
   ld    bc,7
   ioi   lsir
   ld    hl,(sp+@sp+DxSCR)         ; Descriptor regs base
   ex		de,hl
   ld    hl,(sp+@sp+chan)
   add   hl,de
   ex    de,hl
   ld    hl,@sp+dregs
   add   hl,sp
   ex    de,hl
   ld    bc,4
   ioi lsir
   ld    hl,(sp+@sp+DxLA0R)         ; Continue with descriptor regs
	ex		de,hl
   ld    hl,(sp+@sp+chan)
   add   hl,de
   ex    de,hl
   ld    hl,@sp+dregs+4
   add   hl,sp
   ex    de,hl
   ld    bc,3
   ioi lsir
   #endasm
 	if (masters) {
   	printf("DMCSHR+DMCSLR: %02X %02X\n", mregs[1],mregs[0]);
      printf("DMCR:  %02X  transfer pri=%u  int pri=%u\n",
      	mregs[4], (mregs[4] >> 2) & 3, mregs[4] & 3);
      printf("DMTCR: %02X  pri=%s burst=%d clocks=%d\n",
      	mregs[5],
         mregs[5] & 0x80 ?
         (mregs[5] & 0x40 ? "rot chan" : "rot byte") : "fixed",
         _tran_burst[mregs[5]>>3 & 0x7],
         _tran_clocks[mregs[5] & 0x7]);
		printf("DCSTCR: %02X  pri=%s burst=%d\n",
      	mregs[5],
         mregs[5] & 0x80 ?
         (mregs[5] & 0x40 ? "rot chan (CS)" : "rot byte (CS)") : "fixed (CS)",
         _tran_burst[mregs[5]>>3 & 0x7]);
   }
   chan = chanCpy;
   printf("D%uTBR:  %02X\n", chan , pregs[1]);
   printf("D%uTMR:  %02X\n", chan, pregs[2]);
   printf("D%uBUnR: %02X %02X\n", chan, pregs[4], pregs[3]);
   printf("D%uIAnR: %02X %02X %02X\n", chan, pregs[7], pregs[6], pregs[5]);

   printf("D%uSMR:  %02X %s\n", chan, pregs[0], _tran_state(pregs[0]));
	printf("D%uSCR:  %02X\n", chan, dregs[0]);
   printf("D%uCR:   %02X\n", chan, dregs[1]);
   printf("D%uLnR:  %02X %02X\n", chan, dregs[3], dregs[2]);
   printf("D%uLAnR: %02X %02X %02X\n", chan, dregs[6], dregs[5], dregs[4]);

	#else //if its a Rabbit 4000/5000
	auto char mregs[8];		// Master regs in 0x0100-0x0107 range
   auto char pregs[7];		// Per-channel regs (not part of buffer descriptor)
   								// in 0x01?8 - 0x01?E range where ? = chan number
                           // also includes state machine register
   auto char dregs[16];		// Descriptor regs in 0x01?0 - 0x01?F range
   								// where ? = chan number + 8.

   chan <<= 4;
   chan &= 0x00F0;

   if (masters) {
   #asm
   ld		hl,@sp+mregs
   add	hl,sp
   ex		de,hl
   ld		hl,DMCSR				; DMCSR (first master reg)
   ld		bc,8
   ioi lsir
   #endasm
   }

   #asm
   ld		de,D0TBR				; D0TBR
   ld		hl,(sp+@sp+chan)
   add	hl,de
   ex		de,hl
   ld		hl,@sp+pregs
   add	hl,sp
   ex		de,hl
   ld		bc,7
   ioi lsir

   ld		de,D0SMR				; Descriptor regs base
   ld		hl,(sp+@sp+chan)
   add	hl,de
   ex		de,hl
   ld		hl,@sp+dregs
   add	hl,sp
   ex		de,hl
   ld		bc,16
   ioi lsir
   #endasm

   if (masters) {
   	printf("DMCSR: %02X\n", mregs[0]);
      printf("DMCR:  %02X  transfer pri=%u  int pri=%u\n",
      	mregs[4], (mregs[4] >> 2) & 3, mregs[4] & 3);
      printf("DMTCR: %02X  pri=%s burst=%d clocks=%d\n",
      	mregs[5],
         mregs[5] & 0x80 ?
         (mregs[5] & 0x40 ? "rot chan" : "rot byte") : "fixed",
         _tran_burst[mregs[5]>>3 & 0x7],
         _tran_clocks[mregs[5] & 0x7]);
   }
   chan >>= 4;
   printf("D%uTBR:  %02X\n", chan, pregs[0]);
   printf("D%uTMR:  %02X\n", chan, pregs[1]);
   printf("D%uBUnR: %02X%02X\n", chan, pregs[3], pregs[2]);
   printf("D%uIAnR: %02X%02X%02X\n", chan, pregs[6], pregs[5], pregs[4]);

   printf("D%uSMR:  %02X %s\n", chan, dregs[0], _tran_state(dregs[0]));
   printf("D%uCR:   %02X\n", chan, dregs[1]);
   printf("D%uLnR:  %02X%02X\n", chan, dregs[3], dregs[2]);
   //printf("The following 2 values are write only and read as zero.\n");
   //printf("D%uSAnR: %02X%02X%02X\n", chan, dregs[6], dregs[5], dregs[4]);
   //printf("D%uDAnR: %02X%02X%02X\n", chan, dregs[10], dregs[9], dregs[8]);
   printf("D%uLAnR: %02X%02X%02X\n", chan, dregs[14], dregs[13], dregs[12]);
   #endif
}
/*** BeginHeader DMAsetDirect */
void DMAsetDirect(unsigned int channel,
					   char chanControl,
						unsigned int bufLength,
            		dma_addr_t srcAddress,
            		dma_addr_t destAddress,
            		dma_addr_t linkAddress);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ************************************************
DMAsetDirect						<DMA.LIB>

SYNTAX:	void DMAsetDirect(unsigned int channel,
									char chanControl,
									unsigned int bufLength,
                  			dma_addr_t srcAddress,
			            		dma_addr_t destAddress,
			            		dma_addr_t linkAddress)

PARAMETER1: DMA channel to set
PARAMETER2:	DMA channel control value
PARAMETER3:	DMA buffer length
PARAMETER4:	DMA source address
PARAMETER5: DMA destination address
PARAMETER6: DMA link address (of next buffer descriptor)

DESCRIPTION:	This function sets up a DMA channel with the values provided

RETURN VALUE:	none

SEE ALSO:		DMAloadBufDesc, DMAsetBufDesc
END DESCRIPTION *************************************************************/

_dma_nodebug
void DMAsetDirect(unsigned int channel,
				   	char chanControl,
						unsigned int bufLength,
      	      	dma_addr_t srcAddress,
         	   	dma_addr_t destAddress,
            		dma_addr_t linkAddress)
{
	auto unsigned int DxCR,DxL0R, DxL1R,DxSA0R,DxSA1R,DxSA2R,
							DxDA0R,DxDA1R,DxDA2R,DxLA0R,DxLA1R,DxLA2R;
	#if _RAB6K
	   if(channel >= 8){
	      DxCR = D8CR;
	      DxL0R = D8L0R;
	      DxL1R = D8L1R;
	      DxSA0R = D8SA0R;
	      DxSA1R = D8SA1R;
	      DxSA2R = D8SA2R;
	      DxDA0R = D8DA0R;
	      DxDA1R = D8DA1R;
	      DxDA2R = D8DA2R;
	      DxLA0R = D8LA0R;
	      DxLA1R = D8LA1R;
	      DxLA2R = D8LA2R;
	   }
	   else{
	      DxCR = D0CR;
	      DxL0R = D0L0R;
	      DxL1R = D0L1R;
	      DxSA0R = D0SA0R;
	      DxSA1R = D0SA1R;
	      DxSA2R = D0SA2R;
	      DxDA0R = D0DA0R;
	      DxDA1R = D0DA1R;
	      DxDA2R = D0DA2R;
	      DxLA0R = D0LA0R;
	      DxLA1R = D0LA1R;
	      DxLA2R = D0LA2R;
	   }
   #else
		DxCR = D0CR;
      DxL0R = D0L0R;
		DxL1R = D0L1R;
		DxSA0R = D0SA0R;
		DxSA1R = D0SA1R;
		DxSA2R = D0SA2R;
		DxDA0R = D0DA0R;
		DxDA1R = D0DA1R;
		DxDA2R = D0DA2R;
		DxLA0R = D0LA0R;
		DxLA1R = D0LA1R;
		DxLA2R = D0LA2R;
   #endif
   //printf("Channel in set direct %u\n", channel);
	channel = (channel << 4) & 0x0070;

	#asm
		ld    iy, 0x0000
	   add   iy, sp         // let's use IY
	   ld    hl, (iy+@sp+channel)
	   ex    de, hl
	   ld    a, (iy+@SP+chanControl)
	   ld    hl, (sp+@sp+DxCR)
	   add   hl, de
	   ioi   ld (hl), a
	   ld    a, (iy+@SP+bufLength)
	   ld    hl, (sp+@sp+DxL0R)
	   add   hl, de
	   ioi   ld (hl), a
	   ld    a, (iy+@SP+bufLength+1)
	   ld    hl, (sp+@sp+DxL1R)
	   add   hl, de
	   ioi   ld (hl), a
	   ld    a, (iy+@SP+srcAddress)
	   ld    hl, (sp+@sp+DxSA0R)
	   add   hl, de
	   ioi   ld (hl), a
	   ld    a, (iy+@SP+srcAddress+1)
	   ld    hl, (sp+@sp+DxSA1R)
	   add   hl, de
	   ioi   ld (hl), a
	   ld    a, (iy+@SP+srcAddress+2)
	   ld    hl, (sp+@sp+DxSA2R)
	   add   hl, de
	   ioi   ld (hl), a
	   ld    a, (iy+@SP+destAddress)
	   ld    hl, (sp+@sp+DxDA0R)
	   add   hl, de
	   ioi   ld (hl), a
	   ld    a, (iy+@SP+destAddress+1)
	   ld    hl, (sp+@sp+DxDA1R)
	   add   hl, de
	   ioi   ld (hl), a
	   ld    a, (iy+@SP+destAddress+2)
	   ld    hl, (sp+@sp+DxDA2R)
	   add   hl, de
	   ioi   ld (hl), a
	   ld    a, (iy+@SP+linkAddress)
	   ld    hl, (sp+@sp+DxLA0R)
	   add   hl, de
	   ioi   ld (hl), a
	   ld    a, (iy+@SP+linkAddress+1)
	   ld    hl, (sp+@sp+DxLA1R)
	   add   hl, de
	   ioi   ld (hl), a
	   ld    a, (iy+@SP+linkAddress+2)
	   ld    hl, (sp+@sp+DxLA2R)
	   add   hl, de
	   ioi   ld (hl), a
	#endasm
}

//////////////////////////////////////////////////////////////////////////////

/*** BeginHeader DMAsetBufDesc */
int  DMAsetBufDesc(char chanControl,
						 unsigned int bufLength,
                   dma_addr_t srcAddress,
                   dma_addr_t destAddress,
                   dma_addr_t linkAddress,
                   dma_addr_t bufPtr,
                   int bufSize);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ************************************************
DMAsetBufDesc						<DMA.LIB>

SYNTAX:	int  DMAsetBufDesc(char chanControl,
									 unsigned int bufLength,
                  			 dma_addr_t srcAddress,
			                   dma_addr_t destAddress,
			                   dma_addr_t linkAddress,
         			          dma_addr_t bufPtr,
			                   int bufSize)

PARAMETER1:	DMA channel control value
PARAMETER2:	DMA buffer length
PARAMETER3:	DMA source address
PARAMETER4: DMA destination address
PARAMETER5: DMA link address (of next buffer descriptor)
PARAMETER6:	physical address of buffer descriptor to fill
PARAMETER7:	size of buffer descriptor in bytes (12 or 16 only)

DESCRIPTION:	This function loads a DMA buffer descriptor in memory with
					the values provided.  The buffer needs to be described as
               either 12 or 16 bytes in size.

RETURN VALUE:	0 upon success; -EINVAL for an error.

SEE ALSO:		DMAloadBufDesc, DMAsetDirect
END DESCRIPTION *************************************************************/

_dma_nodebug
int DMAsetBufDesc(char chanControl,
                  unsigned int bufLength,
                  dma_addr_t srcAddress,
                  dma_addr_t destAddress,
                  dma_addr_t linkAddress,
                  dma_addr_t bufPtr,
                  int bufSize)
{
	auto DMABufDesc __far *bd;

	bd = (DMABufDesc __far *) bufPtr;
	if (sizeof (DMABufDesc) == bufSize)
	{
		bd->linkAddress = linkAddress;
	}
	else if (sizeof (DMABufDesc12) != bufSize)
	{
		return -EINVAL;
	}
	bd->frameStatus = 0x00;	// enable R6K's automatic mode selection
	bd->chanControl = chanControl;
	bd->bufLength = bufLength;
	bd->srcAddress = srcAddress;
	bd->destAddress = destAddress;
	return 0;
}


/*** BeginHeader DMAloadBufDesc */
void DMAloadBufDesc(int dmaChannel, dma_addr_t *bufPtr);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ************************************************
DMAloadBufDesc						<DMA.LIB>

SYNTAX:	void DMAloadBufDesc(int dmaChannel, dma_addr_t *bufPtr)

PARAMETER1:	DMA channel number to load
PARAMETER2:	pointer to variable containing physical address of DMA buffer

DESCRIPTION:	This function loads the appropriate DMA Initial Address
					Registers for the requested DMA channel with the address
               provided.

RETURN VALUE:	none

SEE ALSO:		DMAsetBufDesc, DMAsetDirect
END DESCRIPTION *************************************************************/

_dma_nodebug
void DMAloadBufDesc(int dmaChannel, dma_addr_t *bufPtr)
{
	#asm
	//going to compute address of the DxIA0R register
	ld		hl, (sp+@SP+dmaChannel)
   xor   a
   rl    4,jkhl 		// multiply channel by 16
   ld		de, 0x0F80	// load de with bitmask
	ld    a, L 			// save L
   and	hl,de 		// is channel in 0-7 range?, or 8-15 range?
   ld    h, 0x01		// load hl with base of 0x0100
   jr    z, .LTChan8 // jump because channel is less than 8
   set   3,h 			// change the address from 0x01** to 0x9**
   res	7,a			// erase the 8's bit (of what used to be L) b/c base address
   						// in 8-15 chan range for IA0R regs is 0x90C not 0x98C
.LTChan8:
   or    0x0C			// DxIA0R regs have addresses 0x10C,0x11C,0x12C...0x90C,etc
   ld    L, a
	ex		de,hl
   // set up HL as source
   ld		hl, (sp+@SP+bufPtr)

	// copy 3 bytes from memory to appropriate internal register
   ld		bc, 3
   ioi	ldir
	#endasm
}


/*** BeginHeader DMApoll, _DMApoll */
word DMApoll(int dmaChannel, word * bufCount);
__root void _DMApoll(void);	// Do not call this from C; assembler only
/*** EndHeader */

/* START FUNCTION DESCRIPTION ************************************************
DMApoll										<DMA.LIB>

SYNTAX:	word DMApoll(int dmaChannel, word * bufCount)

PARAMETER1:	DMA channel number to poll (0-7).
PARAMETER2:	pointer to variable in which the completed buffer count will be
            written.  The return value contains the number of bytes
            remaining (not yet transferred) in this buffer.  The buffer
            count wraps around modulo 256.

DESCRIPTION:	This is a low-level DMA function for determining how much data
               has been transferred by the specified DMA channel.  Since DMA
               is asynchronous to the CPU, this returns a lower bound on the
               actually completed transfer.

               Important note:

               Owing to the way the DMA channels are designed, this function
               will not give a valid result for the first buffer in a
               linked list or chain, or if there is only one buffer defined
               (with no link or array sequencing).  To get around this
               limitation, define the first buffer as a dummy transfer of
               1 byte from memory to the same memory, and link this initial
               dummy buffer to the desired list or array of buffer descriptors.
               Take the dummy buffer into account when interpreting the
               bufCount value returned.  If you service an interrupt from the
               dummy buffer completion, you will know when it is valid to
               poll.

               This function is mainly intended for endless DMA loops (e.g.
               receiving into a circular buffer from a serial port) thus the
               above restriction should not be too onerous in practice.

RETURN VALUE:	The number of bytes remaining in the buffer indicated by
               *bufCount.  This ranges from 0, if completed, up to the total
               size of the buffer, if not yet started.  If the size of any
               single transfer was 65536 bytes, then the retun value is
               ambiguous as to whether it means '0' or '65536'.

SEE ALSO:		DMAsetBufDesc, DMAsetDirect
END DESCRIPTION *************************************************************/

_dma_nodebug
word DMApoll(int dmaChannel, word * bufCount)
{
	auto word cmask;

   cmask = 1u << dmaChannel;
	#asm
   ld hl,(sp+@sp+cmask)
   ld bc,hl
   ld hl,(sp+@sp+dmaChannel)
   ld a,L
   call _DMApoll
   ex	de,hl
   ld hl,(sp+@sp+bufCount)
   ld (hl),c
   inc hl
   ld (hl),0
   ex de,hl		; HL will have return code
   #endasm
}

#asm __root __nodebug
; Set up with BC=channel mask to poll (one bit set)
;             A=corresponding channel number (0-7, Rabbit 4k/5k) (0-15, Rab 6k)
; Trashes A,B
; Returns C = buffer count
;         HL = remaining bytes in that buffer
_DMApoll::
#if _RAB6K //if it's a Rabbit 6000
		push	ix
		rla $ rla $ rla $ rla
		and	0xF0
		bit	7, a
		jr		nz, .DMApollHigh

		; Use IX to address DMA regs.  Because of wide range of addrs, IX set to
		; 0x140+(chan*16) then DxBCR is offset -0x3D, DxSMR is at -0x3E, and DxL0R
		; is at +0x42.
		add	0x40
		ld		L, a
		ld		h, 0x01
		ld		ix, hl
		; We need to halt the DMA so we can get a consistent reading of BU and LEN
		; registers
		ld		hl, DMHLR
		ipset	3
ioi	ld		a, (DMCSLR)
		ipres
ioi	ld		(hl), c
		; A has original running status
		and	a, c	; now only the channel of interest: bit is 1 if must restart
ioi	ld		b, (ix-0x3E)	; DxSMR
ioi	ld		hl, (ix+0x42)	; DxL[0,1]R
ioi	ld		c, (ix-0x3D)	; DxBCR
ioi	ld		(DMCSLR), a		; Restart if it was running
		; Now check against state machine register
		ld		a, b
		or		0x0F
		inc	a
		jr		z, .ok			; Any 0xF? state need no adjustment to bcomp.

		inc	c					; other states need to adjust buffer complete count
.ok:
		pop	ix
		ret

	.DMApollHigh:
		; Use IX to address DMA regs.  Because of wide range of addrs, IX set to
		; 0x940+(chan*16) then DxBCR is offset -0x3D, DxSMR is at -0x3E, and DxL0R
		; is at +0x42.
		add	0x40
		ld		L, a
		ld		h, 0x09
		ld		ix, hl
		; We need to halt the DMA so we can get a consistent reading of BU and LEN
		; registers
		ld		hl, DMHMR
		ipset	3
ioi	ld		a, (DMCSMR)
		ipres
ioi	ld		(hl), b
		; A has original running status
		and	a, b	; now only the channel of interest: bit is 1 if must restart
ioi	ld		b, (ix-0x3E)	; DxSMR
ioi	ld		hl, (ix+0x42)	; DxL[0,1]R
ioi	ld		c, (ix-0x3D)	; DxBCR
ioi	ld		(DMCSMR), a		; Restart if it was running
		; Now check against state machine register
		ld		a, b
		or		0x0F
		inc	a
		jr		z, .okHigh		; Any 0xF? state need no adjustment to bcomp.

		inc	c					; other states need to adjust buffer complete count
.okHigh:
		pop	ix
		ret
#else	//otherwise it's a Rabbit 5000/4000
		push	ix
		; Use IX to address DMA regs.  Because of wide range of addrs, IX set to
		; 0x140+(chan*16) then DxBCR is offset -0x3D, DxSMR is at -0x3E (Rabbit
		; 5000) vs. +0x40 (Rabbit 4000), and DxL0R is at +0x42.
		rla $ rla $ rla $ rla
		and	0x70
		add	0x40
		ld		L, a
		ld		h, 0x01
		ld		ix, hl
		; We need to halt the DMA so we can get a consistent reading of BU and LEN
		; registers
		ld		hl, DMHR
		ipset	3
ioi	ld		a, (DMCSR)
		ipres
ioi	ld		(hl), c
		; A has original running status
		and	a, c	; now only the channel of interest: bit is 1 if must restart
	#if CPU_ID_MASK(_CPU_ID_) == R5000	//if it's a Rabbit 5000
ioi	ld		b, (ix-0x3E)	; DxSMR
	#else	//otherwise it's a Rabbit 4000
ioi	ld		b, (ix+0x40)	; DxSMR
	#endif
ioi	ld		hl, (ix+0x42)	; DxL[0,1]R
ioi	ld		c, (ix-0x3D)	; DxBCR
ioi	ld		(DMCSR), a		; Restart if it was running
		; Now check against state machine register
		ld		a, b
		or		0x0F
		inc	a
		jr		z, .ok			; Any 0xF? state need no adjustment to bcomp.

		inc	c					; other states need to adjust buffer complete count
.ok:
		pop	ix
		ret
#endif
#endasm
/*** BeginHeader */
#endif
/*** EndHeader */