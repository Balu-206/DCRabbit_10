/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

/*** BeginHeader */
#ifdef SIGNAL_DEBUG
	#define _signal_debug __debug
#else
	#define _signal_debug __nodebug
#endif
#include <signal.h>
/*** EndHeader */

/*** BeginHeader _signal_table */
/*** EndHeader */
// Initialize _signal_table to all zeros (SIG_DFL).  ANSI C would do this
// automatically without an initializer.  We cheat by setting the first
// element and having Dynamic C filling the remaining bytes with 0.
//_signal_func *_signal_table[_SIGNAL_COUNT] = { SIG_DFL };
_signal_func_ptr _signal_table[_SIGNAL_COUNT] = { SIG_DFL };

/*** BeginHeader signal */
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
signal                                                          <signal.h>

SYNTAX:	void (*signal( int sig, void (*func)(int)))(int)

DESCRIPTION:	Chooses one of three ways to handle receipt of a given signal.

					If <func> is SIG_DFL, default handling will occur.

					If <func> is SIG_IGN, the signal is ignored.

					Otherwise, <func> should point to a function to be called when
					that signal occurs.  Such a function is called a signal handler.

					When a signal occurs, if <func> points to a function, the
					following occurs:

						1) The equivalent of signal( sig, SIG_DFL) is executed.
						2) <func> is called with <sig> as the parameter.
						3) <func> can return and execution will continue at the
							point it was interrupted, or it can terminate by calling
							abort(), exit() or longjmp().  Of course, the SIGABRT
							handler should not call abort().

PARAMETER 1:	Signal to handle.  Must be one of the following:

					SIGABRT:	Abnormal termination, such as initiated by abort().
					SIGFPE:	Floating-point exception (e.g., div by zero, overflow).
					SIGILL:	Illegal instruction.
					SIGINT:	Interactive attention signal.
					SIGSEGV:	Invalid access to storage.
					SIGTERM:	Termination request sent to program.

					The current version of Dynamic C does not generate any signals.
					Future versions may send SIGABRT when abort() is called and
					floating-point errors may call SIGFPE instead of generating
					exceptions.

PARAMETER 2:	Either SIG_DFL (for default handling), SIG_IGN (to ignore) or
					the address of a function to handle the signal.  Such a function
					should accept a single integer parameter (the signal generated)
					and return nothing.

					If the signal was not generated by calling abort() or raise(),
					this function shouldn't call any standard library functions
					except the signal function itself (with the same signal number
					as passed to the signal handler).  It should not refer to any
					global variables other than those declared as type
					"volatile sig_atomic_t".

RETURN VALUE:	On success, returns the previous handler for the signal (which
					could be SIG_DFL or SIG_IGN).
					On failure, sets <errno> to EINVAL and returns SIG_ERR.

SEE ALSO:	raise

END DESCRIPTION **********************************************************/
/*
	DEVNOTE: eventually would like to have this be true:
					Note that on the Rabbit platform, only SIGFPE signals are
					generated within the libraries.  The other signals will only
					be generated by a call to the signal() function.
*/
_signal_debug
// Dynamic C can't handle standard declaration:
// void (*signal( int sig, void (*func)(int)))(int)
_signal_func *signal( int sig, _signal_func *func)
{
	_signal_func *handler;

	if (sig < 0 || sig >= _SIGNAL_COUNT || func == SIG_ERR)
	{
		errno = EINVAL;
		return SIG_ERR;
	}
	handler = _signal_table[sig];
	_signal_table[sig] = func;

	return handler;
}

/*** BeginHeader raise */
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
raise                                                           <signal.h>

SYNTAX:	int raise( int sig)

DESCRIPTION:	Sends signal <sig> to the program.  If a signal handler has
					been registered with signal(), raise() will set the handler
					back to SIG_DFL before calling the registered handler.

PARAMETER 1:	Signal to send, must be one of the following:

					SIGABRT:	Abnormal termination, such as initiated by abort().
					SIGFPE:	Floating-point exception (e.g., div by zero, overflow).
					SIGILL:	Illegal instruction.
					SIGINT:	Interactive attention signal.
					SIGSEGV:	Invalid access to storage.
					SIGTERM:	Termination request sent to program.

RETURN VALUE:	0 on success, -EINVAL if <sig> is invalid.

SEE ALSO:	signal

END DESCRIPTION **********************************************************/
_signal_debug
int raise( int sig)
{
	_signal_func *handler;

	if (sig < 0 || sig >= _SIGNAL_COUNT)
	{
		return -EINVAL;
	}

	handler = _signal_table[sig];
	if (handler == SIG_IGN)			// ignore signal
	{
		// nothing
	}
	else if (handler == SIG_DFL)		// default handler
	{
		// no default behaviors for now
	}
	else
	{
		// revert to default and call the registered handler
		_signal_table[sig] = SIG_DFL;
		handler(sig);
	}

	return 0;
}