/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/*** BeginHeader */
#if !defined __IDBLOCK_LIB
#define __IDBLOCK_LIB
/*** EndHeader */

/* START LIBRARY DESCRIPTION ***************************************************
IDBLOCK.LIB

DESCRIPTION:
   Functions to access the ID block in Rabbit Semiconductor product flash
   devices.

VERSION:
   5.0 (tableVersion = 5)
END DESCRIPTION ***************************************************************/

/* START STRUCTURE DESCRIPTION *******************************************
SysIDBlock						<IDBLOCK.LIB>

DESCRIPTION:	This structure contains a copy of the ID block read off
the flash device, if present.

END DESCRIPTION **********************************************************/

/*** BeginHeader */

#define IDUSERBLOCKS_FLASHNUM 1



typedef	struct _SysIDBlockType2 {
	uint8    flashMBC;     // Memory Bank Configurations
	uint8    flash2MBC;
	uint8    ramMBC;
	uint32   devSpecLoc;		// Count of additional memory devices immediately
									//  preceding this block
	uint32 	macrosLoc;		// Start of the macro table for additional board
									//  configuration options.
	uint32	driversLoc;		// offset to preloaded drivers start from ID block
									//  start (positive is below ID block)
	uint32	ioDescLoc;		// offset to I/O descriptions start from ID block
									//  start (positive is below ID block)
	uint32	ioPermLoc;		// offset to User mode I/O permissions start from ID
									//  block start (positive is below ID block)
	uint32	persBlockLoc;	// offset to persistent storage block area start from
									//  ID block start (positive is below ID block)
	uint16	userBlockSiz2;	// size of v. 5 "new style" mirrored User block image
	uint16	idBlockCRC2;	// CRC of SysIDBlockType2 type with idBlockCRC2
									//  member reset to zero and base CRC value of
									//  SysIDBlock.idBlockCRC
} SysIDBlockType2;

typedef struct _SysIDBlockType {
	uint16	tableVersion;		// version number for this table layout
	uint16	productID;			// Rabbit Semiconductor part #
	uint16	vendorID;			// 1 = Rabbit Semiconductor
	uint8		timestamp[7];		//	YY/M/D H:M:S
	uint32	flashID;				// Rabbit Semiconductor part # dev on cs0 oe0 (normally primary flash)
	uint16	flashType;			// Write method
	uint16	flashSize;			// in 1000h pages
	uint16	sectorSize;			// size of flash sector in bytes
	uint16	numSectors;			// number of sectors
	uint16	flashSpeed;			// in nanoseconds
	uint32	flash2ID;				// Rabbit Semiconductor part #, 2nd flash
	uint16	flash2Type;			// Write method, 2nd flash
	uint16	flash2Size;			// in 1000h pages, 2nd flash
	uint16	sector2Size;		// size of 2nd flash's sectors in bytes
	uint16	num2Sectors;		// number of sectors
	uint16	flash2Speed;		// in nanoseconds, 2nd flash
	uint32	ramID;				// Rabbit Semiconductor part #
	uint16	ramSize;			// in 1000h pages
	uint16	ramSpeed;			// in nanoseconds
	uint16	cpuID;				// CPU type identification
	uint32	crystalFreq;		// in Hertz
	uint8		macAddr[6];			// Media Access Control (MAC) address
	uint8		serialNumber[24];	// device serial number
	uint8		productName[30];	// null-terminated string
	// Begin new version 5 System ID block member structure.
	// Note:  Versions of Dynamic C released prior to those which fully support
	//        the version 5 ID+User blocks will simply ignore the new version 5
	//        ID block members.  When loading a version 4 or prior ID block,
	//        versions of Dynamic C that know about the new version 5 ID block
	//        members will zero-fill the new members upon recognizing the older
	//        version ID block.
	SysIDBlockType2 idBlock2;	// idblock
	// End new version 5 System ID block member structure.
	uint8		reserved[1];	// allow future expansion (EG: see addition of v. 5's
									//  idblock2 member structure, above)
	uint32	idBlockSize;	// size of versions 1,2,3,4 ID block
	uint16	userBlockSize;	// when nonzero, size of User block for ID block
									//  versions 1,2,3,4
	uint16	userBlockLoc;	// when nonzero, offset to User block start from
									//  ID block versions 1,2,3,4 start (below ID block)
	uint16	idBlockCRC;		// CRC of SysIDBlock with idBlockCRC member reset to
									//  zero and base CRC value of zero, and excluding
									//  idBlock2 and reserved members
	uint8		marker[6];		// valid if [0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA]
} SysIDBlockType;

#define MACRO_NAME_SIZE 9
#define MACRO_TABLE_SIZE (0x100 / sizeof (MacroTableEntry))
#define MEMORY_DEVICE_TABLE_SIZE (0x100 / sizeof (MemDevSpec))

typedef struct
{
	char name[MACRO_NAME_SIZE];
   unsigned long value;
} MacroTableEntry;

typedef struct _MemDevSpec {
	uint32	ID;				// Rabbit Semiconductor part #, 0 = SRAM, other = flash id
	uint16	type;			   // Write method
	uint16	devSize;		   // in 1000h pages
	uint16	sectorSize;		// size of flash sector in bytes
	uint16	numSectors;		// number of sectors
	uint16	devSpeed;		// in nanoseconds
   uint8    MBC ;          // Memmory bank configuration (Chip selects, waits, etc)
} MemDevSpec;


SysIDBlockType	SysIDBlock;

// Conditionally define static variables.  Since serial boot flash
// devices require costates, make some local variables static so that
// costates remember the necessary state.
#if !_SERIAL_BOOT_FLASH_
	#define _SBF_STATIC
#else
	#define _SBF_STATIC static
#endif

/*** EndHeader */

/*** BeginHeader _ub_sBuf */
// Small static buffers for serial flash buffering
// Size must be power of 2
#define _UB_SBUF_SIZE 128
extern __far char _ub_sBuf[_UB_SBUF_SIZE];

/*** EndHeader */
__far char _ub_sBuf[_UB_SBUF_SIZE];

/*** BeginHeader _ub_dBuf */
extern __far char _ub_dBuf[_UB_SBUF_SIZE];

/*** EndHeader */
__far char _ub_dBuf[_UB_SBUF_SIZE];

/******************************************************************************/

/*** BeginHeader IDBlockAddr */
extern unsigned long	IDBlockAddr;		// physical address of the ID blocks
/*** EndHeader */
unsigned long	IDBlockAddr;

/*** BeginHeader UserBlockAddr */
extern unsigned long	UserBlockAddr;		// physical address of the user blocks
/*** EndHeader */
unsigned long	UserBlockAddr;

/*** BeginHeader IDBlockSector */
extern int IDBlockSector;		// sector # of 1st sector in ID blocks
/*** EndHeader */
int IDBlockSector;

/*** BeginHeader UserBlockSector */
extern int UserBlockSector;	// sector # of 1st sector in user blocks
/*** EndHeader */
int UserBlockSector;


/*** BeginHeader	_getIDBlockTotalSize */
long _getIDBlockTotalSize(void);
/*** EndHeader */
__nodebug
long _getIDBlockTotalSize(void)
{
   if (SysIDBlock.userBlockSize)
      return SysIDBlock.idBlockSize + SysIDBlock.userBlockLoc;
   else if (SysIDBlock.idBlock2.userBlockSiz2)
      return SysIDBlock.idBlock2.userBlockSiz2 + 6ul;
   else
   	return 0;
}

/*** BeginHeader	_findUserBlockStart */
__root void _findUserBlockStart(void);
/*** EndHeader */

/* START_FUNCTION DESCRIPTION *********************************************
_findUserBlockStart           <IDBLOCK.LIB>

SYNTAX:  void _findUserBlockStart(void);

DESCRIPTION:
   Determines the address of the lowest copy of the User block. Loads the
   address and sector (flash page number) into the global variables
   UserBlockAddr and UserBlockSector.

   NOTE!!!!!
      This function should not be called by the user application.

RETURN VALUE:
   None.
END DESCRIPTION **********************************************************/

__nodebug __root
void _findUserBlockStart(void)
{
#if _SERIAL_BOOT_FLASH_
	// the system ID block is *always* located at the top of the boot flash
	IDBlockAddr = (uint32) _sfb_dev.pagesize * (uint32) _sfb_dev.npages -
	              SysIDBlock.idBlockSize;
#endif

	// calculate the system ID block's sector number (note that the
	//  SysIDBlock.idBlock2.persBlockLoc value will be zero for all but version
	//  5+ unique system ID blocks)
	IDBlockSector = _LongToSector(IDBlockAddr -
	                              SysIDBlock.idBlock2.persBlockLoc);
	// calculate the User block (if mirrored, image B's) address
	if (SysIDBlock.userBlockSize)
	{
		// combined (and possibly mirrored) system ID + User blocks
		UserBlockAddr = IDBlockAddr - SysIDBlock.userBlockSize;
		if (SysIDBlock.tableVersion > 2)
		{
			// this version 3 or later system ID block is combined with the User
			//  block, so subtract the mirrored size to get image B's address
			UserBlockAddr -= SysIDBlock.idBlockSize + SysIDBlock.userBlockSize;
		}
		// protect the system ID and / or User blocks from this sector number & up
		UserBlockSector = _LongToSector(UserBlockAddr);
	}
	else if (SysIDBlock.idBlock2.userBlockSiz2)
	{
		// version 5 or later unique system ID block w/ mirrored User block images
		// first, get the User block image A "rough" address then sector number
		UserBlockAddr = _SectorToLong(IDBlockSector) -
		                SysIDBlock.idBlock2.userBlockSiz2 -
		                sizeof SysIDBlock.marker;
		UserBlockSector = _LongToSector(UserBlockAddr);
		// next, get the User block image B "rough" address then sector number
		UserBlockAddr = _SectorToLong(UserBlockSector) -
		                SysIDBlock.idBlock2.userBlockSiz2 -
		                sizeof SysIDBlock.marker;
		// protect the system ID and / or User blocks from this sector number & up
		UserBlockSector = _LongToSector(UserBlockAddr);
		// last, get the User block image B "actual" (boundary-aligned) address
		UserBlockAddr = _SectorToLong(UserBlockSector);
	}
	else
	{
		// no User block, so just designate the system ID block area as protected
		UserBlockAddr = _SectorToLong(IDBlockSector);
		// protect the system ID and / or User blocks from this sector number & up
		UserBlockSector = IDBlockSector;
	}
}

/*** BeginHeader GetIDBlockSize */
__xmem int GetIDBlockSize();
/*** EndHeader */
/********************************************************************
Return in HL the size of one buffered writable flash data block in
1000h blocks

This function is badly named, it really has more to do with reporting
the User block size than the ID block size.
********************************************************************/
__xmem __nodebug
int GetIDBlockSize()
{
	//*** returns System/user block size in 4k units
	auto char *tabptr;
	auto int retval;

	// Default to zero in case flash type is incompatible with a User block,
	//  or the board just has no User block allocated.
	retval = 0;

	if (!SysIDBlock.userBlockSize && SysIDBlock.idBlock2.userBlockSiz2) {
		// For ID block versions 5 and up with "new style" User block, round up
		//  the ID block's (presumed reliable) new secondary User block image size
		//  to the next 4 KB boundary.
		// NB:  Each "new style" User block image is followed by a six byte
		//      validity marker which is generally included within the 4 KB
		//      boundary.
		retval = (int) ((SysIDBlock.idBlock2.userBlockSiz2 + 0x0FFFul) >> 12ul)
		               & 0x001F;
	}
   else {
		//*** Small sector types (uniform sector size <= 4K)
      // ID block versions 2 through 4 and "old style" version 5 ID block
      retval = (int) (((unsigned long) SysIDBlock.idBlockSize
                      + IDBlockAddr - UserBlockAddr) >> 12ul)
                      & 0x001F;
      // mirrored ID+User Blocks, actual size is half
      retval >>= 1;
	}
   return retval;
}

/*** BeginHeader	_readIDBlock */

__root int _readIDBlock(int);

/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
_readIDBlock                  <IDBLOCK.LIB>

SYNTAX:  int _readIDBlock(int flash_bitmap)

PARAMETER1:  Bitmap of memory quadrants mapped to the primary flash.
             Examples:  0x01 = quadrant 0 only
                        0x03 = quadrants 0 and 1
                        0x0C = quadrants 2 and 3

DESCRIPTION:  Attempts to read the system ID block from the highest flash
quadrant and save it in the system ID block structure.  It performs a CRC
check on the block to verify that the block is valid.  If an error occurs,
SysIDBlock.tableVersion is set to zero.

Starting with Dynamic C version 8, this function supports combined System
ID/User blocks sizes of sizeof(SysIDBlock) and from 4 KB to 64 KB,
inclusive, in 4 KB steps. Prior versions of Dynamic C only supported
mirrored combined System ID/User blocks sizes of sizeof(SysIDBlock), 8 KB,
16 KB and 24 KB or unmirrored combined System ID/User blocks sizes of
sizeof(SysIDBlock) and from 4 KB to 32 KB, inclusive, in 4 KB steps.

Starting with Dynamic C version 9.50, this function supports version 5
unique ID plus mirrored User blocks. The version 5 uID+mUser blocks
standard configuration is as follows:
  1) A 16 KB reserved area containing the unique ID block, located at the
     top of the /CS0 flash. The remainder of the 16 KB area may be used
     for persistent data storage, such as preloaded drivers or I/O
     configuration and/or I/O permissions information.
  2) An 8 KB reserved area containing the User block "A" image, located at
     the beginning of the flash sector(s) immediately below the lowest
     addressed flash sector which contains any part of the 16 KB reserved
     ID block plus persistent data storage area.
  3) An 8 KB reserved area containing the User block "B" image, located at
     the beginning of the flash sector(s) immediately below the lowest
     addressed flash sector which contains any part of the 8 KB reserved
     User block "A" image area.

RETURN VALUE:   0 if successful
               -1 if error reading from flash
               -2 if ID block missing
               -3 if v. 1,2,3,4 ID block invalid (failed CRC check)
               -4 if v. 5 ID block invalid (failed CRC2 check)

IMPORTANT NOTE: For products with serial boot flash that share the
                serial flash SPI lines with other devices, this function
                should not be called while  multi-tasking SPI sharing
                can happen, it should just be called during initialization.

END DESCRIPTION *********************************************************/

#use "math.lib"			// needed for getcrc() function

#asm __root __nodebug
_readIDBlock::
#if _SERIAL_BOOT_FLASH_
		call	_sbf_readSysID
		test	hl
		jr		nz, .noIDblock
#else
		;; it's a parallel boot flash
 #if defined PILOT_BIOS
		;; The parallel flash boot pilot BIOSes always set up a 4 megabyte
		;;  quadrant size; MSB_BIT is redefined approriately.
		;; Hardcoded quadrant 2 for now; we must somehow accommodate the MSB_BIT
		;;  address line inversion setting when we get a parallel flash size
		;;  greater than 4 megabytes.

		; get the specified memory quadrant's last flash byte address into PX,
		;  accounting for possibly different quadrant vs. flash sizes
		ld		px, _cexpr(_QUADRANT_SIZE * 2ul + (_QUADRANT_MASK & _FLASH_MASK))
 #else
		;; Determine the top memory quadrant mapped to flash.
		ld		a, L
.flashInQ3:
		bit	3, a
		jr		z, .flashInQ2

		; get the specified memory quadrant's last flash byte address into PX,
		;  accounting for possibly different quadrant vs. flash sizes
		ld		px, _cexpr(_QUADRANT_SIZE * 3ul + (_QUADRANT_MASK & _FLASH_MASK))
		jr		.copystart

.flashInQ2:
		bit	2, a
		jr		z, .flashInQ1

		; get the specified memory quadrant's last flash byte address into PX,
		;  accounting for possibly different quadrant vs. flash sizes
		ld		px, _cexpr(_QUADRANT_SIZE * 2ul + (_QUADRANT_MASK & _FLASH_MASK))
		jr		.copystart

.flashInQ1:
		bit	1, a
		jr		z, .flashInQ0

		; get the specified memory quadrant's last flash byte address into PX,
		;  accounting for possibly different quadrant vs. flash sizes
		ld		px, _cexpr(_QUADRANT_SIZE * 1ul + (_QUADRANT_MASK & _FLASH_MASK))
		jr		.copystart

.flashInQ0:
		bit	0, a
		jp		z, .noflashquad	; if no quadrant bits set, error

		; get the specified memory quadrant's last flash byte address into PX,
		;  accounting for possibly different quadrant vs. flash sizes
		ld		px, _cexpr(_QUADRANT_SIZE * 0ul + (_QUADRANT_MASK & _FLASH_MASK))
.copystart:
 #endif
		ld		b, 17					; check 17 locations for the system ID block:
										;   top-0K, top-4K, top-8K, ..., top-64K
.copyheader:
		ld		pz, px				; save a copy of this location's top address
		;; copy top 16 bytes of block to SysIDBlock struct in RAM
		push	bc						; save locations count
		; get the near address of SysIDBlock's last byte into DE
		ld		de, _cexpr(SysIDBlock + sizeof SysIDBlock - 1u)
		; get the far address of SysIDBlock's last byte into PY
		ldl	py, de
		; get the length from SysIDBlock.idBlockSize to the end of SysIDBlock
		ld		bc, _SysIDBlockType+@LENGTH-idBlockSize
		; Ideally, it would be nice to have offsetof() working in asm code!
;		ld		bc, _cexpr(sizeof SysIDBlock - offsetof(SysIDBlock, idBlockSize))
		copyr							; copy top 16 bytes of block to RAM
		;; check for 55 AA 55 AA 55 AA marker at end of ID block
		ld		hl, SysIDBlock+marker
		ld		b, 6
		ld		a, 0x55
.loop1:
		cp		(hl)
		jr		nz, .badmarker

		inc	hl
		cpl
		djnz	.loop1

		jr		.copyblock

.badmarker:
.checkCRC_failed:
		ld		jkhl, pz				; get last location's top address into JKHL
		ld		px, 0x1000			; get the 0x1000 byte block length into PX
		ld		bcde, px
		sub	jkhl, bcde			; calculate the next location's top address
		ld		px, jkhl
		pop	bc						; recover the locations down-counter
		djnz	.copyheader

		jp		.noIDblock

.copyblock:
		;; copy remainder of ID block to RAM
		ld		px, pz+1				; get address of current location top (+1) into PX
		ld		jkhl, px
		ld		bcde, (SysIDBlock+idBlockSize)	; get the system ID block size
		sub	jkhl, bcde			; calculate system ID block's flash start address
		ld		(IDBlockAddr), jkhl	; save it for later use (incl. by pilot BIOS)
		ld		px, jkhl				; copy source physical address
		ld		de, SysIDBlock		; copy destination near address
		ldl	py, de				; copy destination far address
		ld		bc, _SysIDBlockType+idBlockSize	; copy size = offset to idBlockSize
		copy
		push	pz						; preserve the last location's top address
		call	.checkCRC			; we call our local subroutine to check the CRC(s)
		pop	pz						; recover the last location's top address
		test	hl
		jr		nz, .checkCRC_failed

		add   sp, 2					; clean up stack residue (BC down-counter value)
		ret

.checkCRC:
		;; Our local subroutine is really just the remainder of the _readIDBlock()
		;;  function, which is common to all compile modes!
#endif	//!_SERIAL_BOOT_FLASH_

		;; perform CRC check(s) on the SysIDBlock structure's copied content
		ld		hl, (SysIDBlock+idBlockCRC) ; get as-copied CRC value
		push	hl						; save it for comparison later
		clr	hl
		ld		(SysIDBlock+idBlockCRC), hl	; clear out the CRC value
		;; first, do CRC on SysIDBlock part before the idBlock2 and reserved fields
		; put getcrc()'s accum (base CRC is 0) parameter on the stack
		push	hl
		; put getcrc()'s count (length) parameter on the stack
		push _SysIDBlockType+idBlock2
		; put getcrc()'s *dataarray (address) parameter on the stack
		ldl	px, SysIDBlock
		push	px
		call	crc16_calc
		add	sp, 8					; clean up stack residue
		;; second, continue CRC on last 16 bytes of SysIDBlock
		; put getcrc()'s accum (continued CRC) parameter on the stack
		push	hl
		; put getcrc()'s count (length) parameter on the stack
		push	sizeof(SysIDBlockType)-(_SysIDBlockType+idBlockSize)
		; put getcrc()'s *dataarray (address) parameter on the stack
		ldl	px, SysIDBlock+idBlockSize
		push	px
		call	crc16_calc
		add	sp, 8					; clean up stack residue
		; hl now contains CRC value for versions 1,2,3,4 ID block
		pop	de						; recover the as-copied ID block CRC value
		or		a						; clear the Carry flag
		sbc	hl, de
		jp		nz, .badCRC

		;; versions 1,2,3,4 ID block CRC matches, restore CRC value to SysIDBlock
		ld		(SysIDBlock+idBlockCRC), de

		;; if this is a version 5 (or greater) ID block, then check the CRC2 value
		ld		hl, (SysIDBlock+tableVersion)				; get ID block version
		cp		hl, 5
		jr		c, .v1234IDBlock

		ld		hl, (SysIDBlock+idBlock2+idBlockCRC2)	; get as-copied CRC2 value
		push	hl						; save it for comparison later
		clr	hl
		ld		(SysIDBlock+idBlock2+idBlockCRC2), hl	; clear out the CRC2 value
		;; third, do CRC2 on SysIDBlock middle part after the 'reserved' field
		; put getcrc()'s accum (continued original CRC) parameter on the stack
		ld		hl, (SysIDBlock+idBlockCRC)
		push	hl
		; put getcrc()'s count (length) parameter on the stack
		push	sizeof(SysIDBlockType2)
		; put getcrc()'s *dataarray (address) parameter on the stack
		ldl	px, SysIDBlock+idBlock2
		push	px
		call	crc16_calc
		add	sp, 8					; clean up stack residue
		; hl now contains CRC2 value for version 5 ID block
		pop	de						; recover the as-copied ID block CRC2 value
		or		a						; clear the Carry flag
		sbc	hl, de
		jp		nz, .badCRC2

		;; version 5 ID block CRC2 matches, so restore CRC2 value to SysIDBlock
		ld		(SysIDBlock+idBlock2+idBlockCRC2), de
		jr		.okdone

.v1234IDBlock:
		ld		hl, SysIDBlock+idBlock2
		ld		b, _SysIDBlockType+idBlockSize-idBlock2
		xor	a
.clearV5Members:
		ld		(hl), a
		inc	hl
		djnz	.clearV5Members

.okdone:
		;; if flash driver init was successful then get User block start address
		ld		hl, (_InitFlashDriverOK)
		test	hl
		jr		z, .done

		call	_findUserBlockStart
		clr	hl
.done:
		ret

.noflashquad:
		ld		bcde, -1
		jr		.errorexit

.noIDblock:
		ld		bcde, -2
		jr		.errorexit

.badCRC:
		ld		bcde, -3
		jr		.errorexit

.badCRC2:
		ld		bcde, -4
.errorexit:
		;; At this point, BC content is ignored and DE contains error result code.
		;; On error, reset both IDBlockAddr and SysIDBlock.tableVersion to zero.
		ld		jkhl, 0
		ld		(IDBlockAddr), jkhl
		ld		(SysIDBlock+tableVersion), hl
		ex		de, hl				; get error result code into HL
		jr		.done
#endasm

/******************************************************************************/

/*********************************************************
  Internal function to get user block info.
*********************************************************/

/*** BeginHeader _GetUserBlockInfo, GetUserBlockInfo, savedUBI */
struct userBlockInfo{
	unsigned long addrA;			// start of block A
	unsigned long addrB;			// start of block B
	unsigned long blockSize;	// set to 0 if no good block found
	unsigned long topAddr;		// = flash size
	int  blockAvalid;				//  0 if block B only valid
	unsigned long totSize;		// Total userID block size (cached from
										//  _getIDBlockTotalSize())
};

extern const char validMarker[];
extern __far struct userBlockInfo savedUBI;

void _GetUserBlockInfo(struct userBlockInfo __far *uBI);
const struct userBlockInfo __far * GetUserBlockInfo(struct userBlockInfo __far *uBI);

/*** EndHeader */

__far struct userBlockInfo savedUBI;

__nodebug
const struct userBlockInfo __far * GetUserBlockInfo(struct userBlockInfo __far *uBI)
{
	#GLOBAL_INIT {
	   // Only read the flash on program start up
	   // so we don't tie up serial pins or waste time.
	   // NOTE: we used to call this function every time, with the assumption
	   // that it would be more resistant to "memory trashing" errors, however
	   // we rely on an in-core system ID block mirror, as well as other
	   // critical data, so there's no point in trying to be more robust
	   // with the userID block.
	   _GetUserBlockInfo(&savedUBI);
	}

	if (uBI)
		_f_memcpy(uBI, &savedUBI, sizeof(struct userBlockInfo));
	return &savedUBI;
}

#if !defined V2_USE_USERBLOCKADDR
	#define V2_USE_USERBLOCKADDR 0
#endif

const char validMarker[]={"\x55\xAA\x55\xAA\x55\xAA"};

#if _SERIAL_BOOT_FLASH_
	#define fmem2root(x,y,z) _sbfReadUsr(x,y,z)
#else
	#define fmem2root(x,y,z) xmem2root(x,y,z)
#endif

__nodebug
void _GetUserBlockInfo(struct userBlockInfo __far *uBI)
{
	auto char validTest[6];
	auto int sectorNumber;
	auto uint32 offset;
#if !_SERIAL_BOOT_FLASH_ && (FAST_RAM_COMPILE || RAM_COMPILE)
	// FAST_RAM_COMPILE and RAM_COMPILE modes have (at least) the top portion of
	// the primary parallel flash mapped into the MB3CR quadrant. The system ID
	// and User blocks are then located at or near the top of Rabbit's physical
	// memory, so the offset (difference) from the top of physical memory to the
	// size (i.e. top, as if mapped to start at physical address 0) of the
	// primary parallel flash must be accounted for.
	auto uint32 idBlockOfst;
#endif

	// initially zero all struct members
	_f_memset(uBI, 0, sizeof(struct userBlockInfo));

// NB:  In order to accommodate odd flash types such as the nonuniform
//      sector size nonerasable-boot-sector Atmel AT49F002(N)T, whose
//      topmost (boot) sector is unusable, the following conditional
//      code makes use of the _SectorToLong function.  The flash
//      information table entry for such a flash type simply has the
//      number of sectors item reduced by the number of unusable
//      sectors.  This allows the flash information table to retain its
//      powers-of-two flash size items, thus avoiding nasty side-effects
//      such as errant calculations of flash masks and memory sizes.

#if _SERIAL_BOOT_FLASH_
	// The ID Block is located at or near the top of the serial boot flash.
	uBI->topAddr = (uint32) _sfb_dev.pagesize * (uint32) _sfb_dev.npages;
#else
	// The ID Block is located at or near the top of the primary parallel flash.
	uBI->topAddr = _SectorToLong(getNumSectors());
 #if FAST_RAM_COMPILE || RAM_COMPILE
	// Calculate the offset (difference) from the top of physical memory to the
	// size (i.e. top, as if mapped to start at physical address 0) of the
	// primary parallel flash.
	idBlockOfst = (1ul << (MSB_BIT + 1)) - uBI->topAddr;
 #endif
#endif
	uBI->blockSize =  GetIDBlockSize() * 4096ul;

	if (uBI->blockSize)
	{
		assert(SysIDBlock.tableVersion == 5);
		if (SysIDBlock.userBlockSize)
		{
#if !_SERIAL_BOOT_FLASH_ && (FAST_RAM_COMPILE || RAM_COMPILE)
			// Account for the offset (difference) from the top of physical memory
			// to the size (i.e. top, as if mapped to start at physical address 0)
			// of the primary parallel flash.
			uBI->topAddr += idBlockOfst;
#endif
			// "Old style" mirrored combined ID/User block images, located
			//  immediately below the top of flash, possibly with a storage area
			//  gap between the ID and User blocks within an image.
			uBI->addrA = uBI->topAddr -
			             (SysIDBlock.idBlockSize + SysIDBlock.userBlockLoc);
			uBI->addrB = uBI->addrA -
			             (SysIDBlock.idBlockSize + SysIDBlock.userBlockLoc);
			// we have to trust the original User block size in the ID Block!
			uBI->blockSize = SysIDBlock.userBlockSize;
			//*** block A valid? ***
			fmem2root(validTest, uBI->topAddr - 6ul, 6u);
			if (!memcmp(validMarker, validTest, 6u))
			{
				uBI->blockAvalid = 1;
			}
			else
			{
				//*** block B valid? ***
				fmem2root(validTest, uBI->addrA - 6ul, 6u);
				if (memcmp(validMarker, validTest, 6u))
				{
					uBI->blockSize = 0ul;	// no valid block
				}
			}
		}
		else if (SysIDBlock.idBlock2.userBlockSiz2)
		{
			// "New style" unique ID block plus mirrored User block images,
			//  located immediately below the top of flash, possibly with a
			//  persistent storage area between the ID block and the top-most
			//  User block image.  None of the ID block and the User block
			//  images are permitted to share a flash sector.
			// NB:  Each "new style" User block image is followed by a six byte
			//      validity marker which is generally included within the
			//      flash sector (and typically also 4 KB) boundary.
#if _SERIAL_BOOT_FLASH_
			// Need to adjust for non-power-of-two page sizes
			offset = SysIDBlock.idBlock2.persBlockLoc&0xFFFFF000UL;
			if(!_sfb_dev.binaryMode) offset += 0x1000UL;
#else
			offset = SysIDBlock.idBlock2.persBlockLoc;
#endif
			sectorNumber = _LongToSector(uBI->topAddr - offset);
			uBI->addrA = _SectorToLong(sectorNumber);
#if _SERIAL_BOOT_FLASH_
			// Need to adjust for non-power-of-two page sizes
			offset = SysIDBlock.idBlock2.userBlockSiz2&0xFFFFF000UL;
			if(!_sfb_dev.binaryMode) offset += 0x1000UL;
#else
			offset = SysIDBlock.idBlock2.userBlockSiz2;
#endif
			sectorNumber = _LongToSector(uBI->addrA - 6ul - offset);
			uBI->addrA = _SectorToLong(sectorNumber);
			sectorNumber = _LongToSector(uBI->addrA - 6ul - offset);
			uBI->addrB = _SectorToLong(sectorNumber);
#if !_SERIAL_BOOT_FLASH_ && (FAST_RAM_COMPILE || RAM_COMPILE)
			// Account for the offset (difference) from the top of physical memory
			// to the size (i.e. top, as if mapped to start at physical address 0)
			// of the primary parallel flash.
			uBI->topAddr += idBlockOfst;
			uBI->addrA += idBlockOfst;
			uBI->addrB += idBlockOfst;
#endif
			// we have to trust the secondary User block size in the ID Block!
			uBI->blockSize = SysIDBlock.idBlock2.userBlockSiz2;
			//*** block A valid? ***
			fmem2root(validTest, uBI->addrA + uBI->blockSize, 6u);
			if (!memcmp(validMarker, validTest, 6u))
			{
				uBI->blockAvalid = 1;
			}
			else
			{
				//*** block B valid? ***
				fmem2root(validTest, uBI->addrB + uBI->blockSize, 6u);
				if (memcmp(validMarker, validTest, 6u))
				{
					uBI->blockSize = 0ul;	// no valid block
				}
			}
		}
		else
		{
			uBI->blockSize = 0ul;	// no User block allocated?
		}
		uBI->totSize = _getIDBlockTotalSize();
	}
}

/* START FUNCTION DESCRIPTION ********************************************
_GetSysMacroValue			<IDBLOCK.LIB>

SYNTAX: int _GetSysMacroValue(char *name, long* value)

PARAMETER1:		Name of system id block macro (acts as lookup key).
PARAMETER2:		Pointer to macro value to return to caller.

DESCRIPTION:   Finds the system table macro named by the first parameter (as
defined by the compiler) and retrieves the value of the macro as defined in
the system macro table.  The system macro table contains board specific
configuration parameters that are define by the compiler and can be retrieved
at runtime through this interface.  The flash driver must be initialized and
the system ID block must be read before this function will return accurate
results.

See writeUserBlockArray for more details.

RETURN VALUE:	 0 if successful
					-1 Macro name not found
               -2 No valid ID block found (block version 3 or later)
               -3 First parameter is a bad macro name
               -4 Macro table corrupt

IMPORTANT NOTE: For products with serial boot flash that share the
                serial flash SPI lines with other devices, this function
                and _GetSysMacroIndex should not be called while
                multi-tasking SPI sharing can happen, they should
                just be called during initialization.

END DESCRIPTION **********************************************************/

/*** BeginHeader _GetSysMacroValue */
int _GetSysMacroValue(char * name, uint32 * value);
/*** EndHeader */

__nodebug
int _GetSysMacroValue(char * name, uint32 * value)
{
	// The compiler changes a macro xx in the macro table to _DC_xx_ as used by
	// library and sample code; these macros help clarify the logic of unwrapping
	// the macro parameter.
	#define COMPILER_PFX 4
	#define COMPILER_SFX 1
	#define COMPILER_CHRS (COMPILER_PFX + COMPILER_SFX)

	// This is the layout of the macro table header at the beginning of the
	// macro table.
	typedef struct {
		unsigned int sz;
		char version;
	} Header;

	auto unsigned int 			length; // Multipurpose

	// The name of the macro as stored in the macro table.
	auto char 						macro_name[MACRO_NAME_SIZE];

	// A small buffer to hold the maximum macro table entry. This is not of type
	// MacroTableEntry because the macro table is packed so that strings only
	// take exactly the space they require.
	auto char						raw_buffer[sizeof (MacroTableEntry)];

	// Intended to point to the end of the string of the current macro table.
	auto char *                null_char_ptr;

	auto Header 					header; // A copy of the header.
	auto Header __far * 			header_ptr; // A pointer to the header.
	auto char __far * 				raw_ptr; // A pointer to the current entry.
	auto char __far * 				raw_ptr_end; // The end of the macro table.
	// --- END OF DECLARATIONS ---


	if (SysIDBlock.idBlock2.macrosLoc == 0)
	{
		return -1;
	}

	if (IDBlockAddr == 0)
	{
		return -2;
	}

	// Convert the compiler macro name to the true ID block form by removing the
	// wrapping characters the compiler adds.
	length = strlen(name);
	if (length < COMPILER_CHRS + 1 ||
	    length > COMPILER_CHRS + MACRO_NAME_SIZE - 1)
	{
		return -3;	// The macro name is out of range.
	}
	strncpy(macro_name, name + COMPILER_PFX, length - COMPILER_CHRS);
	macro_name[length - COMPILER_CHRS] = '\x00';

	header_ptr = (Header __far *) (IDBlockAddr - SysIDBlock.idBlock2.macrosLoc);

#if _SERIAL_BOOT_FLASH_
	_sbfReadUsr(&header, (unsigned long) header_ptr, sizeof header);
#else
	header = *header_ptr;
#endif

	if (header.version != 0)
	{
		return -4;	// Version 0 macro tables are latest.
	}

	// This block reads a full entry length worth of data into the raw buffer.
	// It then searches the raw buffer for the null character that should
	// terminate the string and errors if not found. This null character also
	// marks the beginning of the macro value.
	// On entry, 'length' does not have an appropriate value to increment the
	// pointer, but is calculated within the loop; The 'length' variable is re-
	// used to conserve stack space.
	for (raw_ptr = (char __far *)(header_ptr + 1),
	     raw_ptr_end = raw_ptr + (header.sz - sizeof header);
	     raw_ptr < raw_ptr_end; raw_ptr += length)
	{
		// Get the entry, then check for a match.
#if _SERIAL_BOOT_FLASH_
		_sbfReadUsr(&raw_buffer, (unsigned long)raw_ptr,
		            sizeof (MacroTableEntry));
#else
		_f_memcpy((void __far *)(&raw_buffer), raw_ptr, sizeof (MacroTableEntry));
#endif
		for (null_char_ptr = raw_buffer, length = 0;
		     *null_char_ptr != '\x00' && length < MACRO_NAME_SIZE;
		     ++null_char_ptr, ++length)
			;
		if (length == MACRO_NAME_SIZE)
		{
			return -4;
		}
		length += 1 + sizeof (uint32);	// '1 +' for null character

		if (!strncmp(macro_name, raw_buffer, MACRO_NAME_SIZE))
		{
			*value = *(uint32 *)(null_char_ptr + 1);
			return 0;
		}
	}
	return -1;
}

/* START FUNCTION DESCRIPTION ********************************************
_GetSysMacroIndex			<IDBLOCK.LIB>

SYNTAX: int _GetSysMacroIndex(int n, char* buf, uint32* value)

PARAMETER1:		The nth
PARAMETER2:    Character array to contain and return macro name (copied from
					system macro table).	MUST BE AT LEAST SYS_MACRO_LENGTH bytes
               or function will overflow buffer and can crash system!!!!
PARAMETER3:		Pointer to macro value to return to caller.

DESCRIPTION:	Skips to the nth macro entry and retrieves the macro name (as
defined by the compiler), and the value of the macro as defined in the system
macro table.  The system macro table contains board specific configuration
parameters that are define by the compiler and can be retrieved at runtime
through this interface.  The flash driver must be initialized and the system
ID block must be read before this function will return accurate results.

RETURN VALUE:	 0 if successful
					-1 invalid address or range (use to find end of table)
               -2 ID block or macro table invalid

IMPORTANT NOTE: For products with serial boot flash that share the
                serial flash SPI lines with other devices, this function
                and _GetSysMacroValue should not be called while
                multi-tasking SPI sharing can happen, they should
                just be called during initialization.

SEE ALSO:      _GetSysMacroValue

END DESCRIPTION **********************************************************/

/*** BeginHeader _GetSysMacroIndex */
int _GetSysMacroIndex(int, char* buf, uint32*);
/*** EndHeader */

#define _SYS_MACRO_TABLE_MAXSIZE 256

__nodebug
int _GetSysMacroIndex(int n, char* buf, uint32* value)
{
	auto long mactableloc, mactableend;
	auto uint16 len;
	auto int i;
	auto chr;
	auto char buffer[256],*chptr;

	// Calculate location of macro table
	mactableloc = IDBlockAddr - SysIDBlock.idBlock2.macrosLoc;

	// Get the length of the macro table
#if !_SERIAL_BOOT_FLASH_
	len = xgetint(mactableloc);
#else
	_sbfReadUsr(&len, mactableloc, sizeof len);
#endif

	// End of macro table is used to terminate loop below
	mactableend = mactableloc + len;
	mactableloc += 2;

#if !_SERIAL_BOOT_FLASH_
	chr = (char) xgetint(mactableloc);
#else
	_sbfReadUsr(&i, mactableloc, sizeof i);
	chr = (char) i;
#endif

	if (IDBlockAddr == 0 || (char) chr  != 0 || len > _SYS_MACRO_TABLE_MAXSIZE)
	{
		return -2;
	}
	++mactableloc;

	// Each entry is at least 6 bytes long, table is at most 256 bytes
	if (n > (len / 6))
	{
		return -1;
	}

	i = 0;
	while (i < n)
	{
#if !_SERIAL_BOOT_FLASH_
		mactableloc = (long)_f_memchr((void __far *)mactableloc, '\0', len) + 5;
#else
		_sbfReadUsr(buffer, mactableloc, len);
		if (chptr = memchr(buffer, '\0', len))
		{
			len = (uint16) chptr - (uint16) buffer + 5;
			mactableloc += len;
		}
		else
		{
			mactableloc = 5;
		}
#endif
		// if _f_memchr returns 0 then not found and exit
		if (mactableloc == 5) return -2;
		if (mactableloc >= mactableend) return -1;
		++i;
	}
#if !_SERIAL_BOOT_FLASH_
	len = strlen((char __far *) mactableloc) + 1;
#else
	_sbfReadUsr(buffer, mactableloc, 0x80);
	len = strlen(buffer) + 1;
#endif
	strcpy(buf, "_DC_");
#if !_SERIAL_BOOT_FLASH_
	xmem2root(buf + 4, mactableloc, len);
#else
	_sbfReadUsr(buf+4, mactableloc, len);
#endif
	strcat(buf, "_");
	mactableloc += len;
#if !_SERIAL_BOOT_FLASH_
	*value = xgetlong(mactableloc);
#else
	_sbfReadUsr(value, mactableloc, 4);
#endif
	return 0;
}



/*** BeginHeader _GetDevSpecIndex */
int _GetDevSpecIndex(int n, MemDevSpec *devspec);
/*** EndHeader */
__nodebug
int _GetDevSpecIndex(int n, MemDevSpec *devspec) {
   auto long devspecloc;
   auto uint16 len;
   auto int chr, i;

   if (!SysIDBlock.idBlock2.devSpecLoc)
   {
      return -1;
   }

   // Calculate location of memory devices table
	devspecloc = IDBlockAddr - SysIDBlock.idBlock2.devSpecLoc;
   // Get the length of the macro table
#if !_SERIAL_BOOT_FLASH_
   len = xgetint(devspecloc);
#else
   _sbfReadUsr(&len, devspecloc, 2);
#endif
   // End of memory devices table is used to terminate loop below
   devspecloc += 2;

   // Check that id block is defined, that memory devices table is version 0
   // and that the length of the table is appropriate
#if !_SERIAL_BOOT_FLASH_
   chr = (char) xgetint(devspecloc);
#else
   _sbfReadUsr(&chr, devspecloc, 2);
#endif
   if(IDBlockAddr == 0 || (char) chr != 0 || len > 256) {
   	return -2;
   }
   devspecloc++;

	// Calculate number of dev spec entries in table (-3 for is header of table)
   len = (len - 3)/sizeof(MemDevSpec);

   if(n >= len) {
   	return -1;
   }
   n *= sizeof(MemDevSpec);

   devspecloc += n;
#if !_SERIAL_BOOT_FLASH_
   xmem2root(devspec, devspecloc, sizeof(MemDevSpec));
#else
   _sbfReadUsr(devspec, devspecloc, sizeof(MemDevSpec));
#endif

   return 0;
}



/*** BeginHeader  ********************************************/
#endif
/*** EndHeader ***********************************************/