/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/*
 * usbHostAPI.lib - USB Host controller driver API.
 *
 * Revision History:
 *         Date           Author    Description
 *         Feb. 29, 2008  BMurtha    Initial Dynamic C/Rabbit 6000 port.
 *                                  Work in progress.
 *                                  "//BPM:COIO" means "Commented out in
 *                                       the original" NS code.
 *************************************************************************/

/*** BeginHeader  */

#ifndef __USBHOSTAPI_H
#define __USBHOSTAPI_H

#ifndef USBHOSTAPI_DEBUG
  #define  _usbhostapi_debug __debug
#else
  #define  _usbhostapi_debug __nodebug
#endif

#ifndef USBHOSTAPI_VERBOSE
	#define USBHOSTAPI_VERBOSE 0
#endif

#ifndef INT32
 #define INT32 long
#endif
#ifndef UINT32
 #define UINT32 unsigned long
#endif

#if USBHOSTAPI_VERBOSE
	#ifdef NDEBUG
	  	#define USBHOST_ASSERT(ignore)
	#else
		#define USBHOST_ASSERT(exp)   \
   		 ((exp) ? (void)0 :        \
	    	_dc_assert(#exp, __FILE__, __LINE__))
   #endif
#else
	#ifdef NDEBUG
	  	#define USBHOST_ASSERT(ignore)
	#else
		#define USBHOST_ASSERT(exp)       \
   		 if(exp){ } else {             \
		   exception(-ERR_ASSERTFAILURE); \
		   exit(-ERR_ASSERTFAILURE); }
   #endif
#endif


#if USBHOSTAPI_VERBOSE
   // This will save save a lot of const space over more specific messages
   //  because the compiler will optimize all instances down to two
   //  strings, __FILE__ and "result !=0 File: %s,Line %d\n\n"
	#define USBAPI_PRINTF_ERR \
					printf("error code=%d File: %s,Line %d\n\n",errorCode?*errorCode:0,__FILE__, __LINE__)
#else
  	#define USBAPI_PRINTF_ERR
#endif

#use "USBHOSTAPI_DEFS.LIB"

/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
   usb_host_init   <USBHOSTAPI.LIB>

SYNTAX:  int usb_host_init(unsigned int devicePowerStableDelay,
                       unsigned long reservedParam, int * errorCode);
DESCRIPTION:
 This routine is called to initialize the USB host controller library. This
 initializes the host controller and starts a thread to handle USB requests.

PARAMETER1: DevicePowerStableDelay - After a device is connected to the
	root hub, the USB host stack internal thread waits the specified number
   of milliseconds before driving the bus to allow a bus powered device to
   be power stable.  The minimum delay is 100 milliseconds and the maximum
   delay is 2000 milliseconds.

PARAMETER2:
  Reserved. Set to zero

RETURN VALUE:
  0 - success
 -1 - failure

END DESCRIPTION **********************************************************/

/*** BeginHeader usb_host_init */
__xmem int usb_host_init(unsigned int devicePowerStableDelay,
                       unsigned int reservedParam, int * errorCode);

	extern unsigned int hub_status_change_sem_init;

/*** EndHeader */

unsigned int hub_status_change_sem_init;

//_usbhostapi_debug
__xmem int usb_host_init(unsigned int devicePowerStableDelay,
                  unsigned int reservedParam, int * errorCode)
{
    auto int j, result;
    auto unsigned int status;
#GLOBAL_INIT{/*usb_aligned_malloc_init=0;*/hub_status_change_sem_init=0;}

    result = 0;

    USBHOST_ASSERT(errorCode != NULL);

    // Check for NULL pointers
    if (errorCode == NULL)
    {
        if (errorCode != NULL)
            *errorCode = USBH_NULL_POINTER;
        result = -1;
        goto usbapiinitexit;
    }

    result = (int)usbOhciInit(NULL);
    if (result)
    {
            //"usb_host_init: usbOhciInit() failed\n"
            *errorCode = result;
            result = -1;
    			USBAPI_PRINTF_ERR;
            goto usbapiinitexit;
    }
    if (!hub_status_change_sem_init)
    {
  #if USBHOSTAPI_VERBOSE
        printf("usb_host_init create hub_status_change_sem \n");
  #endif
 		  hub_status_change_sem = OSSemCreate(1);

	     if( hub_status_change_sem==NULL )
  	     {
      		exception(USB_SEMAPHORE_ERROR);
		      exit(USB_SEMAPHORE_ERROR);
		  }
        hub_status_change_sem_init = 1;
    }
usbapiinitexit:
    return result;
}

/* START FUNCTION DESCRIPTION ********************************************
 usb_host_start(int * errorCode)         <USBHOSTAPI.LIB>

SYNTAX:  int usb_host_start();

DESCRIPTION:  This function starts the host controller specified by
	the controller handle returned by a previous successful call to
   usb_host_init();


RETURN VALUES:
	  0 - Success
	-USBH_NULL_POINTER
	-USBH_START_CONTROLLER_FAILED

END DESCRIPTION **********************************************************/
/*** BeginHeader usb_host_start */

__xmem int usb_host_start(int * errorCode) ;

/*** EndHeader */
//
// This function starts the host controller specified by the controller handle
// returned by a previous successfull call to usb_host_init()
//
_usbhostapi_debug
__xmem int usb_host_start(int * errorCode)
{
    auto int result;

    result = 0;

    USBHOST_ASSERT(errorCode != NULL);
    if (errorCode == NULL)
    {
        result = -1;
  		  USBAPI_PRINTF_ERR;
        *errorCode = USBH_NULL_POINTER;
//      "usb_host_start: NULL pointer\n"
        goto usbapihsexit;
    }

    // Start the OHCI controller
    result = usbOhciStartHcd();
    if (result)
    {
        *errorCode = -1;  //BPM - was USBH_START_CONTROLLER_FAILED;
  		  USBAPI_PRINTF_ERR;
//      "usb_host_start: usbOhciStartHcd() failed\n"
        goto usbapihsexit;
    }

usbapihsexit:
    return result;
}

/*** BeginHeader usb_host_enable_interrupts */

__xmem int usb_host_enable_interrupts() ;

/*** EndHeader */

_usbhostapi_debug
__xmem int usb_host_enable_interrupts()
{
   //Start the OHCI interrupts
   usbOhciEnableInterrupts();

    return 0;
}

/***************************************************************************
 * This function is used by the hub driver and the USB Host stack to
 * connect a new USB device.  The function just initializes the USB device
 * information.  It's the lower level driver that resets the port and does
 * the enumeration.  This function is not used by user applications.
 *
 * @param device  A pointer to the usbDevice structure registered for
 * the device.
 *
 * @param errorCode If this function fails (returns -1) the errorCode is filled
 * in with a number which represents the error which caused the failure.
 *
 * @return 0        Success
 * @return -1       Failure
 *
 * @see @link usbDevice
***************************************************************************/

/*** BeginHeader usb_connect_device */
__xmem int usb_connect_device(usbDevice __far * device, int * errorCode);
/*** EndHeader */
#define USB_DEFAULT_PACKET_LEN      64  // BPM 8
_usbhostapi_debug
__xmem int usb_connect_device(usbDevice __far * device, int * errorCode)
{
    auto int result;

    result=0;
	 USBHOST_ASSERT(device != NULL && errorCode != NULL);

    if (device == NULL || errorCode == NULL)
    {
       result = (-1);
       if (errorCode != NULL)
           *errorCode = USBH_NULL_POINTER;
       USBAPI_PRINTF_ERR;
       goto exit_usbcdfunction;
    }
    device->descriptor.bMaxPacketSize0 = USB_DEFAULT_PACKET_LEN;

exit_usbcdfunction:

    return result;
}

/*** BeginHeader usb_dump_device */
__xmem int usb_dump_device(usbDevice __far *device);
/*** EndHeader */
_usbhostapi_debug
__xmem int usb_dump_device(usbDevice __far *device)
{
	usbConfigDescriptor __far * cd;
	usbDeviceDescriptor __far * dd;
	usbInterfaceDescriptor __far * id;
	usbEndpointDescriptor __far * ed;
	word cdn;
	word idn;
	word edn;

	printf("\nDevice #%lu\n", device->devnum);
	printf("  Speed: %u = %s\n", device->Speed,
		device->Speed == 0 ? "full" : "low");
	printf("  maxpacketsize: %u = %u\n", device->maxpacketsize, 8 << device->maxpacketsize);
	printf("  parent_port: %u\n", device->parent_port);
	dd = &device->descriptor;
	printf("  bLength: %u\n", dd->bLength);
	printf("  bDescriptorType: %u\n", dd->bDescriptorType);
	printf("  bcdUSB: 0x%04X\n", dd->bcdUSB);
	printf("  bDeviceClass: %u\n", dd->bDeviceClass);
	printf("  bDeviceSubClass: %u\n", dd->bDeviceSubClass);
	printf("  bDeviceProtocol: %u\n", dd->bDeviceProtocol);
	printf("  bMaxPacketSize0: %u\n", dd->bMaxPacketSize0);
	printf("  idVendor: %u=0x%04X\n", dd->idVendor, dd->idVendor);
	printf("  idProduct: %u=0x%04X\n", dd->idProduct, dd->idProduct);
	printf("  bcdDevice: 0x%04X\n", dd->bcdDevice);
	printf("  iManufacturer: %u\n", dd->iManufacturer);
	printf("  iProduct: %u\n", dd->iProduct);
	printf("  iSerialNumber: %u\n", dd->iSerialNumber);
	printf("  bNumConfigurations: %u out of %u\n", dd->bNumConfigurations, USB_MAXCONFIG);

	for (cdn = 0; cdn < device->descriptor.bNumConfigurations; ++cdn) {
		cd = device->config + cdn;
		printf("  Config[%u]:\n", cdn);
		printf("    bLength: %u\n", cd->bLength);
		printf("    bDescriptorType: %u\n", cd->bDescriptorType);
		printf("    wTotalLength: %u\n", cd->wTotalLength);
		printf("    bNumInterfaces: %u out of %u\n", cd->bNumInterfaces, USB_MAXINTERFACES);
		printf("    bConfigurationValue: %u\n", cd->bConfigurationValue);
		printf("    iConfiguration: %u\n", cd->iConfiguration);
		printf("    bmAttributes: 0x%02X = %s %s\n", cd->bmAttributes,
			cd->bmAttributes & 0x40 ? "SelfPwrd" : "BusPwrd",
			cd->bmAttributes & 0x20 ? "RmtWakeup" : ""
			);
		printf("    MaxPower: %u mA\n", cd->MaxPower * 2u);
		for (idn = 0; idn < cd->bNumInterfaces; ++idn) {
			id = cd->interface + idn;
			printf("    Interface[%u]:\n", idn);
			printf("      bLength: %u\n", id->bLength);
			printf("      bDescriptorType: %u\n", id->bDescriptorType);
			printf("      bInterfaceNumber: %u\n", id->bInterfaceNumber);
			printf("      bAlternateSetting: %u\n", id->bAlternateSetting);
			printf("      bNumEndpoints: %u out of %u\n", id->bNumEndpoints, USB_MAXENDPOINTS);
			printf("      bInterfaceClass: %u = %s\n",
				id->bInterfaceClass,
				id->bInterfaceClass == 3 ? "HID" :
				"?");
			printf("      bInterfaceSubClass: %u\n", id->bInterfaceSubClass);
			printf("      bInterfaceProtocol: %u\n", id->bInterfaceProtocol);
			printf("      iInterface: %u\n", id->iInterface);
			for (edn = 0; edn < id->bNumEndpoints; ++edn) {
				ed = id->endpoint + edn;
				printf("      Endpoint[%u]:\n", edn);
				printf("        bLength: %u\n", ed->bLength);
				printf("        bDescriptorType: %u\n", ed->bDescriptorType);
				printf("        bEndpointAddress: 0x%02X = %s EP %u\n",
						ed->bEndpointAddress,
						ed->bEndpointAddress & 0x80 ? "output" : "input",
						ed->bEndpointAddress & 0x7F);
				printf("        bmAttributes: 0x%02X = %s\n",
						ed->bmAttributes,
						(ed->bmAttributes & 3) == 3 ? "interrupt" :
						(ed->bmAttributes & 3) == 2 ? "bulk" :
						(ed->bmAttributes & 3) == 1 ? "isoch" :
						"control"
						);
				printf("        wMaxPacketSize: %u\n", ed->wMaxPacketSize);
				printf("        bInterval: %u ms\n", ed->bInterval);

			}
		}
	}
}


/*** BeginHeader usb_probe_new_device, usb_driver_list */
__xmem int usb_probe_new_device(usbDevice __far *device, int *errorCode);
extern USB_LIST_ENTRY __far usb_driver_list;
/*** EndHeader */

USB_LIST_ENTRY __far usb_driver_list;

// This function is called for each new device attached to
// the USB bus.  The probe function of each registered USB
// device class driver is called to check determine if the
// new device is supported by one of the installed drivers.
//
_usbhostapi_debug
__xmem int usb_probe_new_device(usbDevice __far *device, int *errorCode)
{

    auto int result;
    auto USB_LIST_ENTRY __far *tmp;
    auto usbDriver  __far *driver;

#GLOBAL_INIT{
     usb_driver_list.next = &usb_driver_list;
     usb_driver_list.prev = &usb_driver_list;
}

    USBHOST_ASSERT(device != NULL);
    result = 0;
    tmp = usb_driver_list.next;


    // Check for NULL pointers
    if (device == NULL || errorCode == NULL)
    {
        result = -1;
        if (errorCode != NULL)
            *errorCode = USBH_NULL_POINTER;
        USBAPI_PRINTF_ERR;
        goto exit_pnd_function;
    }
    while (tmp != &usb_driver_list)
    {
        driver = list_entry(tmp, usbDriver, driver_list);
        tmp =  tmp->next;

        if (!driver->probe(device))
        {
            device->driver = driver;
            goto exit_pnd_function;
        }
    }
#if  USBHOSTAPI_VERBOSE
    // No driver recognized the device
    printf("usb_probe_new_device: Unknown new USB device:\n");
#endif

exit_pnd_function:

    return result;
}

/*************************************************************************
  This function is used by the hub driver and the USB Host stack to
  enumerate a new device that was added to the USB bus.  This function
  is not used by user applications.

  @param device  A pointer to the usbDevice structure registered for
  the device.

  @param errorCode If this function fails (returns -1) the errorCode is filled
  in with a number which represents the error which caused the failure.

  @return 0        Success
  @return -1       Failure

  @see @link usbDevice
*************************************************************************/
/*** BeginHeader usb_enumerate_device */
__xmem int usb_enumerate_device(usbDevice __far *device, int *errorCode);
/*** EndHeader */

#define USBAPI_GETCONFIG_BUFSIZE 255

_usbhostapi_debug
__xmem int usb_enumerate_device(usbDevice __far *device, int *errorCode)
{
	 auto char BB[USBAPI_GETCONFIG_BUFSIZE];
    auto char __far *buffer;
    auto long bytesTransferred;
    auto int result, i;
    auto devrequest request;

    buffer = NULL;
    result = 0;

    USBHOST_ASSERT(device != NULL && errorCode != NULL);

    if (device == NULL || errorCode == NULL)
    {
        result = -1;
        if (errorCode != NULL)
            *errorCode = USBH_NULL_POINTER;
        USBAPI_PRINTF_ERR;
        goto usbapiedexit;
    }
#if  USBHOSTAPI_VERBOSE
    printf("usb_enumerate_device: Assigned device number %d\n", (int)device->devnum);
#endif

    for (i = 0; i < 3; i++)
    {
        // When devices are attached to certain USB 2.0 hubs, the devices do not
        // respond to the SET ADDRESS device request, so we retry a few times
        if (usb_set_address(device, errorCode))
        {
#if  USBHOSTAPI_VERBOSE
            printf( "usb_enumerate_device: usb_set_address() failed\n");
#endif
//            tx_thread_sleep(NS_MILLISECONDS_TO_TICKS(10 << i));
            OSTimeDlyHMSM(0,0,0,10 << i);

        }
        else
        {
            break;
        }
    }
    if (i >= 3)
    {
        result = -1;
        USBAPI_PRINTF_ERR;
        goto usbapiedexit;
    }


   // Wait for the SET_ADDRESS command to complete
    OSTimeDlyHMSM(0,0,0,MIN_SLEEP_INTERVAL_MS);

    //SJH - use paddr to get physical addr
    buffer = (char __far *)paddr(BB);
    memset(BB, 0, USBAPI_GETCONFIG_BUFSIZE);

    // Get the device descriptor
    if (usb_set_getdescriptor_request(&request, USB_DT_DEVICE, 0,
                                      SIZEOF_DEVICE_DESCRIPTOR, errorCode))
    {
        result = -1;
        USBAPI_PRINTF_ERR;
        goto usbapiedexit;
    }

    if (usb_device_request(device, FALSE, &request, buffer,
        SIZEOF_DEVICE_DESCRIPTOR, &bytesTransferred,
        TX_WAIT_FOREVER, errorCode))
    {
        result = -1;
        // *errorCode = USBH_DEVICE_REQUEST_FAILED; //BPM:COIO
        USBAPI_PRINTF_ERR;
        goto usbapiedexit;
    }
//    OSTimeDlyHMSM(0,0,0,20);  //BPM seems to need to yield for low speed

// BPM Bytes WERE transfered! wassup?
// See note about ISR callback in usbOhciQueueGeneralRequest
    if(!bytesTransferred)
    {
        result = -1;
        *errorCode = USBH_DEVICE_REQUEST_FAILED;
        USBAPI_PRINTF_ERR;
        goto usbapiedexit;
    }
    else
    {
        if(bytesTransferred == SIZEOF_DEVICE_DESCRIPTOR )
        {
            _f_memcpy(&device->descriptor, buffer, sizeof(device->descriptor));
        }
        else
        {
           result = -1;
           *errorCode = USBH_DEVICE_REQUEST_FAILED;
           USBAPI_PRINTF_ERR;
           goto usbapiedexit;
        }
    }

    // Get configuration descriptor
    if (usb_get_configuration(device, errorCode))
    {
        result = -1;
        USBAPI_PRINTF_ERR;
        goto usbapiedexit;
    }

#if  USBHOSTAPI_VERBOSE
	 usb_dump_device(device);
#endif

    if (usb_probe_new_device(device, errorCode))
    {
        result = -1;
        USBAPI_PRINTF_ERR;
        goto usbapiedexit;
    }

usbapiedexit:
	/*
    if (buffer)
    {
        if (fsfree(buffer))
        {
            result = -1;
            USBAPI_PRINTF_ERR;
        }
    }
   */
    return result;
}

/***************************************************************************
  This routine requests the current device configuration value and updates
  the usbDevice structure. A zero value in the bConfigurationValue
  indicates an unconfigured device. The configuration descriptor in
  the usbDevice structure is updated with the new information.

  @param device  A pointer to the usbDevice structure registered for
  the device.

  @param errorCode If this function fails (returns -1) the errorCode is filled
  in with a number which represents the error which caused the failure.

  @return 0        Success
  @return -1       Failure

  @see @link usbDevice
****************************************************************************/

/*** BeginHeader usb_get_configuration */
__xmem int usb_get_configuration(usbDevice __far *device, int *errorCode);
/*** EndHeader */
_usbhostapi_debug
__xmem int usb_get_configuration(usbDevice __far * device, int * errorCode)
{
	 auto char BB[USBAPI_GETCONFIG_BUFSIZE];
    auto devrequest	request;
    auto int     		descriptor_size;
    auto long     		bytesTransferred;
    auto int       j, result;
    auto char __far 	*buffer;

    result = 0;
    buffer = NULL;

    USBHOST_ASSERT(device != NULL && errorCode != NULL);

    if (device == NULL || errorCode == NULL)
    {
        result = -1;
        if (errorCode != NULL)
            *errorCode = USBH_NULL_POINTER;
        USBAPI_PRINTF_ERR;
        goto usbapigcexit;
    }
    //SJH - use paddr to get physical addr
    buffer = (char __far *)paddr(BB);

    for (j = 0; j < device->descriptor.bNumConfigurations; j++)
    {
        memset(BB, 0, USBAPI_GETCONFIG_BUFSIZE);

        // Obtain the first 9 (guaranteed) bytes of the descriptor
        if (usb_set_getdescriptor_request(&request, USB_DT_CONFIG, j, 9, errorCode))
        {
            result = -1;
            USBAPI_PRINTF_ERR;
            goto usbapigcexit;
        }

        if (usb_device_request(device, FALSE, &request, buffer, 9,
            &bytesTransferred, TX_WAIT_FOREVER, errorCode))
        {
            result = -1;
            USBAPI_PRINTF_ERR;
            goto usbapigcexit;
        }

        // Decode data stream to find out the total bytes of descriptor data
        descriptor_size = USB_DESCRIPTOR_TOTAL_LEN(buffer);

        if ((word)descriptor_size > USBAPI_GETCONFIG_BUFSIZE)
            descriptor_size = USBAPI_GETCONFIG_BUFSIZE;

        _f_memset(buffer, 0, USBAPI_GETCONFIG_BUFSIZE);

        // Get the configuration descriptor
        if (usb_set_getdescriptor_request(&request, USB_DT_CONFIG, j,
                                          USBAPI_GETCONFIG_BUFSIZE, errorCode))
        {
            result = -1;
            USBAPI_PRINTF_ERR;
            goto usbapigcexit;
        }
        if (usb_device_request(device, FALSE, &request, buffer,
                               USBAPI_GETCONFIG_BUFSIZE, &bytesTransferred,
                               TX_WAIT_FOREVER, errorCode))
        {
            result = -1;
            USBAPI_PRINTF_ERR;
            goto usbapigcexit;
        }

        if(bytesTransferred <= 0)
        {
            result = -1;
            *errorCode = USBH_DEVICE_REQUEST_FAILED;
            USBAPI_PRINTF_ERR;
            goto usbapigcexit;
        }
        else
        {
#if  USBHOSTAPI_VERBOSE
				printf("Descriptor %d, len=%ld:\n", j, bytesTransferred);
				mem_dump(buffer, (word)bytesTransferred);
#endif
            //BPM  A kludge for a bug in the OPTION GTM378 (whatever that
            // is) was compile switched out in the original NS code here.

            if(bytesTransferred < descriptor_size ||
              bytesTransferred > USBAPI_GETCONFIG_BUFSIZE)
            {
               result = -1;
               *errorCode = USBH_DEVICE_REQUEST_FAILED;
#if  USBHOSTAPI_VERBOSE
               printf( "usb_get_configuration: receive byte count invalid, %d bytes received\n", bytesTransferred);
#endif
               goto usbapigcexit;
            }
            // just ignore the size since Windows always ignores it.
            // Vantive 24338 sends 41 bytes for their keypad.
            //
            else if((bytesTransferred != descriptor_size) &&
               (bytesTransferred != (descriptor_size + 1)) && // NS9xxx device mode driver sends extra byte if transfer size on 16 byte boundary for Windows compatibility
               (bytesTransferred != USBAPI_GETCONFIG_BUFSIZE))
            {
#if  USBHOSTAPI_VERBOSE
               // it's ok to get extra bytes
               printf("usb_get_configuration: %d bytes received(expected %d bytes); extra bytes will be ignored).\n", bytesTransferred, descriptor_size);
#endif
            }
        }
        if (usb_parse_configuration_descriptor(device, j, buffer, descriptor_size, errorCode))
        {
            result = -1;
            USBAPI_PRINTF_ERR;
            goto usbapigcexit;
        }
    }

usbapigcexit:
	/*
    if (buffer)
    {
        if (fsfree(buffer))
        {
            result = -1;
            *errorCode = USBH_FREE_FAILED;
            USBAPI_PRINTF_ERR;
        }
    }
   */
    return result;
}

/*** BeginHeader usb_parse_configuration_descriptor */
__xmem int usb_parse_configuration_descriptor(usbDevice __far *device, int cfg_index,
                                              void __far *buffer, int bytesInBuffer,
                                              int *errorCode);
#define INTERFACE_DESCR_LEN 9
/*** EndHeader */
//
// Parse the configuration data returned through a GET CONFIGURATION request
//
_usbhostapi_debug
__xmem int usb_parse_configuration_descriptor(usbDevice __far *device, int cfg_index,
                                              void __far *buffer, int bytesInBuffer,
                                              int *errorCode)
{
    auto int i, localBufferOffset, result, bufferOffset;
    auto usbConfigDescriptor __far *config;

    localBufferOffset = 0; result = 0; bufferOffset = 0;

    USBHOST_ASSERT(device != NULL && buffer != NULL && errorCode != NULL);

    // Check for NULL pointers
    if (device == NULL || buffer == NULL || errorCode == NULL)
    {
        result = -1;
        if (errorCode != NULL)
            *errorCode = USBH_NULL_POINTER;
        USBAPI_PRINTF_ERR;
        goto usbapipcdexit;
    }

    config = device->config + cfg_index;
#if  USBHOSTAPI_VERBOSE
	 printf("usb_parse_configuration_descriptor(%u): getting config descriptor...\n", cfg_index);
#endif
    if (usb_get_descriptor_offset((unsigned char __far *)buffer, bytesInBuffer,
                 USB_DT_CONFIG /*0x02*/, 9, &bufferOffset, errorCode))
    {
        result = -1;
        USBAPI_PRINTF_ERR;
        goto usbapipcdexit;
    }
    _f_memcpy(config, (unsigned char __far *)buffer + bufferOffset, 9);
    bytesInBuffer -= INTERFACE_DESCR_LEN;
    bufferOffset  += INTERFACE_DESCR_LEN;

    for (i = 0; i < config->bNumInterfaces; i++)
    {
        if (usb_parse_interface_descriptor(i, config->interface + i,
                                          (unsigned char __far *)buffer +
                                           bufferOffset, bytesInBuffer,
                                           &localBufferOffset, errorCode))
        {
            result = -1;
            USBAPI_PRINTF_ERR;
            goto usbapipcdexit;
        }
        bufferOffset += localBufferOffset;
        bytesInBuffer -= localBufferOffset;
    }

usbapipcdexit:

    return result;
}

/*** BeginHeader usb_parse_interface_descriptor */
__xmem  int usb_parse_interface_descriptor(word ifnum, usbInterfaceDescriptor __far *interface,
                                  unsigned char __far *buffer, int bytesInBuffer,
                                      int __far *bufferOffset, int *errorCode);
/*** EndHeader */
#define INTERFACE_DESCR_LEN 9
//
// Parse the interface descriptor data returned through a GET CONFIGURATION request
//
_usbhostapi_debug
__xmem int usb_parse_interface_descriptor(word ifnum, usbInterfaceDescriptor __far *interface,
                                          unsigned char __far *buffer, int bytesInBuffer,
                                          int __far *bufferOffset, int *errorCode)
{
    auto int i, result, localBufferOffset;
    auto unsigned short temp, temp1;

    result = 0;

    USBHOST_ASSERT(interface != NULL && buffer != NULL && bufferOffset != NULL && errorCode != NULL);

    // Check for NULL pointers
    if (interface == NULL || buffer == NULL || bufferOffset == NULL || errorCode == NULL)
    {
        result = -1;
        if (errorCode != NULL)
            *errorCode = USBH_NULL_POINTER;
        USBAPI_PRINTF_ERR;
        goto usbapipidexit;
    }
#if  USBHOSTAPI_VERBOSE
	 printf("usb_parse_interface_descriptor(%u): getting interface descriptor...\n", ifnum);
#endif
    if (usb_get_descriptor_offset(buffer, bytesInBuffer, USB_DT_INTERFACE /*0x04*/,
                              INTERFACE_DESCR_LEN /*0x09*/, bufferOffset, errorCode))
    {
        result = -1;
        USBAPI_PRINTF_ERR;
        goto usbapipidexit;
    }
    _f_memcpy(interface, buffer + (*bufferOffset), INTERFACE_DESCR_LEN);
    bytesInBuffer -= INTERFACE_DESCR_LEN;
    *bufferOffset += INTERFACE_DESCR_LEN;

    for (i = 0; i < interface->bNumEndpoints; i++)
    {
        temp = (unsigned int)(unsigned char __far *)(buffer + (*bufferOffset));
        temp1 = ((USB_DT_HID << 8) | INTERFACE_DESCR_LEN);
        if(temp == temp1)
        {
            *bufferOffset  += INTERFACE_DESCR_LEN;    // skip HID descriptor... TBD: handle HID descriptor???
            bytesInBuffer -= INTERFACE_DESCR_LEN;
        }

        if (usb_parse_endpoint_descriptor(i, interface->endpoint + i,
		        buffer + (*bufferOffset), bytesInBuffer,
		        &localBufferOffset, errorCode))
        {
            result = -1;
            USBAPI_PRINTF_ERR;
            goto usbapipidexit;
        }
        *bufferOffset += localBufferOffset;
        bytesInBuffer -= localBufferOffset;
    }

usbapipidexit:

    return result;
}


/*** BeginHeader usb_parse_endpoint_descriptor */
__xmem  int usb_parse_endpoint_descriptor(word epnum, usbEndpointDescriptor __far *endpoint,
		unsigned char __far *buffer, int bytesInBuffer, int __far *bufferOffset,
      int *errorCode);
/*** EndHeader */
#define USB_ENDPOINT_DESCR_LEN 7
//
// Parse the endpoint descriptor data returned through a GET CONFIGURATION request
//
_usbhostapi_debug
__xmem int usb_parse_endpoint_descriptor(word epnum, usbEndpointDescriptor __far *endpoint,
	   	unsigned char __far *buffer, int bytesInBuffer, int __far *bufferOffset,
         int *errorCode)
{
    int result;
    result = 0;

    USBHOST_ASSERT(endpoint != NULL && buffer != NULL &&
                  bufferOffset != NULL && errorCode != NULL);

    // Check for NULL pointers
    if (    endpoint == NULL || buffer == NULL ||
        bufferOffset == NULL || errorCode == NULL
       )
    {
        result = -1;
        if (errorCode != NULL)
            *errorCode = USBH_NULL_POINTER;
        USBAPI_PRINTF_ERR;
        goto usbapipedexit;
    }

#if  USBHOSTAPI_VERBOSE
	 printf("usb_parse_endpoint_descriptor(%u): getting endpoint descriptor...\n", epnum);
#endif
    if (usb_get_descriptor_offset(buffer, bytesInBuffer, USB_DT_ENDPOINT /*0x05*/,
                   USB_ENDPOINT_DESCR_LEN /*0x07*/, bufferOffset, errorCode))
    {
        result = -1;
        USBAPI_PRINTF_ERR;
        goto usbapipedexit;
    }

    _f_memcpy(endpoint, buffer + (*bufferOffset), USB_ENDPOINT_DESCR_LEN);
    *bufferOffset += USB_ENDPOINT_DESCR_LEN;

usbapipedexit:

    return result;
}


/*** BeginHeader usb_get_descriptor_offset */
__xmem int usb_get_descriptor_offset(unsigned char __far *buffer, int bytesInBuffer,
                                     unsigned char descrType,
                                     unsigned char descrLen,
                                     int __far * bufferOffset, int *errorCode);
/*** EndHeader */
//
// Parse the USB configuration data, and build the attached device database.
//
_usbhostapi_debug
__xmem int usb_get_descriptor_offset(unsigned char __far *buffer, int bytesInBuffer,
                                     unsigned char descrType,
                                     unsigned char descrLen,
                                     int __far * bufferOffset, int *errorCode)
{
    auto unsigned short  n_desc;
    auto int n_len, i, result;

    result=0;

    USBHOST_ASSERT(buffer != NULL && bufferOffset != NULL && errorCode != NULL);

    // Check for NULL pointers
    if (buffer == NULL || bufferOffset == NULL || errorCode == NULL)
    {
        result = -1;
        if (errorCode != NULL)
            *errorCode = USBH_NULL_POINTER;
        USBAPI_PRINTF_ERR;
        goto usbapigdoexit;
    }

    *bufferOffset = 0; // initialize variable
    while(1)
    {
        if (bytesInBuffer < descrLen)
        {
            result = -1;
            *errorCode = USBH_INVALID_CONFIGURATION_DATA;
            USBAPI_PRINTF_ERR;
            goto usbapigdoexit;
        }

        _f_memcpy(&n_desc, buffer, sizeof(unsigned short));

        if ( (USB_DESCRIPTOR_LEN(buffer) ==  descrLen) && (USB_DESCRIPTOR_TYPE(buffer) == descrType) )
        {
#if USBHOSTAPI_VERBOSE
        		printf("usb_get_descriptor_offset: found %02x/%02x at offset %u, len %u\n",
            	(n_desc>>8) & 0xFF, n_desc & 0xFF, *bufferOffset, USB_DESCRIPTOR_LEN(buffer));
#endif
            goto usbapigdoexit;
        }

        n_len = USB_DESCRIPTOR_LEN(buffer);

        if (n_len < 2 || n_len > bytesInBuffer)
        {
            result = -1;
            *errorCode = USBH_INVALID_CONFIGURATION_DATA;
            USBAPI_PRINTF_ERR;
            goto usbapigdoexit;
        }

        bytesInBuffer -= n_len;
        buffer += n_len;
        *bufferOffset += n_len;
    }

usbapigdoexit:

    return result;
}


/* START FUNCTION DESCRIPTION ********************************************
   usb_device_request     <USBHOSTAPI.LIB>

SYNTAX:  int usb_device_request(usbDevice far * device, int outputIO,
                   devrequest far * request, unsigned char far * buffer,
                   long bytesToTransfer, long far * bytesTransferred,
                   int timeout);

DESCRIPTION:  This routine sends a device request to the device. All the
	API functions that perform device requests call this function. Device
   requests that are not supported by the USB Host API must be implemented
   by the user. User-implemented device request functions must call this
   function. Refer to the device class drivers source code for examples on
   how to implement device requests.

PARAMETER1:
	device -  A pointer to the usbDevice structure registered for the device.
PARAMETER2:
	outputIO - Set to TRUE if the device request writes to the device.
	Set to FALSE if the device request reads from the device.
PARAMETER3:
	request - The pointer to the devrequest structure that contains the
	device request data.
PARAMETER4:
	The pointer to the buffer that stores read/write data.
PARAMETER5:
	bytesToTransfer  The number of bytes to transfer.
PARAMETER6:
	bytesTransferred  The pointer to the variable that stores the actual
	number of bytes transferred.
PARAMETER7:
	timeout - The timeout period (in system clock ticks) to wait for the
	device request to complete.

RETURN VALUE:
	0 - Success
  -1 - Failure

END DESCRIPTION **********************************************************/


/*** BeginHeader usb_device_request */
__xmem int usb_device_request(usbDevice __far * device, int outputIO,
                        devrequest __far * request, unsigned char __far * buffer,
                        long bytesToTransfer, long __far * bytesTransferred,
                        int timeout, int * errorCode);
/*** EndHeader */

_usbhostapi_debug
__xmem int usb_device_request(usbDevice __far * device, int outputIO,
                        devrequest __far * request, unsigned char __far * buffer,
                        long bytesToTransfer, long __far * bytesTransferred,
                        int timeout, int * errorCode)
{
    int             result;
    unsigned long   pipe_info;

    result = 0;

    //SJH Added this because TX_WAIT_FOREVER is zero, but zero means non-blocking!
    // Since this function does not support non-blocking, change to "long" timeout
    // of about 1/2 sec.
    if (!timeout)
    	timeout = 500;

    // The buffer and bytesTransferred arguments can be NULL
    USBHOST_ASSERT(device != NULL && request != NULL && errorCode != NULL);

    if (device == NULL || request == NULL || errorCode == NULL)
    {
        result = -1;
        if (errorCode != NULL)
            *errorCode = USBH_NULL_POINTER;
        USBAPI_PRINTF_ERR;
        goto usbapidrexit;
    }

    if(!outputIO)
        pipe_info = USB_RECIEVE_CTRL_PIPE(device, 0UL);
    else
        pipe_info = USB_SEND_CTRL_PIPE(device, 0UL);
#if USBHOSTAPI_VERBOSE > 2
	 printf("usb_device_request: calling QGR pipe=0x%08lX...\n", pipe_info);
#endif
    result = usbOhciQueueGeneralRequest(device, pipe_info, request, buffer,
                     bytesToTransfer, bytesTransferred, timeout,
                             (USB_CALLBACK)NULL);
#if USBHOSTAPI_VERBOSE > 2
	 printf("usb_device_request: ...result=%d\n", result);
#endif
    if (result)
    {
        *errorCode = result;
        result = -1;
        USBAPI_PRINTF_ERR;
        //"usb_device_request: usbOhciQueueGeneralRequest() failed\n"
    }
usbapidrexit:

    return result;
}


//
// These are the actual routines to send
// and receive control messages.
//
/*** BeginHeader usb_set_getdescriptor_request */
__xmem int usb_set_getdescriptor_request(devrequest * request,
               unsigned char type, unsigned char descriptor_index,
               short int bytesToTransfer, int * errorCode);

int usb_set_address(usbDevice __far *device, int *errorCode);

/*** EndHeader */

_usbhostapi_debug
__xmem int usb_set_getdescriptor_request(devrequest * request,
               unsigned char descr_type, unsigned char descr_index,
               short int bytesToTransfer, int * errorCode)
{
    auto int result;

    result = 0;

    USBHOST_ASSERT(request != NULL && errorCode != NULL);

    if (request == NULL || errorCode == NULL)
    {
        result = (-1);
        if (errorCode != NULL)
            *errorCode = USBH_NULL_POINTER;
        USBAPI_PRINTF_ERR;
        goto usbpisgdrexit;
    }

    FORMAT_USB_DEVICE_REQUEST(
                request,                          // Request pointer
                USB_DEVICE_TO_HOST_REQ,           //  Request Type
                USB_REQ_GET_DESCRIPTOR,           //  Request
                MAKE16(descr_type, descr_index),  //  Value (type/index = hi/lo)
                0,                                //  Index
                bytesToTransfer);                 //  Length

usbpisgdrexit:

    return result;
}

_usbhostapi_debug
__xmem int usb_set_address(usbDevice __far *device, int *errorCode)
{
    devrequest request;
    auto int result;

    result = 0;

    USBHOST_ASSERT(device != NULL && errorCode != NULL);

    // check for NULL pointers
    if (device == NULL || errorCode == NULL)
    {
       result = (-1);
       if (errorCode != NULL)
           *errorCode = USBH_NULL_POINTER;
       USBAPI_PRINTF_ERR;
       goto usbapisaexit;
    }

    FORMAT_USB_DEVICE_REQUEST(
                &request,             // Request pointer
                0,                    //   Request Type
                USB_REQ_SET_ADDRESS,  //   Request
                device->devnum,       //   Value
                0,                    //   Index
                0);                   //   Length

#if USBHOSTAPI_VERBOSE
    printf("usb_set_address: address %d\n", (int)device->devnum);
#endif

    result = usbOhciQueueGeneralRequest(device, USB_SEND_DEFAULT_CTRL(device),
                                            &request, NULL, 0, NULL,
                                            TX_WAIT_FOREVER,
                                            (USB_CALLBACK)NULL);
    if (result)
    {
        *errorCode = result;
        result = -1;
        USBAPI_PRINTF_ERR;
    }
usbapisaexit:

    return result;
}



/*************************************************************************
 * This function is used by the hub driver and the USB Host stack to
 * confirm that a new device was added to the USB bus.  This function
 * is not used by user applications.
 *
 * @param device  A pointer to the usbDevice structure registered for
 * the device.
 *
 * @param errorCode If this function fails (returns -1) the errorCode is filled
 * in with a number which represents the error which caused the failure.
 *
 * @return 0        Success
 * @return -1       Failure
 *
 * @see @link usbDevice
***************************************************************************/

/*** BeginHeader usb_check_new_device */

__xmem int usb_check_new_device(usbDevice __far * device, int * errorCode);
#define GET_DEVICE_DESCRIPTOR_RETRIES 3

/*** EndHeader */

_usbhostapi_debug
__xmem int usb_check_new_device(usbDevice __far * device, int * errorCode)
{
    // When this function is called, the device has been assigned a
    //  new device address. The function gets the device descriptor to
    //  confirm that the new device is working.

	 auto char BB[64];
    auto int i, result;
    auto long bytesTransferred;
    auto devrequest request;
    char __far * buffer;


    result = 0;
    buffer = NULL;

    USBHOST_ASSERT(device != NULL && errorCode != NULL);

    if (device == NULL || errorCode == NULL)
    {
        result = -1;
        if (errorCode != NULL)
            *errorCode = USBH_NULL_POINTER;
        USBAPI_PRINTF_ERR;
        goto usbapicndexit;
    }

	device->maxpacketsize = 0;  // Default to 8 byte max packet size

    if (usb_set_getdescriptor_request(&request, USB_DT_DEVICE, 0, 8, errorCode))
    {
        result = -1;
        USBAPI_PRINTF_ERR;
        goto usbapicndexit;
    }

    buffer = (char __far *)paddr(BB);
    memset(BB, 0, 8);

    for (i = 0; i < GET_DEVICE_DESCRIPTOR_RETRIES; i++)
    {
        if (!usb_device_request(device, FALSE, &request,
                   (char __far *)buffer, 8, &bytesTransferred,
                   TX_WAIT_FOREVER, errorCode))
        {
            break;
        }
        OSTimeDlyHMSM(0,0,0,MIN_SLEEP_INTERVAL_MS);

#if USBHOSTAPI_VERBOSE
        USBAPI_PRINTF_ERR;
	     //"usb_check_new_device: usb_device_request() failed\n"
#endif
    }
    if (i >= GET_DEVICE_DESCRIPTOR_RETRIES)
    {
        result = -1;
        USBAPI_PRINTF_ERR;
        goto usbapicndexit;
    }

    _f_memcpy(&device->descriptor, buffer, 8);

#if USBHOSTAPI_VERBOSE
    printf("usb_check_new_device: maxpacketsize: %d\n", device->descriptor.bMaxPacketSize0);
#endif
    switch (device->descriptor.bMaxPacketSize0)
    {
        default: //8
            device->maxpacketsize = 0;
            break;
        case 16:
            device->maxpacketsize = 1;
            break;
        case 32:
            device->maxpacketsize = 2;
            break;
        case 64:
            device->maxpacketsize = 3;
            break;
    }

usbapicndexit:
	/*
    if (buffer)
    {
        if (fsfree(buffer))
        {
            result = -1;
            *errorCode = USBH_FREE_FAILED;
            USBAPI_PRINTF_ERR;
        }
    }
	*/
    return result;
}

/*********************************************************************
 This function is used by the hub driver and USB Host driver to relinquish
 the device number of a USB device that was disconnected. The USB device
 number is stored in the devnum member of the usbDevice structure.
 This function is not used by user applications.

  @param device        A pointer to the usbDevice structure registered for
                       the device.
  @param errorCode     A pointer to an integer to return the error code.

  @return 0        Success
  @return -1       Failure

  @see @link usbDevice
**********************************************************************/

/*** BeginHeader usb_put_device_number */
__xmem int usb_put_device_number(usbDevice __far * device, int * errorCode);
/*** EndHeader */

_usbhostapi_debug
__xmem int usb_put_device_number(usbDevice __far * device, int * errorCode)
{
    int result;
    char * usb_device_number_table;

    //return 0;  //BPM

    usb_device_number_table = NULL;
    result = 0;

//    USBHOST_ASSERT(device != NULL && errorCode != NULL);
    if(device == NULL || errorCode == NULL)
    {
        result = -1;
        USBAPI_PRINTF_ERR;
        goto usbapipdnexit;
    }

    usb_device_number_table = device_number_table;


    // Original code checked for FIRST_USB_DEVICE_NUMBER instead of 0.
    // If the enumeration process didn't past the initial get descriptor
    // request, device->devnum is 0 when the device is disconnected. If
    // this occurs, we don't treat this as an error
    if ( (device->devnum < 0) || (device->devnum > (MAX_USB_DEVICES - 1)))
    {
        result = -1;
        *errorCode = USBH_INVALID_DEVICE_NUMBER;
        USBAPI_PRINTF_ERR;
        goto usbapipdnexit;
    }

    // device number corresponding to table index is not used
    if(usb_device_number_table[(int)device->devnum])
    {
        usb_device_number_table[(int)device->devnum] = 0;
    }

    // If the usb_device_number_table[] array entry is 0, this means that
    // the enumeration process failed, so we don't treat this as an error
    // otherwise, when the device that failed to enumerate is unplugged,
    // the corresponding endpoint descriptors are not deallocated by the
    // USB Host (OHCI) driver
#if 0
    else
    {
        result = -1;
        *errorCode = USBH_DEVICE_NUMBER_NOT_USED;
        USBAPI_PRINTF_ERR;
    }
#endif

usbapipdnexit:

    return result;
}

/****************************************************************************
 This function is used by the hub driver and USB Host driver to assign
 a device number to a USB device that was connected.  The USB device
 number is stored in the devnum member of the usbDevice structure. This
 function is not used by user applications.

  @param device        A pointer to the usbDevice structure registered for
                       the device.
  @param errorCode     A pointer to an integer to return the error code.

  @return 0        Success
  @return -1       Failure

***************************************************************************/
/*** BeginHeader usb_get_device_number */

__xmem int usb_get_device_number(usbDevice __far * device, int * errorCode);

/*** EndHeader */

_usbhostapi_debug
__xmem int usb_get_device_number(usbDevice __far * device, int * errorCode)
{
    int result, j;
    char * usb_device_number_table;


    usb_device_number_table = NULL;
    result = 0;

 //   return 0;  //BPM

    USBHOST_ASSERT(device != NULL && errorCode != NULL);

    if (device == NULL || errorCode == NULL)
    {
        result = -1;
        if (errorCode != NULL)
            *errorCode = USBH_NULL_POINTER;
        USBAPI_PRINTF_ERR;
        goto usbapigdnexit;
    }

   usb_device_number_table = device_number_table;

    for (j = FIRST_USB_DEVICE_NUMBER; j < MAX_USB_DEVICES; j++)
    {
        if (!usb_device_number_table[j])
        {
            device->devnum = j;

				// device number corresponding to table index is used
            usb_device_number_table[(int)device->devnum] = 1;
            break;
        }
    }

    if (j >= MAX_USB_DEVICES)
    {
        result = -1;
        *errorCode = USBH_MAX_DEVICES;
        USBAPI_PRINTF_ERR;
//        goto usbapigdnexit; // there already
    }
usbapigdnexit:

    return result;
}

//
// Something got disconnected. Get rid of it, and all of its children.
//
/*** BeginHeader usb_disconnect_device */

__xmem int usb_disconnect_device(UINT32 pdevice32, int * errorCode);

/*** EndHeader */

_usbhostapi_debug
__xmem int usb_disconnect_device(UINT32 pdevice32, int *errorCode)
{
    auto int result;
    auto usbDevice __far *device;
//    auto usbDevice far ** child;
    auto __far struct usbDevice_t *__far* pdevice;
    auto __far struct usbDevice_t *__far* child;

    int i, error_code;

    //return 0;  //BPM

    result = 0;

    pdevice = (__far struct usbDevice_t *__far* )pdevice32;

    if (pdevice == 0UL || errorCode == NULL)
    {
        result = -1;
        if (errorCode != NULL)
            *errorCode = USBH_NULL_POINTER;
        USBAPI_PRINTF_ERR;
        goto usbapiddexit;
    }
    device = *pdevice;
    if (device)
    {
        *pdevice = 0UL;

#if USBHOSTAPI_VERBOSE
        printf("usb_disconnect_device: USB device %d disconnected\n",
                   device->devnum);
#endif
        if(device->driver)
            device->driver->disconnect(device);

        if (usb_put_device_number(device, &error_code))
        {
            result = -1;
            USBAPI_PRINTF_ERR;
            goto usbapiddexit;
        }
        // Free up all the children...
//  Lots of problems with this code, ignore hub children devices for now

        for (i = 0; i < USB_MAXCHILDREN; i++)
        {
//            *child = device->children + i;
            //BPM recursion alert!
            if (usb_disconnect_device((UINT32)(device->children + i), &error_code))
            {
                result = -1;
                USBAPI_PRINTF_ERR;
                goto usbapiddexit;
            }
        }
//*/
        result = usbOhciUsbDeallocate(device);
        if (result)
        {
            *errorCode = result;
            result = -1;
            USBAPI_PRINTF_ERR;
            goto usbapiddexit;
        }
    }

usbapiddexit:

    return result;
}

/* START FUNCTION DESCRIPTION ********************************************
   usb_register           <USBHOSTAPI.LIB>

SYNTAX: int usb_register(const usbDriver * driver);

DESCRIPTION:  This routine is called to initialize the USB driver with the
	USB core. The new_driver argument points to a completely initialized
   usbDriver (see link below) structure. On success this function
   returns 0; otherwise, it returns an error value. The USB core then adds
   the specified driver to its internal linked list of drivers. The
   usbDriver structure contains the entry points for the registered driver.

	The first step in setting up a USB device driver is to register your
   device driver with the USB core by calling this routine. USB device
   drivers are registered and deregistered with the USB subsystem. A
   driver must register 2 entry points and its name.

	The "probe" routine specified in the new_driver structure is called
   whenever new devices attach to the USB.  It is then up to the USB
	driver that called this routine to make subsequest USB calls to send
   and receive data to the device.

PARAMETER:
	driver - A pointer to the usbDeriver structure passed into this routine.

RETURN VALUE:
	 0 - Success
   -1 - failure

SEE ALSO:
 usbDriver, usb_deregister

END DESCRIPTION **********************************************************/

/*** BeginHeader usb_register */
__xmem int usb_register(const usbDriver * driver, int * errorCode);
/*** EndHeader */

_usbhostapi_debug
__xmem int usb_register(const usbDriver * driver, int * errorCode)
{
    auto int result;

    result = 0;

    USBHOST_ASSERT(driver != NULL && errorCode != NULL);

    // Check for NULL pointers
    if (driver == NULL || errorCode == NULL)
    {
        result = -1;
        if (errorCode != NULL)
            *errorCode = USBH_NULL_POINTER;
        USBAPI_PRINTF_ERR;
        //"usb_register: NULL pointer\n");
    }
    else
    {
        // TBD: check for duplicate drivers

        // Add the new driver pointer to the list of known drivers
        InsertHeadList(&usb_driver_list, &driver->driver_list);
    }
    return result;
}

/* START FUNCTION DESCRIPTION ********************************************
   usb_deregister        <USBHOSTAPI.LIB>

SYNTAX:  int usb_deregister(usbDriver * driver);

DESCRIPTION:  This routine is called to remove the USB driver with the
	USB core. The argument driver points to the usbDriver (see link below)
	structure that was passed to the usbRegister routine.

PARAMETER: driver - A pointer to the usbDriver passed to the
	usbRegister routine.

RETURN VALUE:
	 0 - Success
   -1 - Failure

END DESCRIPTION **********************************************************/

/*** BeginHeader usb_deregister */
	__xmem int usb_deregister(usbDriver * driver, int * errorCode);
/*** EndHeader */

_usbhostapi_debug
__xmem int usb_deregister(usbDriver * driver, int * errorCode)
{
    auto int result;

    result = 0;
    USBHOST_ASSERT(driver != NULL && errorCode != NULL);

    // Check for NULL pointers
    if (driver == NULL || errorCode == NULL)
    {
        result = -1;
        if (errorCode != NULL)
        {
            *errorCode = USBH_NULL_POINTER;
        }
        USBAPI_PRINTF_ERR;
        //"usb_deregister: NULL pointer\n"
    }
    else
    {
        // TDB: check for existing pointer
        RemoveEntryList(&driver->driver_list);
    }
    return result;
}

/* START FUNCTION DESCRIPTION ********************************************
  usb_bulk_transfer    <USBHOSTAPI.LIB>

SYNTAX: int usb_bulk_transfer(usbDevice far * device, long output_io,
             long endpoint, char far * buffer, long bytesToTransfer,
             long far * bytesTransferred, long maxPacketSize, int timeout,
             int * errorCode);

DESCRIPTION:  This routine is called to perform a bulk data transfer.

PARAMETER1:
	device  - A pointer to the usbDevice structure registered for the device.
PARAMETER2:
	output_io - The direction of the data transfer. TRUE for bulk OUT and
   				 FALSE for bulk IN.
PARAMETER3:
	endpoint - Endpoint number to send data to.
PARAMETER4:
	buffer - Pointer to the buffer containing the data to be sent.
PARAMETER5:
	bytesToTransfer - The number of bytes to transfer.
PARAMETER6:
	bytesTransferred - A pointer to an integer that stores the actual
   number of bytes transferred.
PARAMETER7:
	maxPacketSize - The maximum packet size for the endpoint.
PARAMETER8:
	timeout  - The number of ticks to wait for the data transfer to complete.

RETURN VALUE:
	 0 -  Success
	-1 - Failure

END DESCRIPTION **********************************************************/

/*** BeginHeader usb_bulk_transfer */
__xmem int usb_bulk_transfer(usbDevice __far * device, long output_io,
       long endpoint, char __far * buffer, long bytesToTransfer,
       long __far * bytesTransferred, long maxPacketSize, int timeout,
       int * errorCode);
/*** EndHeader */

_usbhostapi_debug
__xmem int usb_bulk_transfer(usbDevice __far * device, long output_io,
       long endpoint, char __far * buffer, long bytesToTransfer,
       long __far * bytesTransferred, long maxPacketSize, int timeout,
       int * errorCode)
{
    auto unsigned long pipeInfo;
    auto int result;

    result = 0;

    USBHOST_ASSERT(device != NULL && buffer != NULL &&
           bytesTransferred != NULL && errorCode != NULL);

    // check for NULL pointers
    if (device == NULL || buffer == NULL ||
        bytesTransferred == NULL || errorCode == NULL)
    {
       result = -1;
       if (errorCode != NULL)
       {
           *errorCode = USBH_NULL_POINTER;
       }
       USBAPI_PRINTF_ERR;
       //"usb_bulk_transfer: NULL pointer\n"
       goto usbapibtexit;
    }

    // check that direction and endpoint MSB are consistent
    if (!output_io)
    {
       if (!(endpoint & 0x80))
       {
           result = -1;
           *errorCode = USBH_ENDPOINT_INCONSISTENT;
           USBAPI_PRINTF_ERR;
           //"usb_bulk_transfer: endpoint inconsistent\n"
           goto usbapibtexit;
       }
    }
    else
    {
       if (endpoint & 0x80)
       {
           result = (-1);
           *errorCode = USBH_ENDPOINT_INCONSISTENT;
           USBAPI_PRINTF_ERR;
           // "usb_bulk_transfer: endpoint inconsistent\n"
           goto usbapibtexit;
       }
    }

    // check for valid max packet size and convert to pipe info bits
    switch((int)maxPacketSize)
    {
        case 8:
           maxPacketSize = 0;
           break;
        case 16:
           maxPacketSize = 1;
           break;
        case 32:
           maxPacketSize = 2;
           break;
        case 64:
           maxPacketSize = 3;
           break;
       case 512:
           // For high speed devices the max packet size must be 512
           // it doesn't matter what we set here
           maxPacketSize = 3;
           break;
        default:
           result = -1;
           *errorCode = USBH_INVALID_PACKET_SIZE;
           USBAPI_PRINTF_ERR;
           // "usb_bulk_transfer: invalid packet size\n"
           goto usbapibtexit;
    }

    // The 32-bit pipeinfo variable stores the characteristics of the transfer.
    // The different bits of the variable store the following information:
    //
    // device:       bits 8-14
    // endpoint:     bits 15-18
    // data 0/1:     bit 19
    // direction:    bit 7       (0 = Host to Device, 1 = Device to Host)
    // speed:        bit 26-27   (0 = Full, 1 = Low Speed, 2 = High)
    // max size:     bits 0-1    (00 = 8, 01 = 16, 10 = 32, 11 = 64)
    // pipe type:    bits 30-31  (00 = isochronous, 01 = interrupt, 10 = control, 11 = bulk)
    pipeInfo = (USB_PIPE_TYPE_BULK<<30) | (device->devnum<<8) |
               ((endpoint & 0x7f) << 15) |
               ((unsigned long)device->Speed << 26) |
                maxPacketSize | (endpoint & 0x80);

    if (output_io)
        pipeInfo &= ~(0x1 << 7);
    else
        pipeInfo |= 0x1 << 7;

    result = usbOhciQueueGeneralRequest(device, pipeInfo, NULL, buffer,
                                bytesToTransfer, bytesTransferred,
//                                timeout, (USB_CALLBACK)usbOhciGeneralRequestCallback);
                                timeout, (USB_CALLBACK)NULL);
    if(result)
    {
        // transfer error occurred
        if(result == USBH_STALL)
        {
            // Let user call usb_clear_endpoint_feature(), but keep code for reference - JW
            ;;// usb_clear_endpoint_feature(dev, endpoint, USB_FEATURE_ENDPOINT_HALT);
        }
        *errorCode = result;
        result = -1;
        if (*errorCode == USBH_TIMEOUT && timeout != TX_WAIT_FOREVER)
        {
             // Some drivers use a timeout value versus "wait forever".
             // For those drivers, spewing the CRITICAL trace message
             // for each timeout is not proper, since that event is
             // expected (not critical). Use INFO level instead.
             //
             USBAPI_PRINTF_ERR;
             //"usb_bulk_transfer: usbOhciQueueGeneralRequest() timeout \n"
        }
        else
        {
            USBAPI_PRINTF_ERR;
            //"usb_bulk_transfer: usbOhciQueueGeneralRequest() failed \n"
        }
        goto usbapibtexit;
    }

usbapibtexit:
    return result;
}

/* START FUNCTION DESCRIPTION ********************************************
  usb_get_string           <USBHOSTAPI.LIB>

SYNTAX:  int usb_get_string(usbDevice far * device, unsigned short langId,
            char descr_index, void far * buffer, long bytesToTransfer,
            long  * bytesTransferred)

DESCRIPTION:  If a device, configuration, or interface descriptor
	references a string index value, you can use this function to retrieve
	the string descriptor. According to the specification, USB strings are
   coded as Unicode.

PARAMETER1:
	device  - A pointer to the usbDevice structure registered for
	the device.
PARAMETER2:
	langId  - Language identifier for the string.
PARAMETER3:
	descr_index -  The descriptor index for the device request.
PARAMETER4:
	buffer -  Pointer to a buffer to be filled in with the string.
PARAMETER5:
	bytesToTransfer -  Number of bytes in the buffer pointed to by buf.
PARAMETER6:
	bytesTransferred -  Pointer to an integer to be filled in with the
   number of bytes in the string.

RETURN VALUE:
	 0 - Success
   -1 - Failure

END DESCRIPTION **********************************************************/

/*********************************************************************
 * @return 0        Success
 * @return -1       Failure
 *
 * @see @link usbDevice
*****************************************************************/
/*** BeginHeader usb_get_string */
__xmem int usb_get_string(usbDevice __far * device, unsigned short langId,
            unsigned char descr_index, void __far * buffer,
            long bytesToTransfer, long * bytesTransferred,
            int * errorCode);
/*** EndHeader */

_usbhostapi_debug
__xmem int usb_get_string(usbDevice __far * device, unsigned short langId,
            char descr_index, void __far * buffer,
            long bytesToTransfer, long  * bytesTransferred,
            int * errorCode)
{
    auto int result;
    auto devrequest request;

    result = 0;

    USBHOST_ASSERT(device != NULL && buffer != NULL &&
            bytesTransferred != NULL && errorCode != NULL);

    if (device == NULL || buffer == NULL || bytesTransferred == NULL ||
         errorCode == NULL)
    {
        result = -1;
        if (errorCode != NULL)
        {
            *errorCode = USBH_NULL_POINTER;
        }
        USBAPI_PRINTF_ERR;
        //"usb_get_string: NULL pointer\n"
        goto usbapigsexit;
    }

    FORMAT_USB_DEVICE_REQUEST(
                &request,                           // Request pointer
                USB_DEVICE_TO_HOST_REQ,             //      Request Type
                USB_REQ_GET_DESCRIPTOR,             //      Request
                MAKE16(USB_DT_STRING, descr_index), //      Value (type/index = hi/lo)
                langId,                             //      Index
                bytesToTransfer);                   //      Length

#if USBHOSTAPI_VERBOSE
//BPM:COIO    printf(
//      "usb_get_string: idx=%d langId= %081x buffer=%08lx bytesToTransfer= %d\n",
//       descr_index, langId, (int)buffer, bytesToTransfer);
#endif
    if (usb_device_request(device, FALSE, &request, buffer,
           bytesToTransfer, bytesTransferred,
           TX_WAIT_FOREVER, errorCode))
    {
        result = -1;
        USBAPI_PRINTF_ERR;
        //"usb_get_string: usb_device_request() failed\n"
    }

usbapigsexit:

    return result;
}

/* START FUNCTION DESCRIPTION ********************************************
  usb_get_device_descriptor        <USBHOSTAPI.LIB>

SYNTAX:  int usb_get_device_descriptor(usbDevice * device,
             long far * bytesTransferred);

DESCRIPTION:  This routine rereads the complete descriptor tree from a
	particular device. It is called automatically whenever a device is
   attached to the bus, or it may be called whenever a USB descriptor has
   changed. It fills in the descriptor field in the usbDevice structure.

PARAMETER1:
	device -  A pointer to the usbDevice structure registered for the device.
PARAMETER2:
	bytesTransferred -  The number of bytes read from the device.

RETURN VALUE:
	0 - Success
  -1 - Failure

END DESCRIPTION **********************************************************/

/*** BeginHeader usb_get_device_descriptor */
__xmem int usb_get_device_descriptor(usbDevice * device,
             long __far * bytesTransferred, int * errorCode);
/*** EndHeader */
_usbhostapi_debug
__xmem int usb_get_device_descriptor(usbDevice * device,
             long __far * bytesTransferred, int * errorCode)
{
    devrequest request;
    int result;

    result = 0;

    USBHOST_ASSERT(device != NULL && bytesTransferred != NULL
                 && errorCode != NULL);

    if (device == NULL || bytesTransferred == NULL || errorCode == NULL)
    {
        result = -1;
        if (errorCode != NULL)
        {
            *errorCode = USBH_NULL_POINTER;
        }
        USBAPI_PRINTF_ERR;
        // "usb_get_device_descriptor: NULL pointer\n"
        goto usbapigdescexit;
    }

    if (usb_set_getdescriptor_request(
       &request, USB_DT_DEVICE, 0, sizeof(device->descriptor), errorCode))
    {
        result = (-1);
        USBAPI_PRINTF_ERR;
        //"usb_get_device_descriptor: usb_set_getdescriptor_request() failed\n"
        goto usbapigdescexit;
    }

    if (usb_device_request(device, FALSE, &request,
            (unsigned char __far *)&device->descriptor,
             sizeof(device->descriptor), bytesTransferred,
             TX_WAIT_FOREVER, errorCode))
    {
        result = -1;
        USBAPI_PRINTF_ERR;
        //"usb_get_device_descriptor: usb_device_request() failed\n"
    }

usbapigdescexit:

    return result;
}

/* START FUNCTION DESCRIPTION ********************************************
  usb_get_status        <USBHOSTAPI.LIB>

SYNTAX: int usb_get_status(usbDevice far * device, void far * buffer);

DESCRIPTION:  This routine requests status from the specified recipient; this
  appears as a GET_STATUS on the bus. It is called automatically whenever
  a device is attached to the bus, or it may be called whenever a USB
  descriptor has changed.


PARAMETER1:
	device -  A pointer to the usbDevice structure registered for the device.
PARAMETER2:
	buffer -  Pointer to the output buffer containing the USB status
	request structure.

RETURN VALUE:
	0 - Success
  -1 - Failure

END DESCRIPTION **********************************************************/

/*** BeginHeader usb_get_status */
__xmem int usb_get_status(usbDevice __far * device, void __far * buffer,
          int * errorCode);
/*** EndHeader */
_usbhostapi_debug
__xmem int usb_get_status(usbDevice __far * device, void __far * buffer,
          int * errorCode)
{
    auto int result;
    auto long bytesTransferred;
    auto devrequest request;

    result = 0;

    USBHOST_ASSERT(device != NULL && buffer != NULL && errorCode != NULL);

    if (device == NULL || buffer == NULL || errorCode == NULL)
    {
        result = -1;
        *errorCode = USBH_NULL_POINTER;
        USBAPI_PRINTF_ERR;
        //"usb_get_status: NULL pointer\n"
        goto usbapigsexit;
    }

    FORMAT_USB_DEVICE_REQUEST(
                &request,                   // Request pointer
                USB_DEVICE_TO_HOST_REQ,     //      Request Type
                USB_REQ_GET_STATUS,         //      Request
                0,                          //      Value
                0,                          //      Index
                2);                         //      Length

//    if (usb_device_request(device, FALSE, &request, buffer, 4, &bytesTransferred, TX_WAIT_FOREVER, errorCode))
    if (usb_device_request(device, FALSE, &request, buffer, 2, &bytesTransferred, TX_WAIT_FOREVER, errorCode))
    {
        result = -1;
        USBAPI_PRINTF_ERR;
        //"usb_get_status: usb_deice_request() failed\n"
    }

usbapigsexit:

    return result;
}
/* START FUNCTION DESCRIPTION ********************************************
  usb_clear_feature        <USBHOSTAPI.LIB>

SYNTAX:  int usb_clear_feature(usbDevice far * device, short int feature);

DESCRIPTION:  This routine requests status from the specified recipient.

PARAMETER1:
	device -  A pointer to the usbDevice structure registered for the device.
PARAMETER2:
	feature -  Number of the feature to clear.

RETURN VALUE:
	0 - Success
  -1 - Failure

END DESCRIPTION **********************************************************/

/*** BeginHeader usb_clear_feature */
__xmem int usb_clear_feature(usbDevice __far * device, short int feature,
                           int * errorCode);
/*** EndHeader */
_usbhostapi_debug
__xmem int usb_clear_feature(usbDevice __far * device, short int feature,
                           int * errorCode)
{
    int result;
    devrequest request;

    result = 0;

    USBHOST_ASSERT(device != NULL && errorCode != NULL);

    if (device == NULL || errorCode == NULL)
    {
        result = -1;
        if (errorCode == NULL)
        {
            *errorCode = USBH_NULL_POINTER;
        }
        USBAPI_PRINTF_ERR;
        //"usb_clear_feature: NULL pointer\n"
        goto usbapicfexit;
    }

    FORMAT_USB_DEVICE_REQUEST(
                &request,                       // Request pointer
                USB_RT_DEVICE,                  //      Request Type
                USB_REQ_CLEAR_FEATURE,          //      Request
                feature,                        //      Value
                0,                              //      Index
                0);                             //      Length


    if (usb_device_request(device, TRUE, &request, NULL, 0, NULL,
    								TX_WAIT_FOREVER, errorCode))
    {
        result = -1;
        USBAPI_PRINTF_ERR;
        //"usb_clear_feature: usb_device_request() failed\n"
    }

usbapicfexit:

    return result;
}

/* START FUNCTION DESCRIPTION ********************************************
  usb_set_feature        <USBHOSTAPI.LIB>

SYNTAX:  int usb_set_feature(usbDevice far * device, int feature);

DESCRIPTION:  This routine sends a set feature command to the
	specified usbDevice.

PARAMETER1:
	device -  A pointer to the usbDevice structure registered for the device.
PARAMETER2:
	feature -  Number of the feature to set.

RETURN VALUE:
	0 - Success
  -1 - Failure

END DESCRIPTION **********************************************************/

/*** BeginHeader usb_set_feature */
__xmem int usb_set_feature(usbDevice __far * device, short int feature,
            int * errorCode);
/*** EndHeader */
_usbhostapi_debug
__xmem int usb_set_feature(usbDevice __far * device, short int feature,
            int * errorCode)
{
    int result;
    devrequest request;

    result = 0;

    USBHOST_ASSERT(device != NULL && errorCode != NULL);

    if (device == NULL || errorCode == NULL)
    {
        result = -1;
        if (errorCode != NULL)
        {
            *errorCode = USBH_NULL_POINTER;
        }
        USBAPI_PRINTF_ERR;
        //"usb_set_feature: NULL pointer\n"
        goto usbapisfexit;
    }

    FORMAT_USB_DEVICE_REQUEST(
                &request,                   // Request pointer
                USB_RT_DEVICE,              //      Request Type
                USB_REQ_SET_FEATURE,        //      Request
                feature,                    //      Value
                0,                          //      Index
                0);                         //      Length


    if (usb_device_request(device, TRUE, &request, NULL, 0, NULL, TX_WAIT_FOREVER, errorCode))
    {
        result = -1;
        USBAPI_PRINTF_ERR;
        //"usb_set_feature: usb_device_request() failed\n");
    }

usbapisfexit:

    return result;
}


/* START FUNCTION DESCRIPTION ********************************************
  usb_clear_endpoint_feature        <USBHOSTAPI.LIB>

SYNTAX:  int usb_clear_endpoint_feature(usbDevice far * dev,  int endpoint,
              int feature);

DESCRIPTION: This routine sends a clear endpoint feature command to the
	specified usbDevice.

PARAMETER1:
	device -  A pointer to the usbDevice structure registered for the device.
PARAMETER2:
	endpoint -  endpoint Number of the endpoint.
PARAMETER3:
	feature -  Number of the feature to clear.

RETURN VALUE:
	0 - Success
  -1 - Failure

END DESCRIPTION **********************************************************/

/*** BeginHeader usb_clear_endpoint_feature */
__xmem int usb_clear_endpoint_feature(usbDevice __far * dev, short int endpoint,
              short int feature, int * errorCode);
/*** EndHeader */
_usbhostapi_debug
__xmem int usb_clear_endpoint_feature(usbDevice __far * dev, short int endpoint,
              short int feature, int * errorCode)
{
    int result;
    devrequest request;

    result = 0;

    USBHOST_ASSERT(dev != NULL && errorCode != NULL);

    if (dev == NULL || errorCode == NULL)
    {
        result = -1;
        if (errorCode != NULL)
        {
            *errorCode = USBH_NULL_POINTER;
        }
        USBAPI_PRINTF_ERR;
        //"usb_clear_endpoint_feature: NULL pointer\n"
        goto usbapicefexit;
    }

    FORMAT_USB_DEVICE_REQUEST(
                &request,                       // Request pointer
                USB_RECIP_ENDPOINT,             //      Request Type
                USB_REQ_CLEAR_FEATURE,          //      Request
                feature,                        //      Value
                endpoint,                       //      Index
                0);                             //      Length

    if (usb_device_request(dev, TRUE, &request, NULL, 0, NULL,
    									TX_WAIT_FOREVER, errorCode))
    {
        result = -1;
        USBAPI_PRINTF_ERR;
        //"usb_clear_endpoint_feature: usb_device_request() failed\n"
    }

usbapicefexit:

    return result;
}

/* START FUNCTION DESCRIPTION ********************************************
  usb_set_configuration        <USBHOSTAPI.LIB>

SYNTAX:  int usb_set_configuration(usbDevice far * device, int configuration);

DESCRIPTION:  This routine is called to activate a particular configuration.
	Configuration 0 is selected by default after the device is attached
	to the bus.

PARAMETER1:
	device -  A pointer to the usbDevice structure registered for the device.
PARAMETER2:
	configuration -  0 <= configuration < device->descriptor.bNumConfigurations.

RETURN VALUE:
	0 - Success
  -1 - Failure

END DESCRIPTION **********************************************************/

/*** BeginHeader usb_set_configuration */
__xmem int usb_set_configuration(usbDevice __far * device,
                   short int configuration, int * errorCode);
/*** EndHeader */
_usbhostapi_debug
__xmem int usb_set_configuration(usbDevice __far * device,
                   short int configuration, int * errorCode)
{
    int result;
    devrequest request;

    result = 0;

    USBHOST_ASSERT(device != NULL && errorCode != NULL);

    if (device == NULL || errorCode == NULL)
    {
        result = -1;
        if (errorCode != NULL){
            *errorCode = USBH_NULL_POINTER;
		  }
        USBAPI_PRINTF_ERR;
        //"usb_set_configuration: NULL pointer\n"
        goto usbapiscexit;
    }

    FORMAT_USB_DEVICE_REQUEST(
                &request,                           // Request pointer
                USB_RT_DEVICE,                      //      Request Type
                USB_REQ_SET_CONFIGURATION,          //      Request
                configuration,                      //      Value
                0,                                  //      Index
                0);                                 //      Length

    if (usb_device_request(device, TRUE, &request, NULL, 0, NULL,
                         TX_WAIT_FOREVER, errorCode))
    {
        result = -1;
        USBAPI_PRINTF_ERR;
        //"usb_set_configuration: usb_device_request() failed\n"
    }

usbapiscexit:

    return result;
}

/* START FUNCTION DESCRIPTION ********************************************
  usb_set_interface        <USBHOSTAPI.LIB>

SYNTAX:  int usb_set_interface(usbDevice far * device, int interface,
             int alternative, int * errorCode);

DESCRIPTION:  This routine is called to enable a particular interface
	and select its alternative setting.

PARAMETER1:
	device -  A pointer to the usbDevice structure registered for the device.
PARAMETER2:
	interface -  The interface number.
	0 <= interface <= (device->config[x].bNumInterfaces - 1)
PARAMETER3:
	alternative  The interface's alternative setting number.

RETURN VALUE:
	0 - Success
  -1 - Failure

END DESCRIPTION **********************************************************/

/*** BeginHeader usb_set_interface */
__xmem int usb_set_interface(usbDevice __far * device, short int interface,
             short int alternative, int * errorCode);
/*** EndHeader */

_usbhostapi_debug
__xmem int usb_set_interface(usbDevice __far * device, short int interface,
             short int alternative, int * errorCode)
{
    int result;
    devrequest request;

    result = 0;

    USBHOST_ASSERT(device != NULL && errorCode != NULL);

    if (device == NULL || errorCode == NULL)
    {
        result = -1;
        if (errorCode != NULL)
        {
            *errorCode = USBH_NULL_POINTER;
        }
        USBAPI_PRINTF_ERR;
        //"usb_set_interface: NULL pointer\n"
        goto usbapisiexit;
    }


    FORMAT_USB_DEVICE_REQUEST(
                &request,                       // Request pointer
                USB_RECIP_INTERFACE,            //      Request Type
                USB_REQ_SET_INTERFACE,          //      Request
                alternative,                    //      Value
                interface,                      //      Index
                0);                             //      Length

    if (usb_device_request(device, TRUE, &request, NULL, 0, NULL,
                 TX_WAIT_FOREVER, errorCode))
    {
        result = -1;
        USBAPI_PRINTF_ERR;
        //"usb_set_interface: usb_device_request() failed\n"
    }

usbapisiexit:
    return result;
}

/* START FUNCTION DESCRIPTION ********************************************
  usb_request_interrupt_transfer      <USBHOSTAPI.LIB>

SYNTAX:  int usb_request_interrupt_transfer(usbDevice far * device,
               unsigned long pipe, usbDeviceIrq handler, int period,
               void * device_id, int maxpacketsize,
               void far * buffer, int * errorCode);

DESCRIPTION:  This routine is called to request an ISR when interrupt
	data is received from a USB device. The data received and the size
   is passed to the handler routine.

PARAMETER1:
	device -  A pointer to the usbDevice structure registered for the device.
PARAMETER2:
	pipe  -   The pipe that you are receiving data for.
PARAMETER3:
	handler -  Function pointer to the routine that is called when data arrives.
PARAMETER4:
	period  -  How often to call your device.
PARAMETER5:
	device_id -  A pointer that is passed to the handler routine. This is
	intended for the caller's use.
PARAMETER6:
	maxpacketsize -  The maximum size of data that the device can receive.
PARAMETER7:
	buffer -  A pointer to the buffer to place the received data.

RETURN VALUE:
	0 - Success
  -1 - Failure

END DESCRIPTION **********************************************************/

/*** BeginHeader usb_request_interrupt_transfer */
__xmem int usb_request_interrupt_transfer(usbDevice __far * device,
               unsigned long pipe, usbDeviceIrq handler, int period,
                        void * device_id, int maxpacketsize,
                        void __far * buffer, int * errorCode);
/*** EndHeader */

_usbhostapi_debug
__xmem int usb_request_interrupt_transfer(usbDevice __far * device,
               unsigned long pipe, usbDeviceIrq handler, int period,
                        void * device_id, int maxpacketsize,
                        void __far * buffer, int * errorCode)
{
    int result;

    result = 0;

    USBHOST_ASSERT(device != NULL && handler != NULL && device_id != NULL &&
                buffer != NULL && errorCode != NULL);

    if (device == NULL || handler == NULL || device_id == NULL ||
            buffer == NULL || errorCode == NULL)
    {
        result = -1;
        if (errorCode != NULL)
        {
            *errorCode = USBH_NULL_POINTER;
        }
        USBAPI_PRINTF_ERR;
        //"usb_request_interrupt_transfer: NULL pointer\n"
        goto usbapiritexit;
    }


    result = usbOhciInsertInterruptEndpoint(device, pipe, handler, period,
                          device_id, maxpacketsize, buffer);
    if (result)
    {
        *errorCode = result;
        result = -1;
        USBAPI_PRINTF_ERR;
        //"usb_request_interrupt_transfer: usbOhciInsertInterruptEndpoint() failed\n"
    }

usbapiritexit:

    return result;
}

/***************************************************************
 * This function is used by the hub driver and the USB Host stack
 * to allocate a child device for a hub device.  This function is
 * not used by user applications.
 *
 * @external
 * @category USBH
 * @since 6.1
 *
 * @param parentDevice  A pointer to the usbDevice parent structure for which a
 *                      child device will be allocated.
 * @param childDevice   A double pointer to return the address of the usbDevice child
 *                      structure to be allocated.
 * @param errorCode     A pointer to an integer to return the error code.
 *
 * @return 0        Success
 * @return -1       Failure
 *
 * @see @link usbDevice
****************************************************************/
/*** BeginHeader usb_allocate_child_device */

__xmem int usb_allocate_child_device(usbDevice __far * parentDevice,
                usbDevice __far ** childDevice, int * errorCode);

/*** EndHeader */

_usbhostapi_debug
__xmem int usb_allocate_child_device(usbDevice __far * parentDevice,
                usbDevice __far ** childDevice, int * errorCode)
{
    int result;

    result = 0;

    USBHOST_ASSERT(parentDevice != NULL && childDevice != NULL &&
           errorCode != NULL);

    if (parentDevice == NULL || childDevice == NULL || errorCode == NULL)
    {
        result = -1;
        if (errorCode != NULL)
        {
            *errorCode = USBH_NULL_POINTER;
        }
        USBAPI_PRINTF_ERR;
        //"usb_allocate_child_device: NULL pointer\n"
        goto usbapiacdexit;
    }

    result = usbOhciUsbAllocate(parentDevice, childDevice);
    if (result)
    {
        *errorCode = result;
        result = -1;
        USBAPI_PRINTF_ERR;
        //"usb_allocate_child_device: usbOhciUsbAllocate() failed\n"
    }
usbapiacdexit:

    return result;
}

/*** BeginHeader  */
#endif
/*** EndHeader */



