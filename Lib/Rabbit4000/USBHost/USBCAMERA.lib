/*****************************************************************************
* Copyright (c) 2006 Digi International Inc., All Rights Reserved
*
* This software contains proprietary and confidential information of Digi
* International Inc.  By accepting transfer of this copy, Recipient agrees
* to retain this software in confidence, to prevent disclosure to others,
* and to make no use of this software other than that for which it was
* delivered.  This is an unpublished copyrighted work of Digi International
* Inc.  Except as permitted by federal law, 17 USC 117, copying is strictly
* prohibited.
*
* Restricted Rights Legend
*
* Use, duplication, or disclosure by the Government is subject to
* restrictions set forth in sub-paragraph (c)(1)(ii) of The Rights in
* Technical Data and Computer Software clause at DFARS 252.227-7031 or
* subparagraphs (c)(1) and (2) of the Commercial Computer Software -
* Restricted Rights at 48 CFR 52.227-19, as applicable.
*
* Digi International Inc. 11001 Bren Road East, Minnetonka, MN 55343
*
*****************************************************************************/
/*** BeginHeader */
#ifndef _USBCAMERA_H
#define _USBCAMERA_H

#ifdef USBCAMERA_DEBUG
	#define  USBCamDebug __debug
#else
	#define  USBCamDebug __nodebug
#endif

#ifndef USBCAMERA_VERBOSE
	#define USBCAMERA_VERBOSE 0
#endif

// This will save save a lot of const space over more specific messages
//  because the compiler will optimize all instances down to two
//  strings, __FILE__ and "result !=0 File: %s,Line %d\n\n"
#if USBCAMERA_VERBOSE
	#define USBCAMERA_PRINTF_ERR printf("File: %s,Line %d\n", __FILE__,  __LINE__)
#else
  	#define USBCAMERA_PRINTF_ERR
#endif

//#include "tx_api.h"
//#include <usbHostApi.h>
//#include "vicam3.h"
//#include "VicamApi.h"


// from vista code
#define     VCIF_READ                   0x0001
#define     VCIF_WRITE                  0x0002

#define     VCIF_TRANSFER_ERROR         0x1001
#define     VCIF_TRANSFER_NOT_BUSY      0x1002
#define     VCIF_TRANSFER_CANCELED      0x1003

#define     VCIF_FIRMWARE_DOWNLOADED    0x1010

#define     VC3_CMD_FIRMWARE_DOWNLOAD       0xF0
#define     VC3_RESET_DELAY                 1000

// other defines
#define USB_CAMERA_VENDOR_ID 0x1608
#define USB_CAMERA_PRODUCT_ID_4001 0x4001
#define USB_CAMERA_PRODUCT_ID_4011 0x4011
#define USB_CAMERA_PRODUCT_ID_4006 0x4006
#define USB_CAMERA_PRODUCT_ID_4016 0x4016
#define USB_CAMERA_PRODUCT_ID_4007 0x4007
#define USB_CAMERA_PRODUCT_ID_4017 0x4017

#define USB_ENDPOINT_DIR_MASK		0x80
#define USB_DIR_IN			0x80

#define USB_CAMERA_DEV_NAME_FORMAT "/dev/usb/camera%d"
#define MAX_IMAGE_UPDATE_LISTENERS 1	//SJH - only 1 supported for Rabbit

#define MAX_CAMERA_DESC_LEN 32

// max number of cameras supported in the driver
#define USB_CAMERA_MAX 1


typedef struct usbCameraStats
{
    // number of frames successfully read from camera
    unsigned long frames[2];	// 64-bit number
    // aggregate frame size count in KB
    unsigned long framesKB[2];// 64-bit number
    // dropped frames
    unsigned long droppedFrames;
    // largest successful frame
    unsigned long largestFrame;
    // smallest successful frame (non zero)
    unsigned long smallestFrame;

} USB_CAMERA_STATS;


// Message format:
// command 4 bytes (dword aligned)
// data 4 bytes (dword aligned): content is command specific.
typedef enum {
    MSG_START_INVALID = 0,
    // Just a marker to delimit the bottom of valid commands
    MSG_SET_RESOLUTION,
    // data is the new resolution of type VI_CTRL_RESOLUTION_VALUES
    MSG_SET_FRAME_RATE,
    // data is new frame rate.  See VI_CTRL_FRAME_RATE
    MSG_DIE,
    // no data, terminate thread immediately
    MSG_END_INVALID
    // Just a marker to delimit the top of valid commands
} CAMERA_MSG_COMMAND;

typedef int CAMERA_MSG_DATA;

typedef struct camera_msg_struct {
    CAMERA_MSG_COMMAND cmd;
    CAMERA_MSG_DATA data;
} CAMERA_MSG;

#define CAMERA_MSGQ_DEPTH 50
#define CAMERA_MSGQ_MSG_SIZE (sizeof(CAMERA_MSG_COMMAND))
/*SJH
typedef struct cameraMsgQ_struct {
    char name[MAX_CAMERA_DESC_LEN];
    // len is CAMERA_MSGQ_DEPTH * CAMERA_MSGQ_MSG_SIZE * 4
    int qBufferLen;
    int qBuffer[CAMERA_MSGQ_DEPTH * CAMERA_MSGQ_MSG_SIZE];
    TX_QUEUE txQ;
} CAMERA_MSGQ;
*/

typedef struct usb_camera
{
    usbDevice  __far *usbDev;
    int             bulkInEp;
    int             bulkInMaxPacketSize;
    int             devnum;
    int             drvnum;
    char            name[MAX_CAMERA_DESC_LEN];
    USB_LIST_ENTRY  list;
    int             number;
    unsigned short  idProduct;
    char deviceIdString[MAX_CAMERA_DESC_LEN];
    char serNumString[MAX_CAMERA_DESC_LEN];

    // these are from vc3_dev_data
    char            fOpen;          // open flag
    //TX_MUTEX        genLock;
    char            genLockName[MAX_CAMERA_DESC_LEN];
    int             disconnected;
    // small buffer used for usb bulk reads
    char __far *      bulkTransferBuffer;
    // full image buffer used to assemble full image from usb reads
    // not for external consumption (use output buffer below)
    char __far *      imageCaptureBuffer;
    // size of imageCaptureBuffer
    unsigned long   captureBufferSize;
    // size of capture based on chosen capture type, will be max of
    // captureBufferSize
    unsigned long   captureSize;

    // following used by camera_interface.cc
    // cached image buffer
    char __far *      outputBuffer;
    unsigned long   outputBufferLen;
    // image info for image in outputBuffer
    //SJH   VC_IMAGE_INFO  imageInfo;

    // Camera stats
    USB_CAMERA_STATS __far *stats;

    // message Q for update thread
    //SJH   CAMERA_MSGQ far *msgQ;

    int updateThreadRunning;

    // used by update thread to wait between image grabs
    unsigned long pauseTicks;

    // callbacks for image updates
    void (*imageUpdateListeners[MAX_IMAGE_UPDATE_LISTENERS])(/*struct usb_camera far *vc3*/);

    //SJH  PVC_DATA         vcData;

    // Index in settings that this instance uses for its settings.
    // TODO, resolve this and set it correctly
    // (currently just leaving it initialized to zero for single camera instance)
    int settingsIndex;

    // hold the current WatchportCameraSettings.  Using int * for type for now since
    // the C code can't handle the C++ object
    int __far *curSettings;
} USB_CAMERA;


typedef enum {
    CAMER_NOOP,
    CAMERA_CONNECT,
    CAMERA_DISCONNECT,
    CAMERA_OPEN,
    CAMERA_CLOSE
} USB_CAMERA_EVENT;

typedef void (*UsbCameraEvent_fn)(/*USB_CAMERA far *vc3, USB_CAMERA_EVENT newEvent*/);



#define     CALC_GAMMA_TABLE                0

// this turns off the ability to locally decompress.  Use this to reduce the
// memory usage of this driver (as well as the foot print).
#define DISABLE_LOCAL_DECOMPRESS 1

#use    "wpv4011.lib"  // Watchport/V2 without microphone
//#use   "wpv4012.lib"  // Watchport/V2 with microphone
//#use	"wpv4015.lib"	// Watchport/VE Video Encoder - not implemented yet
//#use	"wpv4016.lib"  // Watchport/V3 RoHS Camera without microphone
//#use	"wpv4017.lib"  // Watchport/V3 Sensible Vision Camera without microphone

#define     VC3_CMD_FIRMWARE_DOWNLOAD       0xF0
#define     VC3_RESET_DELAY                 1000

#define     DBG_CAPTURE_BUFFERS             0
#define     DBG_GET_IMAGE_DATA              0

#define		USB_CONTROL_TIMEOUT_SECS		5
#define		USB_BULKIN_TIMEOUT_SECS			10

#define     CAPTURE_BUFFER_UNUSED           0
#define     CAPTURE_BUFFER_WRITING          1
#define     CAPTURE_BUFFER_READY            2
#define     CAPTURE_BUFFER_PROCESSING       3

#define     VC3_FIRMWARE_BLOCK_SIZE         1024

#define     VC_STREAM_STOPPED               0
#define     VC_STREAM_RUNNING               1

// orig #define     BULK_IN_TRANSFER_SIZE (32*1024)
//#define     BULK_IN_TRANSFER_SIZE (8*1024)
#define     BULK_IN_TRANSFER_SIZE (2*1024)

#define     VC3_TIMEOUT         ( 15 * BSP_TICKS_PER_SECOND)

#define VC_NO_ERROR 0	//SJH - this is a guess, no define in original code!
#define VC_ERROR (-1)	//SJH - this is a guess, no define in original code!

/*** EndHeader */

/*** BeginHeader cameraList, usbCameraEventListeners, cameraInsertCount,
		 globalUsbCameraLock */

#define USB_CAMERA_PROBE_BUFFER_SIZE 160
#define MAX_USB_CAMERA_EVENT_LISTENERS 20

extern USB_CAMERA __far *cameraList[USB_CAMERA_MAX];
extern UsbCameraEvent_fn usbCameraEventListeners[MAX_USB_CAMERA_EVENT_LISTENERS];
extern int cameraInsertCount;
extern TX_SEMAPHORE globalUsbCameraLock;
/*** EndHeader */

// note, we are not using the USB LIST most NetOS devices use because:
// 1) it's not thread safe (it only uses protection on insert)
// 2) it turns off all interrupts during insert which is way overkill
USB_CAMERA __far *cameraList[USB_CAMERA_MAX];

// A monotonically increasing count of usb cameras that have been attached.
// Note, this is not necessarily how many entries are in cameraList since cameras
// can be removed.
int cameraInsertCount;

TX_SEMAPHORE globalUsbCameraLock;
//char * globalUsbCameraLockName = "USB Camera Lock (global)";

UsbCameraEvent_fn usbCameraEventListeners[MAX_USB_CAMERA_EVENT_LISTENERS];

/*** BeginHeader init_camera_list */
void init_camera_list(void);
/*** EndHeader */
USBCamDebug
void init_camera_list(void) {
    int i;
	#GLOBAL_INIT { cameraInsertCount = 0; }
    for(i = 0; i < USB_CAMERA_MAX; ++i) {
        cameraList[i] = NULL;
    }
}

/*** BeginHeader list_add_camera */
int list_add_camera(USB_CAMERA __far *camera, int __far *count);
/*** EndHeader */
//adds camera to list and returns 0 if successful, neg if error
// fills in *count with a monotonically increasing count of cameras (zero based)
USBCamDebug
int list_add_camera(USB_CAMERA __far *camera, int __far *count) {
    int i;
    int added;
    int rc;

	 added = 0;
	 rc = -1;

    getGlobalCameraLock();

    for(i = 0; i < USB_CAMERA_MAX; ++i) {
        if(cameraList[i] == NULL) {
            cameraList[i] = camera;
            *count = cameraInsertCount++;
            added = 1;
            break;
        }
    }
    if(added == 0) {
        printf("list_add_camera: Maximum cameras attached.  Can't add new camera\n");
        rc = -1;
    } else {
        rc = 0;
    }

    putGlobalCameraLock();

    return rc;
}

/*** BeginHeader list_delete_camera */
int list_delete_camera(USB_CAMERA __far *camera);
/*** EndHeader */
USBCamDebug
int list_delete_camera(USB_CAMERA __far *camera) {
    int i;
    int deletedIndex;
    int rc;

	 deletedIndex = -1;
	 rc = -1;

    getGlobalCameraLock();

    for(i = 0; i < USB_CAMERA_MAX; ++i) {
        if(cameraList[i] == camera) {
            cameraList[i] = NULL;
            deletedIndex = i;
        }
    }

    if(deletedIndex == -1) {
        printf("list_delete_camera: Camera not found during delete from list\n");
        rc = -1;
    } else {
        rc = 0;

        // now fix up list
        for(i = deletedIndex + 1; i < USB_CAMERA_MAX; ++i) {
            cameraList[i - 1] = cameraList[i];
        }
    }

    putGlobalCameraLock();

    return rc;
}

/*** BeginHeader list_count_camera */
int list_count_camera(void);
/*** EndHeader */
USBCamDebug
int list_count_camera(void) {
    int count;
    int i;

	 count = 0;

    getGlobalCameraLock();

    for(i = 0; i < USB_CAMERA_MAX; ++i) {
        if(cameraList[i] != NULL) {
            count++;
        } else {
            break;
        }
    }

    putGlobalCameraLock();

    return count;
}

/*** BeginHeader list_camera_exist */
int list_camera_exist(USB_CAMERA __far *vc3);
/*** EndHeader */
// Return 0 if this camera is not currently connected
// Return non-zero if it is connected.
USBCamDebug
int list_camera_exist(USB_CAMERA __far *vc3) {

    int ret;
    int i;

	 ret = 0;

    getGlobalCameraLock();

    for(i = 0; i < USB_CAMERA_MAX; ++i) {
        if(cameraList[i] == vc3) {
            ret = 1;
            break;
        }
    }

    putGlobalCameraLock();

    return ret;
}

/*** BeginHeader list_get_camera_at */
USB_CAMERA __far *list_get_camera_at(int listIndex);
/*** EndHeader */
// Put the usb camera collection in a zero-based ordered list and return the instance at location index.
// Position is meaningless and ephemeral (ie. instances can get rearranged unless
// one holds the global lock during successive calls).
USBCamDebug
USB_CAMERA __far *list_get_camera_at(int listIndex) {

    USB_CAMERA __far *ret;

    if((listIndex < 0) || (listIndex >= USB_CAMERA_MAX)) {
        return NULL;
    }

    getGlobalCameraLock();

    ret = cameraList[listIndex];

    putGlobalCameraLock();

    return ret;

}

/*** BeginHeader is_valid_camera */
int is_valid_camera(USB_CAMERA __far *vc3, int lock_on_return);
/*** EndHeader */
// Return 0 if camera is not in a valid state to use, non-zero otherwise
// Checks for:
// Basic validity of vc3
// vc3 is connected
// vc3 is open
// vc3 is not disconnected
//
// if lock_on_return is non-zero, the instance lock is left in place (if vc3 is valid)
// and the caller must putLock.  If zero is returned by function, no action required of caller.
USBCamDebug
int is_valid_camera(USB_CAMERA __far *vc3, int lock_on_return) {

    int ret;

    ret = 0;

    if(vc3 == NULL) {
        return ret;
    }

    if(list_camera_exist(vc3) == 0) {
        trace(CAMERA_TRACE, TRACE_DEBUG, "is_valid_camera: Camera not connected\n");
        return ret;
    }

    getCameraLock(vc3);

    // have to check again holding the lock.  Can't grab the lock first since we
    // can't assume vc3 is valid before checking if it existed.
    if(list_camera_exist(vc3) == 0) {
        trace(CAMERA_TRACE, TRACE_DEBUG, "is_valid_camera: Camera not connected (but just was).\n");
        ret = 0;
    } else {
        if((vc3->fOpen != 0) && (vc3->disconnected == 0)) {
            ret = 1;
        } else {
            trace(CAMERA_TRACE, TRACE_DEBUG, "is_valid_camera: Camera connected but fOpen = %d, disconnected = %d\n", vc3->fOpen, vc3->disconnected);
        }
    }

    if(ret == 0) {
        putCameraLock(vc3);
    } else if(lock_on_return == 0) {
        putCameraLock(vc3);
        trace(CAMERA_TRACE, TRACE_DEBUG, "is_valid_camera: Valid camera and LOCK is OFF\n");
    } else {
        trace(CAMERA_TRACE, TRACE_DEBUG, "is_valid_camera: Valid camera and LOCK is ON\n");
    }

    return ret;
}

/*** BeginHeader check_camera */
int check_camera(USB_CAMERA __far *vc3);
/*** EndHeader */
// Checks for validity of vc3.  If it is valid, non-zero is returned.
// If not valid, return zero.
USBCamDebug
int check_camera(USB_CAMERA __far *vc3) {

    return is_valid_camera(vc3, 0);
}

/*** BeginHeader check_camera_and_lock */
int check_camera_and_lock(USB_CAMERA __far *vc3);
/*** EndHeader */
// Checks for validity of vc3.  If it is valid, non-zero is returned and the instance
// lock is LEFT IN PLACE. Caller responsible to putCameraLock(vc3);
// This can be thought of as a getLock with a guarantee that the instance is good.
// If not valid, return zero and no lock involved.
USBCamDebug
int check_camera_and_lock(USB_CAMERA __far *vc3) {

    return is_valid_camera(vc3, 1);
}


#if 0
/*
 * This function displays the list of cameras connected to the USB host.
 */
int usb_camera_display(void)
{
    int cameras=0;
    LIST_ENTRY *tmp=cameralist.next;

    while(tmp != &cameralist) {
        USB_CAMERA *uP = list_entry(tmp, USB_CAMERA, list);
        trace(CAMERA_TRACE, TRACE_INFO,  "%s\n", uP->name);
        tmp = tmp->next;
        cameras++;
    }

    return cameras;
}
#endif

/*** BeginHeader usb_camera_strings */
int usb_camera_strings(USB_CAMERA __far *camera);
/*** EndHeader */
/* Retrieves and stores needed string values.
*/
USBCamDebug
int usb_camera_strings(USB_CAMERA __far *camera) {
    unsigned short  languageId[255];
    int result;
    int errorCode;
    int nLanguageIds;
    usbDevice __far *device;
    unsigned char __far *buffer;
    int i; long bytesTransferred;
    int p;
	 int productStringIndex;
	 int serNumIndex;

	 result = 0;
    device = camera->usbDev;
    buffer = NULL;

    buffer = pfcalloc(&usb_gen_list);	// Only 160 bytes out of 256 needed
    if(buffer == NULL) {
        result = -1;
        USBCAMERA_PRINTF_ERR;
        goto exit_function;
    }

    //memset(buffer, 0, USB_CAMERA_PROBE_BUFFER_SIZE);
    if(usb_get_string(device, 0, 0, buffer, USB_CAMERA_PROBE_BUFFER_SIZE, &bytesTransferred, &errorCode)) {
        result = -1;
        USBCAMERA_PRINTF_ERR;
        goto exit_function;
    } else {
        if( !(bytesTransferred || (buffer[0] > 2)) ) {
            result = -1;
        		USBCAMERA_PRINTF_ERR;
            goto exit_function;
        }
    }

    nLanguageIds = (buffer[0]-2)/2;

    for(i=0; i < nLanguageIds; i++)
        languageId[i] = buffer[i*2+3]<<8 | buffer[i*2+2];

    for(i=0; i < nLanguageIds; i++) {
        productStringIndex = device->descriptor.iProduct;
        _f_memset(buffer, 0, USB_CAMERA_PROBE_BUFFER_SIZE);
        if(usb_get_string(device, languageId[i], productStringIndex, buffer, USB_CAMERA_PROBE_BUFFER_SIZE, &bytesTransferred, &errorCode)) {
            result = -1;
        		USBCAMERA_PRINTF_ERR;
            goto exit_function;
        }
        for(p=0; p < bytesTransferred/2-1; p++)
            buffer[p] = buffer[p*2+2];

        buffer[p]=0;

        if(strcmp(camera->deviceIdString, "") == 0) {
            /*Get the first device id string and ignore the rest*/
            _f_strncpy(camera->deviceIdString, (char __far *)buffer, MAX_CAMERA_DESC_LEN);
            camera->deviceIdString[MAX_CAMERA_DESC_LEN - 1] = '\0';
            break;
        }
    }

    for(i=0; i < nLanguageIds; i++) {
        serNumIndex = device->descriptor.iSerialNumber;
        _f_memset(buffer, 0, USB_CAMERA_PROBE_BUFFER_SIZE);
        if(usb_get_string(device, languageId[i], serNumIndex, buffer, USB_CAMERA_PROBE_BUFFER_SIZE, &bytesTransferred, &errorCode)) {
            result = -1;
        		USBCAMERA_PRINTF_ERR;
            goto exit_function;
        }
        for(p=0; p < bytesTransferred/2-1; p++)
            buffer[p] = buffer[p*2+2];

        buffer[p]=0;

        if(strcmp(camera->serNumString, "") == 0) {
            _f_strncpy(camera->serNumString, (char __far *)buffer, MAX_CAMERA_DESC_LEN);
            camera->serNumString[MAX_CAMERA_DESC_LEN - 1] = '\0';
            break;
        }
    }

    exit_function:

    if(buffer)
	 	pffree(&usb_gen_list, buffer);

    return result;
}

/*** BeginHeader usb_camera_configure */
int usb_camera_configure(USB_CAMERA __far *camera);
/*** EndHeader */
/*
 * This function is called to configure a camera after
 * it is connected to the USB host and identified
 * by the driver.
 */
USBCamDebug
int usb_camera_configure(USB_CAMERA __far *camera)
{
    int result, errorCode;
    usbDevice __far *device;
    usbInterfaceDescriptor __far *interface;

	 result = 0;
	 device = camera->usbDev;
    interface = device->config[0].interface;

    if(usb_set_configuration(device, device->config[0].bConfigurationValue, &errorCode)) {
        result = -1;
        USBCAMERA_PRINTF_ERR;
        return result;
    }
    printf("usb_camera_configure: set configuration %d\n",
          device->config[0].bConfigurationValue);

    if(usb_set_interface(device, interface->bInterfaceNumber, interface->bAlternateSetting, &errorCode)) {
        result = -1;
        USBCAMERA_PRINTF_ERR;
        return result;
    }
    printf("usb_camera_configure: set interface %d, alternate setting %d\n",
          interface->bInterfaceNumber, interface->bAlternateSetting);

    return result;
}


/*** BeginHeader usb_camera_probe */
long usb_camera_probe(usbDevice __far *device);
/*** EndHeader */
/*
 * This routine is called as devices are connected to the USB, checks
 * if the device is a watchport camera and if so, it configures it.
 */
USBCamDebug
long usb_camera_probe(usbDevice __far *device)
{
    int result;
    int i;
    unsigned short vendorId;
    unsigned short productId;
    unsigned short bcdDevice;
    usbInterfaceDescriptor __far *interface;
    USB_CAMERA __far *camera;
    unsigned rc;

	 result = 0;
	 camera = NULL;

    interface = device->config[0].interface;

    vendorId = device->descriptor.idVendor;
    productId = device->descriptor.idProduct;

    printf("usb_camera_probe: vendorId = %d, productId = %d\n", vendorId, productId);

    if(vendorId != USB_CAMERA_VENDOR_ID) {
        result = -1;
        goto exit_function;
    }

    if(productId != USB_CAMERA_PRODUCT_ID_4001 &&
       productId != USB_CAMERA_PRODUCT_ID_4011 &&
       productId != USB_CAMERA_PRODUCT_ID_4006 &&
       productId != USB_CAMERA_PRODUCT_ID_4016 &&
       productId != USB_CAMERA_PRODUCT_ID_4007 &&
       productId != USB_CAMERA_PRODUCT_ID_4017) {
        result = -1;
        goto exit_function;
    }

    printf("usb_camera_probe: Watchport camera detected\n");

    // Limit cameras to one for now.  TODO, remove this when more than one camera supported.
    if(list_count_camera() != 0) {
        USBCAMERA_PRINTF_ERR;
        result = -1;
        goto exit_function;
    }

    /* No support for  multiple configurations or multiple interfaces */
    if((device->descriptor.bNumConfigurations != 1) || (device->config[0].bNumInterfaces != 1)) {
        USBCAMERA_PRINTF_ERR;
        result = -1;
        goto exit_function;
    }

    camera = (USB_CAMERA __far *)_sys_calloc(sizeof(USB_CAMERA));
    if (!camera) {
        result = -1;
        USBCAMERA_PRINTF_ERR;
        goto exit_function;
    }

    //memset(camera, 0, sizeof(USB_CAMERA));

    device->driverData = (void __far *)camera;
    camera->usbDev = device;
    camera->devnum = device->devnum;
    camera->idProduct = productId;

    // check firmware status
    bcdDevice = device->descriptor.bcdDevice;
    if((bcdDevice & 0xFF00) == 0) {
        printf("usb_camera_probe: device missing firmware.\n");
        if(vcif_DownloadFirmware(device, productId)) {
            printf("usb_camera_probe: firmware download failed\n");
        }

        printf("usb_camera_probe: firmware download worked.\n");
        printf("usb_camera_probe: Device reseting.  Exitiing probe immed. Camera will reattach..\n");
        result = -1;
        goto exit_function;
    }

    /* Search for bulk endpoint */
    for(i = 0; i < interface->bNumEndpoints; i++) {
        if(interface->endpoint[i].bmAttributes == USB_BULK_ENDPOINT) {
            if(interface->endpoint[i].bEndpointAddress & 0x80) {/*IN*/
                camera->bulkInEp = interface->endpoint[i].bEndpointAddress;
                camera->bulkInMaxPacketSize = interface->endpoint[i].wMaxPacketSize;
            } else {/*OUT*/
                // Watchport does not have a bulk out endpoint
                printf("usb_camera_probe: unexpected output endpoint found\n");
            }
        }
    }

    if(!camera->bulkInEp) {
        result = -1;
        printf("usb_camera_probe: input endpoint invalid\n");
        goto exit_function;
    }

    if(usb_camera_strings(camera)) {
        result = -1;
        goto exit_function;
    }

    if(usb_camera_configure(camera)) {
        result = -1;
        goto exit_function;
    }

	/*SJH
    sprintf(camera->genLockName, "USB Camera %d", camera->number);
    camera->genLockName[MAX_CAMERA_DESC_LEN - 1] = '\0';

    rc = tx_mutex_create(&camera->genLock, camera->genLockName, TX_INHERIT);

    if(rc != TX_SUCCESS) {
        result = -1;
        trace(CAMERA_TRACE, TRACE_CRITICAL, "usb_camera_probe: mutex create failed. Error = %d\n", rc);
        goto exit_function;
    }
	*/

    camera->stats = (USB_CAMERA_STATS __far *)_sys_calloc(sizeof(USB_CAMERA_STATS));

    if(camera->stats == NULL) {
        result = -1;
        USBCAMERA_PRINTF_ERR;
        goto exit_function;
    }

    //memset(camera->stats, '\0', sizeof(USB_CAMERA_STATS));

    sprintf(camera->name, USB_CAMERA_DEV_NAME_FORMAT, camera->number);

    camera->disconnected = 0;

    //SJH   applyCameraSettings(camera);

    if(list_add_camera(camera, &camera->number)) {
        result = -1;
        goto exit_function;
    }

    notifyUsbCameraListeners(camera, CAMERA_CONNECT);

    exit_function:

    if(result != 0) {
        if(camera != NULL) {
            if(camera->stats != NULL) {
                _sys_free(camera->stats);
                camera->stats = NULL;
            }
            _sys_free(camera);
            device->driverData = NULL;
        }
    }

    return result;
}


/*** BeginHeader delete_camera_resources */
void delete_camera_resources(USB_CAMERA __far *vc3);
/*** EndHeader */
// free up all resources allocated for a camera instance
USBCamDebug
void delete_camera_resources(USB_CAMERA __far *vc3) {

    word rc;

    if(vc3 == NULL) {
        USBCAMERA_PRINTF_ERR;
        return;
    }
/*SJH
    rc = tx_mutex_delete(&vc3->genLock);
    if(rc != TX_SUCCESS) {
        USBCAMERA_PRINTF_ERR;
    }
*/
    if(vc3->stats != NULL) {
        _sys_free(vc3->stats);
        vc3->stats = NULL;
    }

    //_f_memset(vc3, 0, sizeof(USB_CAMERA));
    _sys_free(vc3);
}

/*** BeginHeader usb_camera_disconnect */
void usb_camera_disconnect(usbDevice __far *device);
/*** EndHeader */
/*
 * This routine is called if the camera is disconnected from the hub.
 */
USBCamDebug
void usb_camera_disconnect(usbDevice __far *device) {

    USB_CAMERA __far *camera;

    if(device == NULL) {
        USBCAMERA_PRINTF_ERR;
        goto exit_function;
    }

    camera = (USB_CAMERA __far *)device->driverData;

    if(camera == NULL) {
        USBCAMERA_PRINTF_ERR;
        goto exit_function;
    } else {
        printf("usb_camera_disconnect: device->devnum = %d usbCamera=%08lX\n",
              device->devnum, (void __far *)camera);
        printf("usb_camera_disconnect: %ls removed\n", camera->name);

        // Remove for the camera from the driver list
        RemoveEntryList(&camera->list);

        // Remove from connected cameras list
        list_delete_camera(camera);


        if(camera->fOpen != 0) {
            camera->disconnected = 1;
        } else {
            delete_camera_resources(camera);
        }

        notifyUsbCameraListeners(camera, CAMERA_DISCONNECT);
    }

    exit_function:

    return;
}

/*** BeginHeader usb_camera_init */
int usb_camera_init(int * error_code);
/*** EndHeader */
/*
 * The following structure is passed to the
 * usbRegister() routine to initialize the camera
 * driver with the USB host.
 */
const usbDriver usbCameraDriver =
{
    "USB Watchport Camera", /* Name of the device driver      */
    usb_camera_probe,          /* Called when devices connect    */
    usb_camera_disconnect,     /* Called when devices disconnect */
    { NULL, NULL}
};

/**
 * This routine is called to initialize the USB camera driver.
 *
 * @external
 * @category USBH
 * @since 6.1
 *
 * @param error_code On failure, contains error code representing the reason for
 * failure.
 *
 * @return 0        Success
 * @return -1       Failure
 *
 * @see @link usbDevice
 * @include <usbHost.h>
 */

USBCamDebug
int usb_camera_init(int * error_code)
{
    int errorCode;
    unsigned long rc;

    // boilerplate to get USB started if not already.
	 _usb_init();

	 globalUsbCameraLock = OSSemCreate(1);
    if(!globalUsbCameraLock) {
       exception(USB_SEMAPHORE_ERROR);
       exit(USB_SEMAPHORE_ERROR);
    }

    init_camera_list();

    initUsbCameraEventListeners();

    if(usb_register(&usbCameraDriver, &errorCode)) {
        if(error_code != NULL) {
            *error_code = errorCode;
        }
        return -1;
    }

    return 0;
}

/*** BeginHeader getCameraLock, putCameraLock, getGlobalCameraLock, putGlobalCameraLock */
void getCameraLock(USB_CAMERA __far *vc3);
void putCameraLock(USB_CAMERA __far *vc3);
void getGlobalCameraLock(void);
void putGlobalCameraLock(void);
/*** EndHeader */
USBCamDebug
void getCameraLock(USB_CAMERA __far *vc3) {
	//SJH - only one cam supported, so use global lock
	getGlobalCameraLock();
}

USBCamDebug
void putCameraLock(USB_CAMERA __far *vc3) {
	//SJH
	putGlobalCameraLock();
}

USBCamDebug
void getGlobalCameraLock(void) {
	//SJH
}

USBCamDebug
void putGlobalCameraLock(void) {
	//SJH
}


/*** BeginHeader initUsbCameraEventListeners */
void initUsbCameraEventListeners(void);
/*** EndHeader */
USBCamDebug
void initUsbCameraEventListeners(void) {
    int i;

    for(i=0; i<MAX_USB_CAMERA_EVENT_LISTENERS; ++i) {
        usbCameraEventListeners[i] = NULL;
    }
}

/*** BeginHeader registerUsbCameraEventListener */
int registerUsbCameraEventListener(UsbCameraEvent_fn newCallback);
/*** EndHeader */
// returns  0 if successful
//         -1 for catchall error
//         -2 if list is full
USBCamDebug
int registerUsbCameraEventListener(UsbCameraEvent_fn newCallback) {

    int i;
    int added;

    added = 0;

    if(newCallback == NULL)
        return -1;

    getGlobalCameraLock();

    for(i=0; i<MAX_USB_CAMERA_EVENT_LISTENERS; ++i) {
        if(usbCameraEventListeners[i] == NULL) {
            usbCameraEventListeners[i] = newCallback;
            added = 1;
            break;
        }
    }

    putGlobalCameraLock();

    if(added) return 0;
    else return -2;
}

/*** BeginHeader notifyUsbCameraListeners */
void notifyUsbCameraListeners(USB_CAMERA __far *vc3, USB_CAMERA_EVENT newEvent);
/*** EndHeader */
USBCamDebug
void notifyUsbCameraListeners(USB_CAMERA __far *vc3, USB_CAMERA_EVENT newEvent) {
    int i;

    getGlobalCameraLock();

    for(i=0; i<MAX_USB_CAMERA_EVENT_LISTENERS; ++i) {
        if(usbCameraEventListeners[i] != NULL)
            usbCameraEventListeners[i](vc3, newEvent);
    }

    putGlobalCameraLock();
}





























































//*****************************************************************************
// Public Functions
//*****************************************************************************
//=============================================================================
// VCOSIF ViCAM Routines
//=============================================================================
//
// These routines are the interfaces between the Vicam3.c module and the
// hardware. These routines handle all the buffer management, bulk transfer
// start and stops, and control communication to and from the camera.
//


//-----------------------------------------------------------------------------
// vcif_Open()
//-----------------------------------------------------------------------------
//
// vcif_Open() is called when an application is preparing to read image data.
// Buffers are allocated for USB image transfers of the requested size.
// Impl swiped from the linux driver.
//
/*** BeginHeader vcif_Open */
int
vcif_Open(
    void __far *          OsData,
    long             CaptureBufferSize );
/*** EndHeader */

USBCamDebug
int
vcif_Open(
    void __far *          OsData,
    long             CaptureBufferSize )
{
	USB_CAMERA __far *vc3;

	vc3 = (USB_CAMERA __far *) OsData;

	// allocate storage for the USB Bulk-In transfer
	//SJH - original code required 256 alignment, but not needed on Rabbit
	//SJH - also allocated both buffers in one hit.
	vc3->bulkTransferBuffer = _sys_malloc( BULK_IN_TRANSFER_SIZE + CaptureBufferSize );
	if ( vc3->bulkTransferBuffer == NULL ) {
	   USBCAMERA_PRINTF_ERR;
	   return VC_ERROR;
	}
	vc3->imageCaptureBuffer = vc3->bulkTransferBuffer + BULK_IN_TRANSFER_SIZE;
	vc3->captureBufferSize = CaptureBufferSize;

	return VC_NO_ERROR;
} // vcif_Open()

//-----------------------------------------------------------------------------
// vcif_Close()
//-----------------------------------------------------------------------------
//
// vcif_Close() is called when the application currently using the camera is
// shutting down, or when the Format or Resolution is being changed.
//

/*** BeginHeader vcif_Close */
int
vcif_Close(
    void __far *          OsData );
/*** EndHeader */
USBCamDebug
int
vcif_Close(
    void __far *          OsData )
{
	USB_CAMERA __far *vc3;

	vc3 = (USB_CAMERA __far *) OsData;

	if ( vc3->bulkTransferBuffer != NULL ) {
	  _sys_free( vc3->bulkTransferBuffer );
	  vc3->bulkTransferBuffer = NULL;
	}

	return VC_NO_ERROR;
} // vcif_Close()


//-----------------------------------------------------------------------------
// vcif_GetImageData()
//-----------------------------------------------------------------------------
//
// vcif_GetImageData() returns a pointer to a buffer with the newest image data.
//

/*** BeginHeader vcif_GetImageData */
int
vcif_GetImageData(
    void __far *          OsData,
    void __far **         ImageData,
    long __far *          ReturnLen );
/*** EndHeader */
USBCamDebug
int
vcif_GetImageData(
    void __far *          OsData,
    void __far **         ImageData,
    long __far *          ReturnLen )
{
	USB_CAMERA __far *vc3;

	char __far *  vbulkTransferBuffer;
	char __far *  vimageCaptureBuffer;
	long        req_count;
	long        transfer_count;
	long        requestLen;
	int         rc;
	long        vimageCaptureBufferLen;


    vc3 = (USB_CAMERA __far *) OsData;

    vbulkTransferBuffer = vc3->bulkTransferBuffer;
    vimageCaptureBuffer = vc3->imageCaptureBuffer;
    vimageCaptureBufferLen = vc3->captureBufferSize;

    *ReturnLen = 0;
    requestLen = vc3->captureSize;
    while ( requestLen > 0 ) {

        if ( vc3->disconnected ) {
	   		USBCAMERA_PRINTF_ERR;
            return( VC_ERROR );
        }

        req_count = requestLen;
        if ( req_count > BULK_IN_TRANSFER_SIZE ) {

            req_count = BULK_IN_TRANSFER_SIZE;
        }

        transfer_count = 0;

        rc = usb_bulk_transfer(vc3->usbDev, FALSE, vc3->bulkInEp, vbulkTransferBuffer,
                               req_count, &transfer_count, vc3->bulkInMaxPacketSize, VC3_TIMEOUT, &rc);
        if(rc != 0) {
	   		USBCAMERA_PRINTF_ERR;
            return VC_ERROR;
        }

        if(*ReturnLen + transfer_count > vimageCaptureBufferLen) {
            //VcDbg(1, "vcif_GetImageData: USB read overflowed capture buffer");
            // keep going...we need to drain the bulk pipe.
        } else {
            _f_memcpy( vimageCaptureBuffer + *ReturnLen, vbulkTransferBuffer, transfer_count );
        }

        *ReturnLen += transfer_count;
        requestLen -= transfer_count;

        if ( transfer_count < req_count ) {

            //VcDbg(1, "vcif_GetImageData: Short Transfer" );

            // short read - probably an mjpg image
            break;
        }
    }

    if(*ReturnLen > vimageCaptureBufferLen) {
   		USBCAMERA_PRINTF_ERR;
        //VcDbg(1, "vcif_GetImageData: Buffer overflow");
        // todo add stats here so user knows when this happens since memory usage is now
        // under the control of the caller.
        // Just return 0 len.  Don't signal an error.
        *ReturnLen = 0;
    }

    //SJH  VcDbg(1, "vcif_GetImageData: Image read return %d bytes\n", *ReturnLen);

    *ImageData = vc3->imageCaptureBuffer;

    return VC_NO_ERROR;
} // vcif_GetImageData()

//-----------------------------------------------------------------------------
// vcif_ReleaseImageBuffer()
//-----------------------------------------------------------------------------
//
// vcif_ReleaseImageBuffer() releases the lock on the image buffer that was
// locked before its pointer was returned by vcif_GetImageData().
//

/*** BeginHeader vcif_ReleaseImageBuffer */
int
vcif_ReleaseImageBuffer(
    void __far *          OsData,
    void __far *          ImageData );
/*** EndHeader */
USBCamDebug
int
vcif_ReleaseImageBuffer(
    void __far *          OsData,
    void __far *          ImageData )
{
	return VC_NO_ERROR;
} // vcif_ReleaseImageBuffer()

//-----------------------------------------------------------------------------
// vcif_StreamPause()
//-----------------------------------------------------------------------------
//
// vcif_StreamPause() is used to stop the camera from streaming data so that
// camera parameters that affect image transfer sizes can be sent. A Pause
// instead of a Stop allows requests for data, through calls to vcif_GetImageData(),
// to be held off until streaming is restarted and prevents errors from rippling
// back up the application. This routine returns when all transfers have been
// stopped and it's safe to change camera parameters.
//

/*** BeginHeader vcif_StreamPause */
int
vcif_StreamPause(
    void __far *          OsData );
/*** EndHeader */
USBCamDebug
int
vcif_StreamPause(
    void __far *          OsData )
{
	return 0;
} // vcif_StreamPause()

//-----------------------------------------------------------------------------
// vcif_StreamStart()
//-----------------------------------------------------------------------------
//
// vcif_StreamStart() initializes the buffer state variables and starts the
// camera streaming data.
//

/*** BeginHeader vcif_StreamStart */
int
vcif_StreamStart(
    void __far *      OsData,
    long            CaptureSize );
/*** EndHeader */
USBCamDebug
int
vcif_StreamStart(
    void __far *      OsData,
    long            CaptureSize )
{

    // this function will be more useful when there are bulk transfers running
    // in the background

    USB_CAMERA __far *vc3;

    vc3 = (USB_CAMERA __far *) OsData;

    if(vc3 == NULL) {
   		USBCAMERA_PRINTF_ERR;
         return -1;
    }
    // save the capture size
    vc3->captureSize = CaptureSize;

    return(0);

} // vcif_StreamStart()

//-----------------------------------------------------------------------------
// vcif_StreamStop()
//-----------------------------------------------------------------------------
//
// vcif_StreamStop() stops the bulk transfer pipeline.
//

/*** BeginHeader vcif_StreamStop */
int
vcif_StreamStop(
    void __far *          OsData );
/*** EndHeader */
USBCamDebug
int
vcif_StreamStop(
    void __far *          OsData )
{
    return(0);

} // vcif_StreamStop()

//-----------------------------------------------------------------------------
// vcif_VendorRequest()
//-----------------------------------------------------------------------------
//
// vcif_VendorRequest() issues a request to the camera's control pipe.
//
// Direction - Indicates either a VCIF_READ or VCIF_WRITE request
// bRequest -  The Vendor Specific Command that the camera will respond to.
// wValue -    The new value to be sent to the camera. USB limits this field to
//             16 bits. This field is not used for VCIF_READ requests.
// wIndex -    VN_CTRL_xxx camera command ID
// wLength -   Length of the data to be transferred that is pointed to by *Data.
//             This field is zero for simple 16 bit ViCAM ControlSet() commands.
//             It is 2 for simple 16 bit ViCAM ControlGet() commands.
// Data -      Pointer to the data transfer buffer.
//

/*** BeginHeader vcif_VendorRequest */
int
vcif_VendorRequest(
    void __far *      OsData,
    int             Direction,
    int             bRequest,               // camera defined command
    int             wValue,                 // new control value ( if VCIF_WRITE )
    int             wIndex,                 // VN_CTRL_xxx command ID
    int             wLength,                // length of the
    void __far *      Data );
/*** EndHeader */
USBCamDebug
int
vcif_VendorRequest(
    void __far *      OsData,
    int             Direction,
    int             bRequest,               // camera defined command
    int             wValue,                 // new control value ( if VCIF_WRITE )
    int             wIndex,                 // VN_CTRL_xxx command ID
    int             wLength,                // length of the
    void __far *      Data )
{
    USB_CAMERA __far *vc3;
    usbDevice __far *devExt;
    devrequest request;
    char __far * buffer;
    int result;
    long totalXfer;
    word timeout;

    vc3 = (USB_CAMERA __far *) OsData;
    devExt = vc3->usbDev;
	 buffer= NULL;
    result = 0;
    totalXfer = 0;
    timeout = 2000; //SJH make 2 secs    20 * BSP_TICKS_PER_SECOND;

    if (devExt == NULL)
    {
        result = (-1);
        goto exit_function;
    }

#if USBCAMERA_VERBOSE > 1
    printf("vcif_VendorRequest: Dir=%d req=%d val=%d index=%d length=%d\n",
    	Direction, bRequest, wValue, wIndex, wLength);
#endif


    // todo, change this to a real max
    if (wLength > 1024) {
        printf("vcif_VendorRequest: request too large. size = %d\n", wLength);
        //VcDbg( 1, "vcif_VendorRequest: usb request len too large\n");
        result = -2;
        goto exit_function;
    }

    if (vc3->disconnected != 0) {
        printf("vcif_VendorRequest: usb request attempted but device disconnected\n");
        //VcDbg( 1, "vcif_VendorRequest: usb request attempted but disconnected\n");
        result = -3;
        goto exit_function;
    }

    if (wLength > 0) {
    	//SJH - was 256 aligned
        buffer = (char __far *)_sys_malloc(wLength);
        if (buffer == NULL) {
            printf("vcif_VendorRequest: usb_malloc failed.  len = %d\n", wLength);
        }
    }

    if ( Direction == VCIF_READ ) {

        request.requesttype  = USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DEVICE_TO_HOST_REQ;
        request.request      = (char) bRequest;
        request.value        = wValue;
        request.index        = wIndex;
        request.length       = wLength;

        if (usb_device_request(devExt, FALSE, &request, buffer, wLength, &totalXfer, timeout, &result))
        {
           result = -4;
   		  USBCAMERA_PRINTF_ERR;
           goto exit_function;
        }

        //trace(CAMERA_TRACE, TRACE_DEBUG, "vcif_VendorRequest: read, total transferred = %d\n", totalXfer);

        if (buffer && totalXfer > 0) {
            _f_memcpy(Data, buffer, (word)totalXfer);
        }
    } else {
        if (!buffer && wLength) {
            result = -5;
            goto exit_function;
        }

        if (buffer)
        		_f_memcpy(buffer, Data, wLength);

        request.requesttype  = USB_TYPE_VENDOR | USB_RECIP_DEVICE;
        request.request      = (char) bRequest;
        request.value        = wValue;
        request.index        = wIndex;
        request.length       = wLength;

        if (usb_device_request(devExt, TRUE, &request, (char __far *)buffer, wLength,
        					&totalXfer, timeout, &result))
        {
           result = -6;
           goto exit_function;
        }
    }

exit_function:

    if(buffer) _sys_free(buffer);
    return result;
}

//=============================================================================
// VCOSIF Operating System Run-Time Library Functions
//=============================================================================
//
// These routines implement generic functions required by Vicam3.c. For
// example, since memory allocation routines in different operating systems
// have different functions names, the Vicam3.c module can make a call to the
// the vcif_MemAlloc() routine and the specifics for the operating system are
// handled within the routine in this module.
//


//-----------------------------------------------------------------------------
// vcif_Sleep()
//-----------------------------------------------------------------------------
//
// vcif_Sleep() puts the current thread into a sleep state for the specified
// number of milliseconds. This routine is NOT accurate to the millisecond due
// to system capabilities.
//

/*** BeginHeader vcif_Sleep */
void
vcif_Sleep(
    void __far *          OsData,
    int             Milliseconds );
/*** EndHeader */
USBCamDebug
void
vcif_Sleep(
    void __far *          OsData,
    int             Milliseconds )
{
    if (Milliseconds < 1) return;
	 OSTimeDlyHMSM( 0, 0, 0, Milliseconds);
} // vcif_MemSet()


//=============================================================================
// Firmware Download Functions
//=============================================================================
//-----------------------------------------------------------------------------
// vcif_DownloadFirmware()
//-----------------------------------------------------------------------------

/*** BeginHeader vcif_DownloadFirmware */
int vcif_DownloadFirmware(usbDevice __far *DevExt, int Pid);
/*** EndHeader */
USBCamDebug
int vcif_DownloadFirmware(usbDevice __far *DevExt, int Pid) {
	 USB_CAMERA __far *vc3;
    unsigned char __far *codePtr;
    int codeLen;

    int rc;
    int orgValue;
    int tmpCount;
    int tmpIndex;

    rc = VC_NO_ERROR;
    orgValue = 0;
    tmpCount = 0;
    tmpIndex = 0;


    if (!DevExt) {
   	  USBCAMERA_PRINTF_ERR;
        return -322;
    }

    vc3 = (USB_CAMERA __far *) DevExt->driverData;


    // use the firmware image compiled into this driver

    if ( Pid == 0x4001 ) {
        //FIXME: The cast applied to wpv4011 is dangerous, as codePtr + tmpIndex
        //       is later passed into vcif_VendorRequest() as a read / write
        //       buffer parameter.
        codePtr = (unsigned char __far *) wpv4011;
        codeLen = (int)sizeof( wpv4011 );
    }
//SJH - not yet implemented...
#if 0
    else if ( Pid == 0x4002 ) {
        codePtr = wpv4012;
        codeLen = sizeof( wpv4012 );
    }
/* VE not implemented yet
	else if ( Pid == 0x4005 ) {
		codePtr = wpv4015;
		codeLen = sizeof( wpv4015);
	}
*/
	else if ( Pid == 0x4006 ) {
		codePtr = wpv4016;
		codeLen = sizeof( wpv4016);
	}
	else if ( Pid == 0x4007 ) {
		codePtr = wpv4017;
		codeLen = sizeof( wpv4017);
	}
//    else if ( Pid == 0x4005 ) {   //jjr mod: using PID=0x4005 for Vista VC3 development board
//        codePtr = wpv4015;
//        codeLen = sizeof( wpv4015 );  //jjr mod
//    }
#endif
    else {
        printf("vcif_DownloadFirmware: Invalid Pid: 0x0%04X\n", Pid);
        //VcDbg( 1, "\n*** vcif_DownloadFirmware - Invalid Pid: 0x%04X\n\n", Pid );
        return( VC_ERROR );
    }

    printf("vcif_DownloadFirmware - 0x%X bytes ...\n", codeLen );

    do {

        tmpCount = codeLen - tmpIndex;
        if ( tmpCount > VC3_FIRMWARE_BLOCK_SIZE ) {
            tmpCount = VC3_FIRMWARE_BLOCK_SIZE;
        }

        // download a block of the firmware into the device
        rc = vcif_VendorRequest( vc3,
                VCIF_WRITE,
                VC3_CMD_FIRMWARE_DOWNLOAD,
                ( orgValue + tmpIndex ) >> 1,   // word address
                0,
                tmpCount,
                codePtr + tmpIndex );

        if(rc != 0) {
            printf("vcif_DownloadFirmware: Download failed error = %d \n", rc);
            return rc;
        }

        tmpIndex += tmpCount;

    } while ( tmpIndex < codeLen );

    // send the command to reset and execute the new firmware
    rc = vcif_VendorRequest( vc3,
            VCIF_WRITE,
            VC3_CMD_FIRMWARE_DOWNLOAD,
            orgValue,
            VC3_RESET_DELAY,
            0,
            (void __far *)NULL );

    if(rc != 0) {
        printf("vcif_DownloadFirmware: reset failed.  error = %d \n", rc);
        return rc;
    }

	printf("vcif_DownloadFirmware - Complete\n" );

    return( rc );

} // vcif_DownloadFirmware()


/*** BeginHeader */
#endif // #ifndef _USBCAMERA_H
/*** EndHeader */


