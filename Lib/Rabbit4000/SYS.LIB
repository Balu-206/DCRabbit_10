/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/*** START LIBRARY DESCRIPTION *********************************************
SYS.LIB

DESCRIPTION:

SUPPORT LIB'S:

CHANGE HISTORY:
  2010 Jan 6  SJH  Fixed MS_TIMER updates when running in slow clock mode
END DESCRIPTION **********************************************************/


/*** BeginHeader */
#ifndef __SYS_LIB
#define __SYS_LIB

// generally useful typedef for individual I/O pin handling
typedef struct sys_iopin_st {
	unsigned port;
	char *shadow;
	char mask;
} sys_iopin_t;
/*** EndHeader */

/*** BeginHeader _sys_exit */
__root void _sys_exit(int exitcode);
/*** EndHeader */
/* START _FUNCTION DESCRIPTION ********************************************
_sys_exit                         										<SYS.LIB>

SYNTAX: void _sys_exit(int exitcode);

DESCRIPTION: Stops the program and returns exitcode to Dynamic C.
Dynamic C uses values above 128 for run-time errors. When not
debugging, _sys_exit will run an infinite loop, causing a watchdog
timeout if the watchdog is enabled.

RETURN VALUE: Does not return.

KEYWORDS: _sys_exit
END DESCRIPTION **********************************************************/

int _sys_exit_ret;
int _sys_exit_err;

#asm __nodebug
; EXIT   : C Callable Version of UNIX exit() for Dynamic C
;
; INPUT  :
;          Stack : (Ret Addr) (Exit Code)
; OUTPUT :
;          None

_sys_exit::
	ld		(_sys_exit_err),hl
   ex		(sp),hl	; return address in hl
   ld		(_sys_exit_ret),hl
   add	sp,4
	call	_BiosStkSwitch
	add	sp,2		; return address left on bios stack
	ld		hl,(_sys_exit_ret)
	exx				; hl' has return address
	ld		hl,(_sys_exit_err)
   ld		a,xpc
	jp		dkEnd
#endasm


/*** beginheader _prot_needs_init, _prot_init, _prot_recover */
__root int _prot_needs_init(void);
__root void _prot_init(void);
__root void _prot_recover(void);
#define _FLAG_PVALID 0xA55ADC42UL
/*** endheader */
extern char _flag_prot16; extern int  *_ptr_prot16; extern int  _prot16_save;
extern char _flag_prot32; extern long *_ptr_prot32; extern long _prot32_save;

/* START FUNCTION DESCRIPTION ********************************************
_prot_init                                                       <SYS.LIB>

SYNTAX:     void _prot_init(void);

KEYWORDS:

DESCRIPTION: Super initialization. Initializes internal data needed
				for recovery of protected variables after a crash. This function
				should be called once per program before protected variables are
				set in order to ensure that the protection mechanism works.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/

/* START FUNCTION DESCRIPTION ********************************************
_prot_recover                                                    <SYS.LIB>

SYNTAX:     void _prot_recover(void);

DESCRIPTION:   Recover variables whose operations are interrupted by
power fail.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/

#asm __nodebug
;
; call _prot_needs_init to determine whether _prot_init has been called
;
_prot_needs_init::
	ld		jkhl,(_flag_pvalid)
   ld		bc,0+(_FLAG_PVALID>>16UL) // Use 0+ so it doesn't look like indirect LD
   ld		de,_FLAG_PVALID
   xor	a
   cp  	jkhl,bcde     // This sets Z flag if they're equal...
   sub   jkhl,bcde     //  this doesn't set Z, but clears HL for 0 return val
   ret   z             // Return 0 if flag valid
   ld    hl,1
   ret                 // Return 1 if flag invalid
;
; call _prot_init only for complete reset
;
_prot_init::
	xor	a
	ld		(_flag_prot16),  a
	ld		(_flag_prot32),  a
   ld		jk,0+(_FLAG_PVALID>>16)
   ld		hl,_FLAG_PVALID
   ld		(_flag_pvalid),  jkhl
	ret
;
; call _prot_recover on startup after power fail, reset, etc.
;
_prot_recover::
	diasmseq(ddip)					;disable interrupts
	ld		a, (_flag_prot16)
	or		a
	jr		z, ._pro_2
	ld		hl, (_ptr_prot16)		;pointer to destination
	ld		de, (_prot16_save)	;data
	ld		(hl), e
	inc	hl
	ld		(hl), d
	xor	a
	ld		(_flag_prot16), a		;clear flag
._pro_2:
	ld		a, (_flag_prot32)
	or		a
	jr		z, ._pro_3
	ld		de, (_ptr_prot32)		;pointer to destination
	ld		hl, _prot32_save		;pointer to source
	ld		bc, 4						;count to move
	ldir								;recover the 32-bit protected variable
	xor	a
	ld		(_flag_prot32), a		;clear flag
._pro_3:
	riasmseq							;restore interrupts
	ret
#endasm


/*** BeginHeader getdivider19200 */

__root char getdivider19200(void);

/*** EndHeader */

/* START FUNCTION DESCRIPTION **************************************************
getdivider19200					                                         <SYS.LIB>

SYNTAX:	char getdivider19200(void);

DESCRIPTION:   Returns the divider19200 value regardless of compile mode.
In separate I&D space mode, the divider value is stored as a define byte in
code space, so directly accessing the variable will result in an incorrect
load (from constant data space). This function uses ldp instruction which
circumvents the separate I&D default loading scheme, so the correct value
is returned.

RETURN VALUE:	The divider19200 value.

SEE ALSO:		divider19200
END DESCRIPTION ***************************************************************/


#asm __root __nodebug
getdivider19200::
	ldf hl, (divider19200)  ; register L now contains the divider
	ld  h, 0						; We are only interested in the 8-bit quantity
	ret
#endasm


/*** BeginHeader clockDoublerOn */
__root void clockDoublerOn(void);
/*** EndHeader */

/* START FUNCTION DESCRIPTION **************************************************
clockDoublerOn						                                         <SYS.LIB>

SYNTAX:	void clockDoublerOn(void);

DESCRIPTION:	Enables the Rabbit clock doubler.  If the doubler is already
enabled, there will be no effect.  Also attempts to adjust the baud rate on
serial port A so communication between Dynamic C and the target is not lost.
Other serial port rates need to be adjusted by the user.  This function is
not task reentrant.

RETURN VALUE:	none.

SEE ALSO:		clockDoublerOff
END DESCRIPTION ***************************************************************/
__root __nodebug
void clockDoublerOn (void)
{
	#asm __nodebug
	lcall	_getDoublerSetting	; get setting to turn on clock doubler
	ld		a, (GCDRShadow)		; get current setting
	cp		l							; compare with new one
	jr		z,.cdo_exit				; if same, don't change anything!
.turnOn:
	ld		a, l
	ioi	ld (GCDR), a			; set new value
	ld		(GCDRShadow), a

	ld		a, (TAT4RShadow)
	inc	a
	sla	a
	dec	a
	ioi	ld (TAT4R), a			; set comm rate
	ld		(TAT4RShadow), a

	ld		a, (freq_divider)		; adjust value for other serial ports
	sla	a
	ld		(freq_divider), a
.cdo_exit:
#endasm
}//clockDoublerOn(void)

/*** BeginHeader clockDoublerOff */
__root void clockDoublerOff(void);
/*** EndHeader */

/* START FUNCTION DESCRIPTION **************************************************
clockDoublerOff					                                         <SYS.LIB>

SYNTAX:	void clockDoublerOff(void);

DESCRIPTION:	Disables the Rabbit clock doubler.  If the doubler is already
disabled, there will be no effect.  Also attempts to adjust the baud rate on
serial port A so communication between Dynamic C and the target is not lost.
Other serial port rates need to be adjusted by the user.  This function is
not task reentrant.

RETURN VALUE:	none.

SEE ALSO:		clockDoublerOn
END DESCRIPTION ***************************************************************/
__root __nodebug
void clockDoublerOff (void)
{
#asm __nodebug
	ld		c, 00h					; setting to turn off clock doubler
	ld		a, (GCDRShadow)		; get current setting
	cp		c							; compare with new one
	jr		z,.cdoff_exit			; if same, don't change anything!
.turnOff:
	ld		a, c
	ioi	ld (GCDR), a			; set new value
	ld		(GCDRShadow), a

	ld		a, (TAT4RShadow)
	inc	a
	srl	a
	dec	a
	ioi	ld (TAT4R), a			; set comm rate
	ld		(TAT4RShadow), a

	ld		a, (freq_divider)		; adjust value for other serial ports
	srl	a
	ld		(freq_divider), a
.cdoff_exit:
#endasm
} //clockDoublerOff(void)

/*** BeginHeader useMainOsc */
__root void useMainOsc(void);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
useMainOsc                                                       <SYS.LIB>

SYNTAX:  void useMainOsc(void);

DESCRIPTION:  Sets the Rabbit processor to use the main oscillator at full
speed for both the CPU and peripheral clock.  If this is already set there
is no effect.  This function also enables the periodic interrupt in case
it was disabled by a call to use32kHzOsc(), and updates the TICK_TIMER,
MS_TIMER, and SEC_TIMER variables from the real-time clock.  This function
is not task reentrant.

RETURN VALUE:  None.

SEE ALSO:  useClockDivider, use32kHzOsc, useClockDivider3000,
set32kHzDivider
END DESCRIPTION *********************************************************/

#asm __nodebug
useMainOsc::
	ld		a, (GCSRShadow)	; get current oscillator(s) setting
	and	a, 0x18				; mask out bits not related to 32 KHz oscillator
	cp		0x10					; is it a 32 KHz oscillator setting?
	jr		nz, .isMainOsc		; if not, just go set full-speed main osc . . .

	;; first, turn on main oscillator without switching CPU to use it
	ld		a, 0x10			; setting to enable main oscillator w/o using it
	ld		(GCSRShadow), a
	ioi	ld (GCSR), a	; set new oscillator settings

	call	updateTimers	; set periodic timers to correct values
	;; this call also serves as a delay for main oscillator to get
	;;		up to speed (roughly ~20msec with 32kHz oscillator)

.isMainOsc:
	;; next, switch CPU to use main oscillator
	ld		a, 0x09			; setting to run CPU off main oscillator
								;	AND enable periodic interrupt (level 1)
	ld		(GCSRShadow), a
	ioi	ld (GCSR), a	; set new oscillator settings

	ret
#endasm

/*** BeginHeader useClockDivider */
__root void useClockDivider(void);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
useClockDivider                                                  <SYS.LIB>

SYNTAX:  void useClockDivider(void);

DESCRIPTION:  Sets the Rabbit processor to use the main oscillator divided
by 8 for the CPU (but not the peripheral clock).  If this is already set,
there is no effect. Because the peripheral clock is not affected, serial
communications should still work.  This function also enables the periodic
interrupt in case it was disabled by a call to use32kHzOsc().
This function is not task reentrant.

RETURN VALUE:  None.

SEE ALSO:  useMainOsc, use32kHzOsc, useClockDivider3000, set32kHzDivider
END DESCRIPTION *********************************************************/


#asm __nodebug
useClockDivider::
	;; enable CPU to use main oscillator with clock divider enabled
	ld		a, 0x05			; enable periodic interrupt and divide CPU
								; clock by 8 (but not peripheral clock)
	ld		(GCSRShadow), a
	ioi	ld (GCSR), a	; set new oscillator settings
	ret
#endasm

/*** BeginHeader use32kHzOsc, updateTimers */

__root void use32kHzOsc(void);
void updateTimers(void);

// State of clocks on entry to 32kHz clock mode
extern unsigned long _lastRTCVal;
extern unsigned long _lastTickVal;
extern unsigned long _lastMSVal;

/*** EndHeader */

unsigned long _lastRTCVal;
unsigned long _lastTickVal;
unsigned long _lastMSVal;

/* START FUNCTION DESCRIPTION ********************************************
use32kHzOsc                                                      <SYS.LIB>

SYNTAX:  void use32kHzOsc(void);

DESCRIPTION:
	   Sets the Rabbit processor to use the 32kHz real time clock oscillator
	   for both the CPU and peripheral clock, and shuts off the main
	   oscillator.  If this is already set, there is no effect.  This mode should
	   provide greatly reduced power consumption.  Serial communications will be
	   lost since typical baud rates cannot be made from a 32kHz clock.  Also
	   note that this function disables the periodic interrupt, so waitfor and
	   related statements will not work properly (although costatements in
	   general will still work).  Due to this fact, the values in TICK_TIMER,
	   MS_TIMER, and SEC_TIMER will not be updated unless you call the function
	   updateTimers() frequently in your code.  In addition, you will need to
	   call hitwd() periodically to hit the hardware watchdog timer since the
	   periodic interrupt normally handles that, or disable the watchdog timer
	   before calling this function.  The watchdog can be disabled with
	   Disable_HW_WDT().  This function is not task reentrant.

RETURN VALUE:  None.

SEE ALSO:  useMainOsc, useClockDivider, updateTimers, useClockDivider3000,
				set32kHzDivider, hitwd, Disable_HW_WDT, Enable_HW_WDT
END DESCRIPTION *********************************************************/

#asm __nodebug
use32kHzOsc::
		ld		a, (GCSRShadow)		; get current oscillator(s) setting
		and	a, 0x18					; mask out bits not related to 32 KHz osc.
		cp		0x10						; already at one of two 32 KHz osc. settings?
		jr		z, .set32KHzMainOff	; if so, just go ensure main oscillator off

	;; save current periodic timer status so we can update later
	;_lastTickVal = TICK_TIMER;
		ld		bcde, (TICK_TIMER)
		ld		(_lastTickVal), bcde
		ld		bcde, (MS_TIMER)
		ld		(_lastMSVal), bcde

ioi   ld 	(RTC0R), a        	; latch RTC
ioi   ld		bcde, (RTC0R)       	; load four lowest bytes of RTC
.again:
		ex		jkhl, bcde				; put previous reading into jkhl
ioi	ld		(RTC0R), a				; latch again (checking for ripple)
ioi	ld		bcde, (RTC0R)			; load four lowest bytes again
		cp		jkhl, bcde
		jr		nz, .again

		ld		(_lastRTCVal), bcde	;    and store in lastRTCVal

.set32KHzMainOff:
		ld		a, 0x14			; setting to run CPU off 32kHz oscillator, turn off
									;	main oscillator AND disable periodic interrupt
		ld		(GCSRShadow), a
ioi	ld 	(GCSR), a		; set new oscillator settings
		ret
#endasm


/* START FUNCTION DESCRIPTION ********************************************
updateTimers                                                     <SYS.LIB>

SYNTAX:  void updateTimers(void);

DESCRIPTION:  Updates the values of TICK_TIMER, MS_TIMER, and SEC_TIMER
					while running off the 32kHz oscillator.  Since the periodic
					interrupt is disabled when running at 32kHz, these values
					will not update unless this function is called.  This function
					is not task reentrant.

					Only call this when running from the 32kHz clock, or
					immediately after switching from the 32kHz clock back to
					the main clock.

					Note:  Your application must service the watchdogs manually if
					you are running off the 32kHz oscillator.

RETURN VALUE:  None.

SEE ALSO:  useMainOsc, use32kHzOsc, hitwd
END DESCRIPTION *********************************************************/
__nodebug
void updateTimers(void)
{
#asm
		; jkhl = current RTC
.retry:
ioi	ld 	(RTC0R), a			; latch RTC
ioi	ld 	jkhl, (RTC0R)		; copy 4 lowest bytes to JKHL
ioi	ld 	(RTC0R), a			; latch RTC
ioi	ld 	bcde, (RTC0R)		; copy 4 lowest bytes to BCDE
		ioi ld a,(GCSR)
		and	a,0x18
		cp		a,0x10				; bits 4:3 == b'10 means running at 32k or less.
		jr		nz,.running_fast
		; Running on clock we are examining, so ignore LSB for comparison
		; purposes, and only compare the 3 MSBs.
		ld		e,L
.running_fast:
		cp		jkhl,bcde
		jr		nz,.retry

		; bcde = _lastRTCVal
		ld		bcde, (_lastRTCVal)

		; jkhl = (current RTC - _lastRTCVal)
		sub	jkhl, bcde

		; jkhl >>= 5				(delta_ticks)
		srl	4, jkhl
		srl	1, jkhl

		ex		jkhl,bcde

		; TICK_TIMER = _lastTickVal + delta_ticks
		ld		jkhl, (_lastTickVal)
		add	jkhl, bcde
		ld		(TICK_TIMER), jkhl

		; The delta_ms value is 1000/1024 (i.e. 125/128) of the delta_ticks value.
		; We calculate this by subtracting from the delta_ticks value first 1/64
		;  and then 1/128 of the original delta_ticks value.
		ld		jkhl,0
		add	jkhl,bcde			; jkhl = delta_ticks
		srl	4,bcde
		srl	2,bcde				; bcde = delta_ticks / 64
		sub	jkhl,bcde			; jkhl = delta_ticks - (delta_ticks / 64)
		srl	1,bcde				; bcde = delta_ticks / 128
		sub	jkhl,bcde			; delta_ms = delta_ticks - (delta_ticks * 125/128)
		; MS_TIMER = _lastMSVal + delta_ms
		ld		bcde, (_lastMSVal)
		add	jkhl,bcde
		ld		(MS_TIMER), jkhl
#endasm

	SEC_TIMER = read_rtc();
}


/*** BeginHeader useClockDivider3000 */
__xmem void useClockDivider3000(int setting);

#define	CLKDIV_1		0x08
#define	CLKDIV_2		0x0C
#define	CLKDIV_4		0x18
#define	CLKDIV_6		0x1C
#define	CLKDIV_8		0x00

/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
useClockDivider3000           											<SYS.LIB>

SYNTAX:  void useClockDivider3000(int setting);

PARAMETER1:  The following divider settings are valid:
               CLKDIV_1  full speed main processor clock
               CLKDIV_2  divide main processor clock by two
               CLKDIV_4  divide main processor clock by four
               CLKDIV_6  divide main processor clock by six
               CLKDIV_8  divide main processor clock by eight

DESCRIPTION:  Sets the expanded clock divider options on the Rabbit
processor.  This function will also affect the peripheral clock --- use
useClockDivider() to divide the processor clock by eight but not affect
the peripheral clock.  Target communications will be lost after changing
this setting because of the baud rate change.  This function also enables
the periodic interrupt in case it was disabled by a call to use32kHzOsc().
This function is not task reentrant.

RETURN VALUE:  None.

SEE ALSO:  useClockDivider, useMainOsc, use32kHzOsc, set32kHzDivider
END DESCRIPTION *********************************************************/

#asm __xmem __nodebug
useClockDivider3000::
	ld		a, l					; get setting
	or		0x01					; enable periodic interrupt
	ld		(GCSRShadow), a
	ioi	ld (GCSR), a		; set new oscillator settings
	lret
#endasm


/*** BeginHeader set32kHzDivider */
__xmem void set32kHzDivider(int setting);

#define	OSC32DIV_1		0x00
#define	OSC32DIV_2		0x04
#define	OSC32DIV_4		0x05
#define	OSC32DIV_8		0x06
#define	OSC32DIV_16		0x07

/*** EndHeader */

/* START FUNCTION DESCRIPTION **************************************************
set32kHzDivider																		<SYS.LIB>

SYNTAX:	void set32kHzDivider(int setting);

PARAMETER1:		32kHz divider setting.  The following are valid:
							OSC32DIV_1		don't divide 32kHz oscillator
							OSC32DIV_2		divide 32kHz oscillator by two
							OSC32DIV_4		divide 32kHz oscillator by four
							OSC32DIV_8		divide 32kHz oscillator by eight
							OSC32DIV_16		divide 32kHz oscillator by sixteen

DESCRIPTION:	Sets the expanded 32kHz oscillator divider for the Rabbit
processor.  This function does not enable running the 32kHz oscillator instead
of the main clock (call use32kHzOsc() to enable that), but will affect the
actual rate used by the processor when that function is called.
This function is not task reentrant.

RETURN VALUE:	none.

SEE ALSO:		useClockDivider, useClockDivider3000, useMainOsc, use32kHzOsc
END DESCRIPTION ***************************************************************/

#asm __xmem __nodebug
set32kHzDivider::
	ld		a, (GPSCRShadow)
	and	0xF8					; don't change other settings in register
	or		l
	ld		(GPSCRShadow), a
	ioi	ld (GPSCR), a		; set new 32kHz divider settings
	lret
#endasm

/*** BeginHeader SetVectIntern */
unsigned SetVectIntern(int vectNum, void *isr);
/*** EndHeader */

/* START FUNCTION DESCRIPTION *************************************************
SetVectIntern							                                     <SYS.LIB>

SYNTAX:	unsigned SetVectIntern(int vectNum, void *isr);

DESCRIPTION:	Function to set an internal interrupt jump table entry.
All Rabbit interrupts use jump vectors. This function writes a jp
instruction (0xC3) followed by the 16 bit ISR address to the appropriate
location in the vector table.

The location in RAM of the vector table is determined and set by the BIOS
automatically at startup. The start of the table is always on a 0x100
boundary.

It is perfectly permissible to have ISRs in xmem and do long jumps to
them from the vector table. It is even possible to place the entire body
of the ISR in the vector table if it is 16 byte long or less, but this
function only sets up jumps to 16 bit addresses.

The following table shows the vectNum argument that should be used for each
peripheral or RST. The offset into the vector table is also shown.

	Peripheral or RST                        vectNum   Vector Table	Rabbit 6000
																		Offset			Only
	-----------------------------------------------------------------------------
	System Management (periodic interrupt)      0x00   0x0000
	Secondary Watchdog Timer						  0x01	0x0010
   RST 10 instruction                          0x02   0x0020
   SYSCALL Instruction								  0x06	0x0060
   RST 38 instruction                          0x07   0x0070
   Slave Port                                  0x08   0x0080
   Write Protection Violation						  0x09	0x0090
   Timer A                                     0x0A   0x00A0
   Timer B                                     0x0B   0x00B0
   Serial Port A                               0x0C   0x00C0
   Serial Port B                               0x0D   0x00D0
   Serial Port C                               0x0E   0x00E0
   Serial Port D                               0x0F   0x00F0
	Network Port C (Wifi)							  0x10	0x0100 -------> X
	Network Port D (USB)								  0x11	0x0110 -------> X
	[RESERVED - For Future Use]					  0x12	0x0120
	Flexible Interface Module A					  0x13	0x0130 -------> X
	Flexible Interface Module B					  0x14	0x0140 -------> X
	Serial Port G (I2C)								  0x15	0x0150 -------> X
	ADC													  0x16	0x0160 -------> X
	Pulse Width Modulator                       0x17   0x0170
	System Mode Violation							  0x18	0x0180
	Quadrature encoder								  0x19   0x0190
	Input capture										  0x1A   0x01A0
	Stack Limit Violation							  0x1B	0x01B0
	Serial port E										  0x1C   0x01C0
	Serial port F										  0x1D   0x01D0
	Network Port B (Ethernet)*						  0x1E	0x01E0
	Timer C												  0x1F	0x01F0

	The following three RSTs are included for completeness,
	but should not be set by the user normally as they are
	used by Dynamic C

   RST 18 instruction                          0x03   0x30
   RST 20 instruction                          0x04   0x40
   RST 28 instruction                          0x05   0x50

* This table entry was previously known as Network Port A. In the Rabbit 5000,
	Wifi and Ethernet could not be used concurrently so they shared an interrupt.
	However, in Rabbit 6000, Wifi and Ethernet can run concurrently so they no
	longer share the same interrupt.

PARAMETER1: Interrupt number. 0 - 0x1F are the only valid values
				(excluding - 0x12). See the above table.
PARAMETER2: ISR handler address. Must be a root address.

RETURN VALUE:	Address of vector table entry, or zero if the vectnum
					is not valid.

SEE ALSO:		GetVectIntern, SetVectExtern, GetVectExtern
END DESCRIPTION **************************************************************/
__useix __nodebug
unsigned SetVectIntern(int vectNum, void *isr)
{
#asm
	; check for invalid vector number (> 0x1F)
	ld    de,0xffe0
	and   hl,de
	jr    z,.vecNumOK
	clr	hl
	push  hl
	jr    .done
.vecNumOK:
	; table entries are 16 bytes
	ld 	de,16
	ld 	hl,(ix+vectNum)
	ld    bc,hl
	mul

	; INTVEC_BASE contains the internal vectable offset
	ld    hl, INTVEC_BASE

	; hl now points to the table entry
	add 	hl, bc

.addrOk:
	; put the jump instruction first
	ld    (hl),_OP_JP
	push  hl
	inc   hl
	push  hl
	pop   iy

	; put the isr address next
	ld    hl,(ix+isr)
  	ld    (iy),hl

.done:
	; return the address of the vector table entry
	pop   hl
#endasm
}

/*** BeginHeader GetVectIntern */
typedef void (*isr_ptr_type) ();
isr_ptr_type GetVectIntern(int vectNum);
/*** EndHeader */

/* START FUNCTION DESCRIPTION **************************************************
GetVectIntern							                                      <SYS.LIB>

SYNTAX:	unsigned (*)() GetVectIntern(int vectNum);

DESCRIPTION:	Function to read the address of internal interrupt
table entry. This function really just returns whatever value is at
the address: (internal vector table base) + (vectNum*16) + 1.

PARAMETER1: Interrupt number. Should be 0 - 0x1F

RETURN VALUE:	isr function address from jump in vector table

SEE ALSO:		SetVectIntern, SetVectExtern, GetVectExtern
END DESCRIPTION ***************************************************************/
__nodebug
isr_ptr_type GetVectIntern(int vectNum)
{
#asm
	; table entries are 16 bytes
	ld 	de,16
	ld 	hl,(sp+vectNum)
	ld    bc,hl
	mul

	; INTVEC_BASE contains the internal vectable offset
	ld    hl, INTVEC_BASE

	; hl now points to the table entry
	add 	hl,bc

	; put the jump instruction first
	ld    hl,(hl+1)
#endasm
}

/*** BeginHeader SetVectExtern */
#define SetVectExtern3000 SetVectExtern
#define SetVectExtern4000 SetVectExtern
unsigned SetVectExtern(int interruptNum, void *isr);
/*** EndHeader */

/* START FUNCTION DESCRIPTION *************************************************
SetVectExtern						                                        <SYS.LIB>

SYNTAX:	unsigned SetVectExtern(int interruptNum, void *isr);

DESCRIPTION:	Function to set one of the external interrupt jump table
entries for the Rabbit CPU.  All Rabbit interrupts use jump vectors.
See SetVectIntern for more information.

The following table shows the vectNum argument that should be used for each
peripheral or RST. The offset into the vector table is also shown.

	Peripheral or RST                        vectNum   Vector Table	Rabbit 6000
																		Offset			Only
	-----------------------------------------------------------------------------
	External Interrupt 0							     0x00   0x0000
	External Interrupt 1								  0x01	0x0010
   External Interrupt 2                        0x02   0x0020 -------> X
   External Interrupt 3                        0x03   0x0030 -------> X
   External Interrupt 4**                      0x04   0x0040 -------> X
   Hardware Breakpoint Interrupt**				  0x04	0x0040
   External Interrupt 5                        0x05   0x0050 -------> X
   External Interrupt 6								  0x06	0x0060 -------> X
   External Interrupt 7                        0x07   0x0070 -------> X
   DMA 0													  0x08   0x0080 -------> X
   DMA 1													  0x09	0x0090
   DMA 2		                                   0x0A   0x00A0
   DMA 3		                                   0x0B   0x00B0
   DMA 4		                                   0x0C   0x00C0
   DMA 5		                                   0x0D   0x00D0
   DMA 6		                                   0x0E   0x00E0
   DMA 7		                                   0x0F   0x00F0
	[Reserved for Future Use]						  0x10	0x0100 -------> X
	[Reserved for Future Use]						  0x11	0x0110 -------> X
	[Reserved for Future Use]						  0x12	0x0120 -------> X
	[Reserved for Future Use]						  0x13	0x0130 -------> X
	Hardware Breakpoint Interrupt**				  0x14	0x0140 -------> X
	[Reserved for Future Use]						  0x15	0x0150 -------> X
	[Reserved for Future Use]						  0x16	0x0160 -------> X
	[Reserved for Future Use]                   0x17   0x0170 -------> X
	DMA 8													  0x18	0x0180 -------> X
	DMA 9													  0x19   0x0190 -------> X
	DMA 10												  0x1A   0x01A0 -------> X
	DMA 11												  0x1B	0x01B0 -------> X
	DMA 12												  0x1C   0x01C0 -------> X
	DMA 13												  0x1D   0x01D0 -------> X
	DMA 14					  							  0x1E	0x01E0 -------> X
	DMA 15												  0x1F	0x01F0 -------> X

 ** On the Rabbit 4000, the EIR table address of HW breakpoints was 0x0040.
    The required size of the EIR (XINTVEC_TABLE_SIZE) is 256 bytes.
 	 On the Rabbit 6000, the EIR table address of HW breakpoints was moved to
 	 0x0140.  The required size of the EIR is 512 bytes.

PARAMETER1: External interrupt number. 0-0x1F accepted for Rabbit 6000,
            otherwise 0-0x0F

PARAMETER2: ISR handler address. Must be a root address.

RETURN VALUE:	0					failed
					!=0				jump address in vector table

SEE ALSO:		GetVectExtern, SetVectIntern, GetVectIntern
END DESCRIPTION ***************************************************************/
__useix __nodebug
unsigned SetVectExtern(int interruptNum, void *isr)
{
#asm
	; check for invalid vector number
	ld		de,~((XINTVEC_TABLE_SIZE>>4)-1)
	and   hl,de
	jr    z,.vecNumOK
	clr	hl
	push  hl
	jr    .done
.vecNumOK:
	; table entries are 16 bytes
	ld 	de,16
	ld 	hl,(ix+interruptNum)
	ld    bc,hl
	mul

	; XINTVEC_BASE contains the external vectable offset/100h
	ld    hl, XINTVEC_BASE

	add	hl, bc	; hl now points to the table entry

	; put the jump instruction first
	ld    (hl),_OP_JP
	push  hl
	inc   hl
	ld		iy, hl

	; put the isr address next
	ld    hl,(ix+isr)
  	ld    (iy),hl

.done:
	; return the address of the vector table entry
	pop   hl
#endasm
}

/*** BeginHeader GetVectExtern */
#define GetVectExtern3000 GetVectExtern
isr_ptr_type GetVectExtern(int interruptNum);
/*** EndHeader */

/* START FUNCTION DESCRIPTION **************************************************
GetVectExtern						                                         <SYS.LIB>

SYNTAX:	void (*)() GetVectExtern(int interruptNum);

DESCRIPTION:	Function to read the address of an external interrupt
table entry.  This function really just returns whatever value is at
the address:  (external vector table base) + (interuptNum*16) + 1.

PARAMETER1: Interrupt number.

RETURN VALUE:	jump address in vector table

SEE ALSO:		SetVectExtern, SetVectIntern, GetVectIntern
END DESCRIPTION ***************************************************************/
__nodebug
isr_ptr_type GetVectExtern(int interruptNum)
{
#asm
	; table entries are 16 bytes
	ld 	de,16
	ld 	hl,(sp+interruptNum)
	ld    bc,hl
	mul

	; XINTVEC_BASE contains the external vectable offset/100
	ld    hl, XINTVEC_BASE

	; hl now points to the table entry
	add 	hl, bc

	; put the jump instruction first
	ld    hl,(hl+1)
#endasm
}


/*** BeginHeader	sysResetChain */

void sysResetChain(void);
void _sysResetChain(void);
#makechain	_sysResetChain

/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
sysResetChain                                                    <SYS.LIB>

SYNTAX:		sysResetChain(void);

DESCRIPTION:	Function chain that can be used to perform startup
actions such as initializing protected variables (called from
_sysIsSoftReset, which itself should be called at the start of a
program if you are using protected variables).
END DESCRIPTION **********************************************************/
__nodebug
void sysResetChain(void)
{
	_sysResetChain();
}

/*** BeginHeader	_sysIsSoftReset */

void _sysIsSoftReset(void);

/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
_sysIsSoftReset                                                  <SYS.LIB>

SYNTAX:		void _sysIsSoftReset(void);

DESCRIPTION:	This function should be called at the start of a program
if you are using protected variables.  It determines whether this restart
of the board is due to a software reset from Dynamic C or a call to
forceSoftReset().  If it was a soft reset, this function then does
the following:

 (1)	calls _prot_init() to initialize the protected variable
		mechanisms.  It is up to the user to initialize protected
		variables.

 (2)	Calls sysResetChain().  The user may attach functions to this
 		chain to perform additional startup actions (for example,
 		initializing protected variables).

If a soft reset did not take place, this function calls _prot_recover()
to recover any protected variables.
END DESCRIPTION **********************************************************/

#if (ZERO_OUT_STATIC_DATA==1)
#fatal "protected variables not usable with ZERO_OUT_STATIC_DATA = 1"
#endif

__nodebug
void _sysIsSoftReset(void)
{
	// was this a software-driven reset?
	if(_prot_needs_init() || chkSoftReset()) {

		// initialize protected variable flags
		_prot_init();

		// call software reset chain
		sysResetChain();

	} else {
	// reset was due to power fail or watchdog timeout

		// restore any protected variable
		_prot_recover();
	}
}


/*** BeginHeader	chkSoftReset */
__root int chkSoftReset(void);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
chkSoftReset                                                     <SYS.LIB>

SYNTAX:		int chkSoftReset(void);

DESCRIPTION:	This function determines whether the last restart of the
board was due to a software reset from Dynamic C or a call to
forceSoftReset(), or from some other reason.

SEE ALSO:		chkHardReset, chkWDTO, forceSoftReset

RETURN VALUE:	1 if the board was restarted due to a soft reset,
					0 if it was not.
END DESCRIPTION **********************************************************/

#asm
chkSoftReset::
	clr	hl
	ld		a, (reset_status)
	and	0xC0
	cp		0x00
	jr		nz, .ret0
.ret1:
	inc	hl
.ret0:
	ret
#endasm


/*** BeginHeader chkHardReset */
__root int chkHardReset(void);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
chkHardReset                                                     <SYS.LIB>

SYNTAX:		int chkHardReset(void);

DESCRIPTION:	This function determines whether this restart of the
board is due to a hardware reset. Asserting the RESET line or recycling
power are both considered hardware resets. A watchdog timeout is not
a hardware reset.

SEE ALSO:		chkSoftReset, chkWDTO, forceSoftReset

RETURN VALUE:	1 if the processor was restarted due to a hardware reset,
					0 if it was not.
END DESCRIPTION **********************************************************/

#asm
chkHardReset::
	clr	hl
	ld		a, (reset_status)
	and	0xC0
	cp		0xC0
	jr		nz, .ret0
.ret1:
	inc	hl
.ret0:
	ret
#endasm


/*** BeginHeader chkWDTO */
__root int chkWDTO(void);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
chkWDTO	                                                        <SYS.LIB>

SYNTAX:		int chkWDTO(void);

DESCRIPTION:	This function determines whether this restart of the
board is due to a watchdog timeout.

SEE ALSO:		chkSoftReset, chkHardReset, forceSoftReset

RETURN VALUE:	1 if the board was restarted due to a watchdog timeout,
					0 if it was not.
END DESCRIPTION **********************************************************/

#ifdef _WDTO_ASSERTS_RESET_
   // Certain boards such as the Rabbit 4000 based serial flash boot
   //  boards have a design requirement that /WDOUT assert /RESET.
   //  The external reset wins when checking the cause of the
   //  reset. The reset_status variable is set in the BIOS
   //  on start-up.
   #warns "Resets caused by watchdog timeout will create and report"
   #warns "a hardware reset on this board."
#endif

#asm
chkWDTO::
	clr	hl
	ld		a, (reset_status)
	and	0xC0
	cp		0x40
	jr		nz, .ret0
.ret1:
	inc	hl
.ret0:
	ret
#endasm


/*** BeginHeader	forceSoftReset */
__root void forceSoftReset(void);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
forceSoftReset                                                   <SYS.LIB>

SYNTAX:		void forceSoftReset(void);

DESCRIPTION:	For a program not compiled for RabbitSys, forces the board into a
               software reset by jumping to the start of the BIOS.
               For a RabbitSys user mode program, this function requests
               RabbitSys to restart the user program.

SEE ALSO:		chkSoftReset, chkHardReset, chkWDTO, forceWatchdogTimeout

RETURN VALUE:	None.
END DESCRIPTION **********************************************************/

#asm
forceSoftReset::
	;; perform a 'soft' reset by restarting the BIOS
	jp		_biosentry_
#endasm

/*** BeginHeader	forceWatchdogTimeout */
__root void forceWatchdogTimeout(void);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
forceWatchdogTimeout                                             <SYS.LIB>

SYNTAX:		void forceWatchdogTimeout(void);

DESCRIPTION:	Disables interrupts and waits for a watchdog timeout to reset
					the board.

					It is usually better to use exit() to reboot, as it will call
					all registered atexit() handlers and flush and close any open
					file handles before rebooting.

SEE ALSO:		chkSoftReset, chkHardReset, chkWDTO, forceSoftReset

RETURN VALUE:	None.
END DESCRIPTION **********************************************************/

#asm
forceWatchdogTimeout::
		ipset	3					; disable interrupts
		ld		a, 0x53			; 1/4 second timeout
ioi	ld		(WDTCR), a
_waitfortimeout:
		jr		_waitfortimeout
#endasm

/*** BeginHeader	Disable_HW_WDT */
__root void Disable_HW_WDT(void);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
Disable_HW_WDT                                                   <SYS.LIB>

SYNTAX:		void Disable_HW_WDT(void);

DESCRIPTION: Disables the hardware watchdog timer on the Rabbit processor.
The watchdog is hit by the periodic interrupt, which is on by default.
This function is is useful for special situations such as low power
"sleepy mode."

The WD timer can be re-enabled by calling Enable_HW_WDT() or by simply
writing  any value except 0x51,0x52,0x53, or 0x5e to WDTTR.

RETURN VALUE:	None.
END DESCRIPTION **********************************************************/

#asm __root
Disable_HW_WDT::
			ld a,0x51
	ioi  	ld (WDTTR),a
			ld a,0x54
	ioi  	ld (WDTTR),a
	ret
#endasm

/*** BeginHeader	Enable_HW_WDT */
__root void Enable_HW_WDT(void);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
Enable_HW_WDT                                                    <SYS.LIB>

SYNTAX:		void Enable_HW_WDT(void);

DESCRIPTION: Enables the hardware watchdog timer on the Rabbit processor.
The watchdog is hit by the periodic interrupt, which is on by default.

RETURN VALUE:	None.
END DESCRIPTION **********************************************************/

#asm __root
Enable_HW_WDT::
	xor a
	ioi  	ld (WDTTR),a
	ret
#endasm


/*** BeginHeader	setClockModulation */
__xmem void setClockModulation(int setting);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
setClockModulation                                               <SYS.LIB>

SYNTAX:			void setClockModulation(int setting);

DESCRIPTION:	Changes the setting of the Rabbit CPU clock
moduation.  Calling this function will force a 500 clock delay before
the setting is changed to ensure that the previous moduation setting
has cleared before the next one is set.  See the "Rabbit 4000
Microprocessor User's Manual" for more details about clock modulation
for EMI reduction.

Rabbit 6000 note: with clock speeds from about 50-100MHz, only the
weakest modulation setting (3) will work.  At speeds above 100MHz,
it is not possible to use any modulation.

If an inappropriate modulation setting is selected, the processor
will crash.  The reason for this is because, with modulation enabled,
memory and I/O cycle timings may be violated.

PARAMETER1:		Clock modulation setting.  Allowed values are:
							0 = no modulation
							1 = weak modulation (1ns steps)
							2 = strong modulation (2ns steps)
							For Rabbit 6000 processors only:
							3 = even weaker modulation for clock speeds
								 in range 50-100MHz	(0.5ns steps)
					Any other value: may crash the processor.

END DESCRIPTION **********************************************************/

void _delay500clocks(void);

__xmem __nodebug
void setClockModulation(int setting)
{
	if (setting == 0) {
		WrPortI(GCM1R, &GCM1RShadow, GCM1RShadow & ~0x80);	// disable modulation
	}
	else {
		WrPortI(GCM1R, &GCM1RShadow, GCM1RShadow & ~0x80);	// disable modulation
		_delay500clocks();
	   switch (setting) {
	   case 1: // enable weak spreading
	      WrPortI(GCM0R, &GCM0RShadow, GCM0RShadow & ~0xC0);
	   	break;
	   case 2: // enable strong spreading
	      WrPortI(GCM0R, &GCM0RShadow, GCM0RShadow & ~0xC0 | 0x80);
	      break;
	   #if _RAB6K
	   case 3: // enable weaker spreading for high clock speeds
	      WrPortI(GCM0R, &GCM0RShadow, GCM0RShadow & ~0xC0 | 0x40);
	      break;
	   #endif
	   default:
	   	break;
		}
		WrPortI(GCM1R, &GCM1RShadow, GCM1RShadow | 0x80);	// reenable modulation
	}
}

#asm
_delay500clocks::
	ld		b, 100
.delayloop:
	djnz	.delayloop	// 5 clocks * 100 = 500 clocks (plus call/return time)
	ret
#endasm

/*** BeginHeader */
//256 byte table of bytes with reversed order bits i.e.
// BitRevTable[B'00000010] == B'01000000

// Already have this table in BIOSLIB/UTIL.LIB, so make an alias to it instead
// of creating const char BitRevTable[256].
#define BitRevTable RevBitTable
/*** EndHeader */

/*** BeginHeader get_reset_status */
int get_reset_status (void);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
get_reset_status                                                 <SYS.LIB>

SYNTAX:			int get_reset_status (void);

DESCRIPTION:	return the value of "reset_status".

PARAMETER:		none.

RETURN VALUE:	reason for reset:
					0xCn		hard reset
					0x4n		hardware watchdog timeout
					0x0n		soft reset

END DESCRIPTION **********************************************************/
__nodebug
int get_reset_status(void)
{
	return reset_status;
}

/*** BeginHeader TAT1R_SetValue */
char TAT1R_SetValue(int requestor, int value);
#define TAT1R_RELEASE_REQ	0x0100	// int value just outside the range of char
// all of the following TAT1R_*TIMER_REQ macros must be unique w.r.t. each other
#define TAT1R_BTIMER_REQ	0x0100	// bit 08 == timer B
#define TAT1R_CTIMER_REQ	0x0200	// bit 09 == timer C
#define TAT1R_A1TIMER_REQ	0x0002	// bit 01 == timer A1
// also, do not change any of the following TAT1R_A.TIMER_REQ macro definitions
//  (they correspond to their bitmask in the TACR)
#define TAT1R_A2TIMER_REQ	0x0004	// bit 02 == timer A2 (eg: serial port E);
#define TAT1R_A3TIMER_REQ	0x0008	// bit 03 == timer A3 (eg: serial port F);
#define TAT1R_A4TIMER_REQ	0x0010	// bit 04 == timer A4 (eg: serial port A);
#define TAT1R_A5TIMER_REQ	0x0020	// bit 05 == timer A5 (eg: serial port B);
#define TAT1R_A6TIMER_REQ	0x0040	// bit 06 == timer A6 (eg: serial port C);
#define TAT1R_A7TIMER_REQ	0x0080	// bit 07 == timer A7 (eg: serial port D);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
TAT1R_SetValue                                                   <SYS.LIB>

SYNTAX:
   char TAT1R_SetValue(int requestor, int value);

DESCRIPTION:
   If not already in use, or if in a compatible use, allocates the TAT1R
   resource (sets a new or keeps the current TAT1R value) as requested.
   Also enables or disables the requestor's timer A1 cascade bit(s) in
   TACR or TBCR, as appropriate.  When the timer B cascade from timer A1
   is disabled in TBCR the timer B "clocked by PCLK/2" is then enabled.

   A run time error occurs if parameter(s) are invalid.

   Note that this function does not attempt to manage interrupts that are
   associated with timers A or B; that work is left entirely up to the
   application.

   This function is not reentrant.

PARAMETER1:
   The requestor of the TAT1R resource.  Use exactly one of the following
   macros to specify the appropriate requestor:
      TAT1R_A1TIMER_REQ (eg: for direct use of Timer A1)
      TAT1R_A2TIMER_REQ (eg: for use by serial port E)
      TAT1R_A3TIMER_REQ (eg: for use by serial port F)
      TAT1R_A4TIMER_REQ (eg: for use by serial port A)
      TAT1R_A5TIMER_REQ (eg: for use by serial port B)
      TAT1R_A6TIMER_REQ (eg: for use by serial port C)
      TAT1R_A7TIMER_REQ (eg: for use by serial port D)
      TAT1R_BTIMER_REQ  (eg: for use with PWM, servo or triac)
      TAT1R_CTIMER_REQ  (eg: for use with Timer C)

PARAMETER2:
   Either the new TAT1R setting value (0 through 255, inclusive), or the
   macro TAT1R_RELEASE_REQ to release the TAT1R resource in use by the
   specified requestor.

RETURN VALUE:
   The new or current TAT1R setting.  The caller should check their
   requested new TAT1R value against this return value.  If the two values
   are not the same, the caller may decide the return value is acceptable
   after all and make another request using the previous return value.  A
   valid release request always succeeds; in this case there is no need
   for the caller to check the return value.
END DESCRIPTION *********************************************************/
__nodebug
char TAT1R_SetValue(int requestor, int value)
{
	static int requestors_bitmap = 0;
	int TxCR;
	char *TxCRShadowPtr;

	if (0 > value || TAT1R_RELEASE_REQ < value) {
		// unknown TAT1R setting value parameter
		exception(-ERR_BADPARAMETER);
		exit(-ERR_BADPARAMETER);
	}

	switch (requestor) {
	default:
		// unknown requestor parameter
		exception(-ERR_BADPARAMETER);
		exit(-ERR_BADPARAMETER);
//		break;
	case TAT1R_A1TIMER_REQ:
	case TAT1R_A2TIMER_REQ:
	case TAT1R_A3TIMER_REQ:
	case TAT1R_A4TIMER_REQ:
	case TAT1R_A5TIMER_REQ:
	case TAT1R_A6TIMER_REQ:
	case TAT1R_A7TIMER_REQ:
		// A timer A1 requestor just sets or releases TAT1R, but extra
		//  (cascade) processing is done for timer A7 through A2 requestors.
		if (TAT1R_RELEASE_REQ == value) {
			if (TAT1R_A1TIMER_REQ != requestor) {
				// disable this requestor's timer A1 to timer Ax cascade
				WrPortI(TACR, &TACRShadow, TACRShadow & (char) (~requestor));
			}
			// reset this requestor's bit flag to indicate its release of TAT1R
			requestors_bitmap &= ~requestor;
		}
		else if (!requestors_bitmap || requestor == requestors_bitmap ||
		         value == TAT1RShadow)
		{
			// set this requestor's bit flag to indicate its use of TAT1R
			requestors_bitmap |= requestor;
			if (value != TAT1RShadow) {
				// set the new TAT1R value
				//  (Assumption:  This is OK because to get here we must be the
				//                sole requestor.)
				//  (NB: The above assumption is a major reason why this function
				//       is not reentrant.)
				WrPortI(TAT1R, &TAT1RShadow, value);
			}
			if (TAT1R_A1TIMER_REQ != requestor) {
				// enable this requestor's timer A1 to timer Ax cascade
				WrPortI(TACR, &TACRShadow, TACRShadow | (char) requestor);
			}
		}
		break;
	case TAT1R_BTIMER_REQ:
		TxCR = TBCR;
		TxCRShadowPtr = &TBCRShadow;
		goto bc_common;

	case TAT1R_CTIMER_REQ:
		TxCR = TCCR;
		TxCRShadowPtr = &TCCRShadow;
	bc_common:
		//  Cascade processing is always done for a timer B/C requestor.
		if (TAT1R_RELEASE_REQ == value) {
			// disable this requestor's timer A1 to timer B/C cascade by enabling
			//  (i.e. resetting to) timer B/C "clocked by PCLK/2" instead
			WrPortI(TxCR, TxCRShadowPtr, *TxCRShadowPtr & (char) 0xF3);
			// reset this requestor's bit flag to indicate its release of TAT1R
			requestors_bitmap &= ~requestor;
		}
		else if (!requestors_bitmap || requestor == requestors_bitmap ||
		         value == TAT1RShadow)
		{
			// set this requestor's bit flag to indicate its use of TAT1R
			requestors_bitmap |= requestor;
			if (value != TAT1RShadow) {
				// set the new TAT1R value
				//  (Assumption:  This is OK because to get here we must be the
				//                sole requestor.)
				//  (NB: The above assumption is a major reason why this function
				//       is not reentrant.)
				WrPortI(TAT1R, &TAT1RShadow, value);
			}
			// enable this requestor's timer A1 to timer B/C cascade
			WrPortI(TxCR, TxCRShadowPtr, (*TxCRShadowPtr & 0xF3) | 0x04);
		}
//		break;
	}

	return TAT1RShadow;
}

/*** BeginHeader SetSerialTATxRValues */
long SetSerialTATxRValues(long bps, char *divisor, int tatXr);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
SetSerialTATxRValues                                             <SYS.LIB>

SYNTAX:
   long SetSerialTATxRValues(long bps, char *divisor, int tatXr);

DESCRIPTION:
   Sets up the possibly shared serial timers (TATxR) resources required to
   achieve, as closely as possible, the requested serial bps rate.  The
   algorithm used in this function attempts to find, when necessary and if
   possible, the lowest value for the TAT1R that will precisely produce
   the requested serial bps rate.  For this reason, an application which
   requires the TAT1R to be shared should generally first set up its usage
   with (1) the most critical timer A1 cascade rate, or (2) the lowest
   timer A1 cascade rate.  I.E.:  Consider setting up the most critical
   usage (PWM, servo, triac, ultra-precise serial rate, etc.) first, else
   set up the slowest usage (often, the lowest serial rate) first.

   Note that this function provides no TATxR resource sharing protection
   for an application which uses any of the individual TATxR resources
   both directly and indirectly.  EG: This function affords no protection
   to an application which sets a direct usage TAT7R timer interrupt and
   also opens serial port D such that TAT7R is used to set the serial data
   rate.

   A run time error occurs if parameter(s) are invalid.

   This function is not reentrant.

PARAMETER1:
   The requested serial bits per second (BPS, baud) rate.

PARAMETER2:
   An optional pointer to the caller's serial timer divisor variable.  If
   the caller is not interested in the actual serial timer (TATxR) divisor
   value that is set by this function, then NULL may be passed.

PARAMETER3:
   The TATxR for the serial timer whose value(s) are to be set.  Use
   exactly one of the following macros:
      TAT4R for serial port A
      TAT5R for serial port B
      TAT6R for serial port C
      TAT7R for serial port D
      TAT2R for serial port E
      TAT3R for serial port F

RETURN VALUE:
   The actual serial rate BPS (baud) setting that was achieved.

SEE ALSO:
   TAT1R_SetValue
END DESCRIPTION *********************************************************/
__nodebug
long SetSerialTATxRValues(long bps, char *divisor, int tatXr)
{
	auto char tat1r_result, *tatXr_shadow;
	auto int i, requestor, ta1div;
	auto long actual_bps, my_divisor;

	if (0L >= bps) {
		// invalid bps parameter value!
		exception(-ERR_BADPARAMETER);
		exit(-ERR_BADPARAMETER);
	}

	// set up our serial port's timers information
	switch (tatXr) {
	default:	// invalid tatXr parameter value!
		exception(-ERR_BADPARAMETER);
		exit(-ERR_BADPARAMETER);
//		break;
	case TAT4R:	// serial port A
		requestor = TAT1R_A4TIMER_REQ;
		tatXr_shadow = &TAT4RShadow;
		break;
	case TAT5R:	// serial port B
		requestor = TAT1R_A5TIMER_REQ;
		tatXr_shadow = &TAT5RShadow;
		break;
	case TAT6R:	// serial port C
		requestor = TAT1R_A6TIMER_REQ;
		tatXr_shadow = &TAT6RShadow;
		break;
	case TAT7R:	// serial port D
		requestor = TAT1R_A7TIMER_REQ;
		tatXr_shadow = &TAT7RShadow;
		break;
	case TAT2R:	// serial port E
		requestor = TAT1R_A2TIMER_REQ;
		tatXr_shadow = &TAT2RShadow;
		break;
	case TAT3R:	// serial port F
		requestor = TAT1R_A3TIMER_REQ;
		tatXr_shadow = &TAT3RShadow;
//		break;
	}

	// (my_divisor+1) for 19200 baud is stored in BIOS variable "freq_divider"
	my_divisor = (((long) freq_divider * 19200L) + ((bps + 1) >> 1)) / bps;

	if (0x10000L < my_divisor) {
		// this will get as close as we can get to the requested low baud rate
		my_divisor = 0x10000L;
		ta1div = 256;
	} else {
		// start with ta1div == 2^^0
		ta1div = 1;
		// We prefer to divide by powers of two so long as no precision is lost.
		while (!(my_divisor / (long) ta1div & 1L) &&
		       my_divisor / (long) ta1div > 256L && ta1div < 256)
		{
			ta1div <<= 1;
		}
		// We've either done as much division by two as is necessary, or perhaps
		//  as is possible without loss of precision.
		// If necessary and possible, we'll calculate some larger ta1div value to
		//  divide by and take our chances with introducing loss of precision.
		while (my_divisor / (long) ta1div > 256L && ta1div < 256) {
			++ta1div;
		}
		// Now ensure, if possible, an exact divider pair.
		for (i = ta1div; i <= 256; ++i) {
			// We do the following test calculation in two steps in an attempt to
			//  prevent any possible optimizations by the compiler that would
			//  eliminate an integer division truncation.
			actual_bps = my_divisor / (long) i;	// intermediate test temp value
			actual_bps *= (long) i;	// final test temp value
			if (actual_bps == my_divisor) {
				ta1div = i;
				break;
			}
		}
	}

	// is the timer A1 cascade actually needed?
	if (1 < ta1div) {
		// yes, enable the timer A1 cascade
		// timer constant registers' value is "n-1" when dividing by "n"
		tat1r_result = TAT1R_SetValue(requestor, ta1div - 1);
		if (ta1div - 1 != (int) tat1r_result) {
			ta1div = 1 + (int) TAT1R_SetValue(requestor, tat1r_result);
		}
		// finally, update our local divisor value
		my_divisor /= (long) ta1div;
	} else {
		// no, ensure the timer A1 cascade is disabled (always succeeds)
		/*tat1r_result =*/ TAT1R_SetValue(requestor, TAT1R_RELEASE_REQ);
	}
	// one-byte timer constant registers' value is "n-1" when dividing by "n"
	ta1div -= 1;
	ta1div &= 0xFF;
	my_divisor -= 1L;
	my_divisor &= 0xFFL;
	WrPortI(tatXr, tatXr_shadow, (char) my_divisor);

	actual_bps = ((long) freq_divider * 19200L) /
	             ((my_divisor + 1L) * ((long) ta1div + 1L));
	if (divisor) {
		// the caller wants to know the actual TATxR divisor value setting
		*divisor = (char) my_divisor;
	}
	return actual_bps;
}


/*** BeginHeader get_cpu_frequency */

unsigned long get_cpu_frequency(void);

/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
get_cpu_frequency                                                <SYS.LIB>

SYNTAX:
   unsigned long get_cpu_frequency(void);

DESCRIPTION:
   Returns the clock speed of CPU as calculated by the BIOS, adjusted for
   the clock doubler if it is enabled.  Due to the limited precision of the
   clock speed calculation, the calculated and actual clock speeds may
   differ slightly.

   For the Rabbit 6000, special bits in the Watchdog timer I/O registers
   keep track of the CPU speed, and these are used to determine the current
   CPU speed.

RETURN VALUE:
   The clock speed of the CPU in Hz.

END DESCRIPTION *********************************************************/
__nodebug
unsigned long get_cpu_frequency(void)
{
   unsigned long retval;

   if ((RdPortI(GCSR) & 0x18) ==  0x10)
   	// Running from 32kHz clock
   	switch (RdPortI(GPSCR) & 0x7) {
   		default: return 32768;
   		case 0x04: return 16384;
   		case 0x05: return 8192;
   		case 0x06: return 4096;
   		case 0x07: return 2048;
   	}

#if CPU_ID_MASK(_CPU_ID_) < R6000
	// Don't have direct measurement capability, need to rely on
	// initial BIOS clock measurement.
   retval = (unsigned long)bios_timer_count * 7200L;
   switch (RdPortI(GCSR) & 0x1C) {
   default: break;
   case 0x00: retval /= 8; break;
   case 0x0C: retval /= 2; break;
   case 0x18: retval /= 4; break;
   case 0x1C: retval /= 6; break;
   }
   if ((RdPortI(GCDR) & 0x1F) > 0)  //if clock doubler is enabled
      retval <<= 1;                 //double result
#else
 // The R6000 has some handy special bits in the WDT regs
 //  that report the CPU speed (divided by 32768).
 #asm
.cpuGFloop:
ioi	ld 	(RTC0R), a
ioi	ld 	hl, (RTC0R)
		ld 	de, (cpuGf_spd_chg)
		cp		hl, de        ; Wait until current RTC is different from
		jr		z, .cpuGFloop ;  when originally stamped
		inc	de
		cp		hl, de        ; Also, make sure more than a few periods have
		jr		z, .cpuGFloop ;  passed in case the CPU was just changed, since
            	           ;  we need enough clocks to sample properly.

ioi   ld    hl, (WDTCR)   ; WDTCR has MS bits, WDTTR (WDTCR+1) 5:0 has LS bits
		ld    a, 0x3F
		and   h
		ld    h, a
		ex    bc, hl        ; Now BC has (CPU speed)/0x8000
		ld    de, 0x8000
		mulu                ; Now HL:BC has CPU speed
		ex    bc, hl        ; Now BC:HL has CPU speed
		ex    de, hl        ; Now BC:DE has CPU speed
		ld 	(sp+@SP+retval),bcde
 #endasm
#endif
   return retval;
}

/*** BeginHeader  ********************************************/
#endif
/*** EndHeader ***********************************************/